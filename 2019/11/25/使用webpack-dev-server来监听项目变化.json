{
    "attributes": {
        "title": "使用webpack-dev-server来监听项目变化",
        "date": "2019-11-25T17:54:36.000Z",
        "tags": "Vue",
        "categories": "Vue"
    },
    "body": "<p>webpack的出现方便了前端开发者，使开发和部署分成了两部分，开发者可以正常根据工程化的要求进行开发，部署时通过webpack实现代码的裁剪和优化。\n本次就介绍一个webpack的功能 <code>webpack-dev-server</code>\n将webpack与提供实时重载的开发服务器一起使用。这仅应用于开发。\n它在后台使用了webpack-dev-middleware，它提供了对Webpack资产的快速内存访问。\nwebpack-dev-server提供了一个小型的express的http服务器，这个http服务器和client使用了websocket通讯协议，原始文件作出改动后，webpack-dev-server会实时的编译，但是最后的编译的文件并没有输出到目标文件夹。\n<strong>注意：启动webpack-dev-server后，在目标文件夹中是看不到编译后的文件的,编译后的文件都保存到了内存当中来加速访问。</strong></p>\n<h2>启用webpack-dev-server</h2>\n<pre><code>npm install -D webpack-dev-server\n</code></pre>\n<p>在webpack.config.js中添加devServer对象：</p>\n<pre><code>var path = require('path');\nmodule.exports = {\n  //...\n  devServer: {\n    contentBase: path.join(__dirname, 'dist'),\n    compress: true, // 开启压缩\n    port: 9000 // 指定运行的端口\n  }\n};\n</code></pre>\n<p>然后通过<code>npx webpack-dev-server</code>启动，终端上会输出一些信息，一般我们会增加一些参数来使输出更加好看:</p>\n<pre><code>webpack-dev-server --devtool eval-source-map --progress --colors --hot --inline\n</code></pre>\n<p>上面的命令增加一个开发工具 <code>eval-source-map</code>，开启了progress进度显示，开启了colors颜色，hot热更新和inline更新模式。上面的参数也可以添加到devServer的属性中。\n终端输出的内容如下:</p>\n<pre><code>10% building 1/1 modules 0 activeℹ ｢wds｣: Project is running at http://localhost:9000/\nℹ ｢wds｣: webpack output is served from /dist/\nℹ ｢wds｣: Content not from webpack is served from /home/justforlxz/Projects/VueBlog/dist\nℹ ｢wdm｣: Hash: ff9005d9f6ffafd11cd4\nVersion: webpack 4.41.0\nTime: 2938ms\nBuilt at: 11/25/2019 6:03:50 PM\n  Asset      Size  Chunks             Chunk Names\nmain.js  2.09 MiB    main  [emitted]  main\nEntrypoint main = main.js\n[0] multi (webpack)-dev-server/client?http://localhost:9000 (webpack)/hot/dev-server.js ./src/main.ts 52 bytes {main} [built]\n</code></pre>\n<p>我们就可以通过localhost:9000来访问我们的应用了。\n需要注意的是，由于我们经常把内容输出到dist目录，但是webpack运行是在项目目录的，访问webpack生成在dist目录的main.js时，需要写上相对于webpack的目录，例如dist/main.js。否则会找不到文件。\n如果遇到问题，导航到 /webpack-dev-server 路径，可以显示出文件的服务位置。 例如，http://localhost:9000/webpack-dev-server。</p>\n<h2>配置webpack</h2>\n<p>webpack-dev-server支持在服务内部调用中间件对数据进行处理。</p>\n<h3>devServer.before</h3>\n<p><code>function (app, server)</code>\n在服务内部的所有其他中间件之前， 提供执行自定义中间件的功能。 这可以用来配置自定义处理程序，例如：</p>\n<pre><code>module.exports = {\n  //...\n  devServer: {\n    before: function(app, server) {\n      app.get('/some/path', function(req, res) {\n        res.json({ custom: 'response' });\n      });\n    }\n  }\n};\n</code></pre>\n<h3>devServer.after</h3>\n<p>同devServer.before，在服务内部的所有中间件之后，提供执行自定义中间件的功能。</p>\n<h3>devServer.allowedHosts</h3>\n<p>允许添加白名单服务，允许一些开发服务器访问。</p>\n<pre><code>module.exports = {\n  //...\n  devServer: {\n    allowedHosts: [\n      'host.com',\n      'subdomain.host.com',\n      'subdomain2.host.com',\n      'host2.com'\n    ]\n  }\n};\n</code></pre>\n<p>模仿 django 的 ALLOWED_HOSTS，以 . 开头的值可以用作子域通配符。.host.com 将会匹配 host.com, www.host.com 和 host.com 的任何其他子域名。</p>\n<pre><code>module.exports = {\n  //...\n  devServer: {\n    // 这实现了与第一个示例相同的效果，\n    // 如果新的子域名需要访问 dev server，\n    // 则无需更新您的配置\n    allowedHosts: [\n      '.host.com',\n      'host2.com'\n    ]\n  }\n};\n</code></pre>\n<h3>devServer.clientLogLevel</h3>\n<p><code>string: 'none' | 'info' | 'error' | 'warning'</code>\n当使用内联模式(inline mode)时，会在开发工具(DevTools)的控制台(console)显示消息，例如：在重新加载之前，在一个错误之前，或者 模块热替换(Hot Module Replacement) 启用时。默认值是 info。\ndevServer.clientLogLevel 可能会显得很繁琐，你可以通过将其设置为 'none' 来关闭 log。</p>\n<pre><code>module.exports = {\n  //...\n  devServer: {\n    clientLogLevel: 'none'\n  }\n};\n</code></pre>\n<h3>devServer.color  - 只用于命令行工具(CLI)</h3>\n<p>只在终端下启用，启用/禁用控制台的彩色输出。</p>\n<pre><code>webpack-dev-server --color\n</code></pre>\n<h3>devServer.compress</h3>\n<p><code>boolean</code>\n一切服务都开启gzip压缩。</p>\n<pre><code>module.exports = {\n  //...\n  devServer: {\n    compress: true\n  }\n};\n</code></pre>\n<h3>devServer.contentBase</h3>\n<p><code>boolean: false string [string] number</code>\n告诉服务器从哪个目录中提供内容。只有在你想要提供静态文件时才需要。devServer.publicPath 将用于确定应该从哪里提供 bundle，并且此选项优先。\n默认情况下，将使用当前工作目录作为提供内容的目录。将其设置为 false 以禁用 contentBase。</p>\n<pre><code>module.exports = {\n  //...\n  devServer: {\n    contentBase: path.join(__dirname, 'public')\n  }\n};\n</code></pre>\n<p>也可以从多个目录提供内容：</p>\n<pre><code>module.exports = {\n  //...\n  devServer: {\n    contentBase: [path.join(__dirname, 'public'), path.join(__dirname, 'assets')]\n  }\n};\n</code></pre>\n<h3>devServer.disableHostCheck</h3>\n<p><code>boolean</code>\n设置为 true 时，此选项绕过主机检查。不建议这样做，因为不检查主机的应用程序容易受到 DNS 重新连接攻击。</p>\n<pre><code>module.exports = {\n  //...\n  devServer: {\n    disableHostCheck: true\n  }\n};\n</code></pre>\n<h3>devServer.filename</h3>\n<p><code>string</code>\n在 lazy mode(惰性模式) 中，此选项可减少编译。 默认在 lazy mode(惰性模式)，每个请求结果都会产生全新的编译。使用 filename，可以只在某个文件被请求时编译。\n如果 output.filename 设置为 'bundle.js' ，devServer.filename 用法如下：</p>\n<pre><code>module.exports = {\n  //...\n  output: {\n    filename: 'bundle.js'\n  },\n  devServer: {\n    lazy: true,\n    filename: 'bundle.js'\n  }\n};\n</code></pre>\n<p>现在只有在请求了bundle.js时，才会去编译bundle。</p>\n<h2>总结</h2>\n<p>webpack的功能确实很强大，可以针对代码进行各种操作，最终生成出可以适应各种场景的代码，使开发和部署彻底分离开来，开发者可以更加专注项目。</p>\n",
    "id": "6d39c7c84d7c4c365d3e55d6e1676429",
    "link": "/2019/11/25/使用webpack-dev-server来监听项目变化"
}