<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小竹&#39;s blog</title>
  
  <subtitle>永远不要停止思考</subtitle>
  <link href="https://blog.justforlxz.com/atom.xml" rel="self"/>
  
  <link href="https://blog.justforlxz.com/"/>
  <updated>2020-09-17T08:26:18.368Z</updated>
  <id>https://blog.justforlxz.com/</id>
  
  <author>
    <name>小竹</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用rEFInd来安全启动系统</title>
    <link href="https://blog.justforlxz.com/2020/09/08/use-refind-to-boot-system/"/>
    <id>https://blog.justforlxz.com/2020/09/08/use-refind-to-boot-system/</id>
    <published>2020-09-08T19:54:26.000Z</published>
    <updated>2020-09-17T08:26:18.368Z</updated>
    
    <content type="html"><![CDATA[<p>今年的七夕，我老婆给我买了一台surface laptop 2代，8G内存 + 256G存储版本，我也成功的用上了田牌的机器。</p><a id="more"></a><blockquote><p>2020/09/17更新： 不知道为啥，反正是开了对内核签名以后，哪怕是BIOS关闭了安全启动，仍然出现mkinitcpio会卡在autodetect上，无奈全部都删掉重来了，没有弄签名，希望各位看到本文章以后解决了这个问题能回复一下，谢谢。</p></blockquote><p>surface默认是开启了安全启动(Microsoft签名)和bitlocker来保障设备和系统安全，我作为一个linux系统的开发者，当然是需要在surface上装一个linux了，但是前两年zccrs已经踩过坑了，linux不识别surface键盘，同样的触摸、网卡、声卡等设备也工作的不是很正常，本来以为我要开启远程开发的生活了，还特意写了一篇<a href="https://blog.justforlxz.com/2020/09/03/use-vscode-to-remotely-develop-dde/">《使用VSCode远程开发DDE》</a>，来给公司里有同样烦恼的人，让他们也感受一下远程开发的魅力。</p><p>苍天不负有心人，我成功的！</p><p>我成功的使用上了ArchLinux,并且工作的十分良好。这多亏了github上的一个组织<a href="https://github.com/linux-surface/linux-surface/">linux-surface</a>，有这么一些人，他们付出劳动来让手里的surface设备也用上linux,并且要和普通的x86兼容机一样工作，感谢他们的付出，也让我吃上了螃蟹，安装的过程我就不在这里详细说了，其实非常简单。</p><p>首先因为surface只有一个usb口，而键盘并不能工作，所以需要一个usb的扩展器。先按fn+f6进bios关闭掉安全启动，修改引导顺序为usb优先，之后就是正常的安装系统，但是不需要安装仓库里的内核，我们需要安装linux-surface提供的仓库里的内核。</p><p>这些都是非常正常的步骤，linux-surface提供了自己的仓库和内核，我们正常使用即可。</p><p>这里开始就是我研究了半天的内容， <strong>开启安全模式!</strong></p><p>首先我看了一下arch wiki上有关于安全启动的内容，写的挺详细的，就是看不懂。讲了各种的知识点，各种签名的方式，但是真正到我开始用的时候，我是一直失败的，失败的方式我就不说了，直接说我如何成功的。</p><p>首先我放弃了grub,一个原因是grub的安全启动我一直没有尝试成功，另外一个是我只有一个系统，没必要用grub。我换成了rEFInd来作为我的bootloader，首先安装rEFInd的引导。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yay -S refind shim-signed sbsigntools</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo refind-install --shim &#x2F;usr&#x2F;share&#x2F;shim-signed&#x2F;shimx64.efi --localkeys</span><br></pre></td></tr></table></figure><p>来解释一下上面两条明令。第一个是安装必要的软件包，refind是bootloader本体，shim-signed是aur里面的用于安全启动的包，shim提供了一种并行的安全启动验证功能，我们使用它来启动refind的efi,再通过refind的efi启动内核，达到终极套娃启动。sbsigntools是用于给文件签名的工具，我们安装完refind以后，refind会帮助我们生成一份默认的key,我们需要使用这个key来为内核进行签名。</p><p>在执行第二条明令以后，会有几次询问，都选择Y回车就行。</p><p>然后使用sbsigntools来对内核进行签名。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo sbsign --key &#x2F;etc&#x2F;refind.d&#x2F;keys&#x2F;refind_local.key --cert &#x2F;etc&#x2F;refind.d&#x2F;keys&#x2F;refind_local.crt --output &#x2F;boot&#x2F;vmlinuz-linux-surface &#x2F;boot&#x2F;vmlinuz-linux-surface</span><br></pre></td></tr></table></figure><p>准备工作已经进行一半了，我们只需要写一下refind的配置文件，就可以启动了。</p><p>refind的配置文件有两个地方，一个是boot分区下面的refind_linux.conf，还有一个是在efi分区里的EFI/refind/refind.conf，我们需要修改的是后者。</p><p>默认配置文件都是注释的，其实我们全部删了就可以了，有需要修改的地方去看原始文件或者文档就行了。</p><p>添加一个menuentry，就可以启动系统了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">also_scan_dirs +,ArchFS&#x2F;boot</span><br><span class="line">dont_scan_dirs ESP:&#x2F;EFI&#x2F;boot,EFI&#x2F;boot</span><br><span class="line">dont_scan_files shim.efi,MokManager.efi,fbx64.efi,mmx64.efi,shimx64.efi</span><br><span class="line">scan_all_linux_kernels false</span><br><span class="line"></span><br><span class="line">menuentry &quot;Arch Linux&quot; &#123;</span><br><span class="line">    icon     &#x2F;EFI&#x2F;refind&#x2F;icons&#x2F;os_arch.png</span><br><span class="line">    volume   8B131F77-62D7-4B4A-82D4-B60D7ACA2F6C</span><br><span class="line">    loader   &#x2F;ArchFS&#x2F;boot&#x2F;vmlinuz-linux-surface</span><br><span class="line">    initrd   &#x2F;ArchFS&#x2F;boot&#x2F;intel-ucode.img</span><br><span class="line">    initrd   &#x2F;ArchFS&#x2F;boot&#x2F;initramfs-linux-surface.img</span><br><span class="line">    options  &quot;root&#x3D;UUID&#x3D;9f8f9556-8ec1-4feb-9519-435beac8376f rw rootflags&#x3D;subvol&#x3D;ArchFS  loglevel&#x3D;3 quiet add_efi_memmap&quot;</span><br><span class="line">    submenuentry &quot;Boot using fallback initramfs&quot; &#123;</span><br><span class="line">        initrd &#x2F;ArchFS&#x2F;boot&#x2F;initramfs-linux-surface-fallback.img</span><br><span class="line">    &#125;</span><br><span class="line">    submenuentry &quot;Boot to terminal&quot; &#123;</span><br><span class="line">        add_options &quot;systemd.unit&#x3D;multi-user.target&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我用的是btrfs文件系统，所以配置文件有点罗嗦。解释一下上面的内容。</p><p>also_scan_dirs是指定扫描某个目录，因为我是btrfs文件系统，必须使用这个才能让refind扫描到内核文件，否则会无法启动。</p><p>dont_scan_dirs是跳过指定的目录，因为refind默认是会扫描所有的efi文件，我们自己提供了emnuentry,所以不需要让它扫描了。</p><p>dont_scan_files是跳过指定的文件，这里是防止其他目录出现对应的efi也被扫描到。</p><p>scan_all_linux_kernels是扫描所有linux内核，这样所有的内核就会出现在启动列表里，我们同样也是不需要的。</p><p>menuentry里面需要修改的地方有，volume是分区的partuuid,我因为这个uuid就测试了好几次，最后才反应过来不是filesystem uuid,要求的是partition uuid. 所有遇到ArchFS的地方都是不需要的，因为btrfs支持字卷，我的系统是在一个叫ArchFS的卷里面的，如果不是btrfs的文件系统，这个是不需要的，同样options里的rootflags选项也是不需要的，这是传递给内核的参数，让内核可以正确的加载根分区。</p><p>这样就算完工了，重启系统，然后进bios里把安全启动改成Microsoft &amp; 3rd party CA，然后重新启动。</p><p>当第一次加载rEFInd的时候，因为我们的证书是才生成的，主板并没有存储对应的签名，rEFInd会启动mmx64.efi来让我们加载证书，证书的位置在<code>/etc/refind.d/keys</code>下，选择<code>refind_local.cer</code>导入，然后选择重启，重新进入系统就可以了。</p><p>导入证书这部分我其实不太确定，因为我除了使用shim方案，我还测试了preloader方案，那个方案会一开始就启动一个MOK的工具进行证书导入，我记不太清shim到底需不需要手动导入了，如果出现了，那就导入一下就行了，没出现的话就能正常的看到引导界面和进入系统了。</p><p>还有一个后续的动作需要处理，就是内核升级以后，我们需要对内核重新签名，否则会被bios拒绝启动。</p><p>编辑<code>/etc/pacman.d/hooks/99-secureboot.hook</code>,并写入以下配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Trigger]</span><br><span class="line">Operation &#x3D; Install</span><br><span class="line">Operation &#x3D; Upgrade</span><br><span class="line">Type &#x3D; Package</span><br><span class="line">Target &#x3D; linux</span><br><span class="line">Target &#x3D; linux-surface</span><br><span class="line">Target &#x3D; systemd</span><br><span class="line"></span><br><span class="line">[Action]</span><br><span class="line">Description &#x3D; Signing Kernel for SecureBoot</span><br><span class="line">When &#x3D; PostTransaction</span><br><span class="line">Exec &#x3D; &#x2F;usr&#x2F;bin&#x2F;sh -c &quot;&#x2F;usr&#x2F;bin&#x2F;find &#x2F;boot&#x2F; -type f \( -name &#39;vmlinuz-*&#39; -o -name &#39;systemd*&#39; \) -exec &#x2F;usr&#x2F;bin&#x2F;sh -c &#39;if ! &#x2F;usr&#x2F;bin&#x2F;sbverify --list &#123;&#125; 2&gt;&#x2F;dev&#x2F;null | &#x2F;usr&#x2F;bin&#x2F;grep -q \&quot;signature certificates\&quot;; then &#x2F;usr&#x2F;bin&#x2F;sbsign --key &#x2F;etc&#x2F;refind.d&#x2F;keys&#x2F;refind_local.key --cert &#x2F;etc&#x2F;refind.d&#x2F;keys&#x2F;refind_local.crt --output &#123;&#125; &#123;&#125;; fi&#39; \;&quot;</span><br><span class="line">Depends &#x3D; sbsigntools</span><br><span class="line">Depends &#x3D; findutils</span><br><span class="line">Depends &#x3D; grep</span><br></pre></td></tr></table></figure><p>享受安全启动吧～</p><img src="/2020/09/08/use-refind-to-boot-system/IMG_1089.JPG" class="" title="图片"><img src="/2020/09/08/use-refind-to-boot-system/IMG_1090.JPG" class="" title="图片"><img src="/2020/09/08/use-refind-to-boot-system/IMG_1091.JPG" class="" title="图片">]]></content>
    
    
    <summary type="html">&lt;p&gt;今年的七夕，我老婆给我买了一台surface laptop 2代，8G内存 + 256G存储版本，我也成功的用上了田牌的机器。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.justforlxz.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Linux" scheme="https://blog.justforlxz.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>deepin git version</title>
    <link href="https://blog.justforlxz.com/2020/09/06/deepin-git-version/"/>
    <id>https://blog.justforlxz.com/2020/09/06/deepin-git-version/</id>
    <published>2020-09-06T12:51:08.000Z</published>
    <updated>2020-09-17T08:26:18.336Z</updated>
    
    <content type="html"><![CDATA[<p>This repository only provides the git version of deepin. You can replace the deepin group in the community by installing the deepin-git group.</p><a id="more"></a><p>The PKGBUILD for all packages are there <a href="https://github.com/justforlxz/deepin-git-repo">https://github.com/justforlxz/deepin-git-repo</a>, Each branch saves the corresponding software.</p><p>Before adding this repository, you should first add the key used to sign the packages in it. You can do this by running the following commands:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -qO - https://packages.justforlxz.com/deepingit.asc \</span><br><span class="line">    | sudo pacman-key --add -</span><br></pre></td></tr></table></figure><p>It is recommended that you now fingerprint it by running</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman-key --finger DCAF15B4605D5BEB</span><br></pre></td></tr></table></figure><p>and in a final step, you have to locally sign the key to trust it via</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman-key --lsign-key DCAF15B4605D5BEB</span><br></pre></td></tr></table></figure><p>More infos on this process can be found at <a href="https://wiki.archlinux.org/index.php/Pacman/Package_signing#Adding_unofficial_keys">https://wiki.archlinux.org/index.php/Pacman/Package_signing#Adding_unofficial_keys</a>. You can now add the repository by editing /etc/pacman.conf and adding</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[deepingit]</span><br><span class="line">Server = https://packages.justforlxz.com/</span><br></pre></td></tr></table></figure><p>at the end of the file. See <a href="https://wiki.archlinux.org/index.php/Pacman#Repositories_and_mirrors">https://wiki.archlinux.org/index.php/Pacman#Repositories_and_mirrors</a> for details.</p><p>to install deepin git version:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -Syy deepin-git</span><br></pre></td></tr></table></figure><p>If you don’t want to use the repository anymore, you can uninstall deepin git, or install the deepin group in Community.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -Rscn deepin-git</span><br></pre></td></tr></table></figure><p>to install deepin group for community.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S deepin</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;This repository only provides the git version of deepin. You can replace the deepin group in the community by installing the deepin-git group.&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.justforlxz.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Linux" scheme="https://blog.justforlxz.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用VSCode远程开发DDE</title>
    <link href="https://blog.justforlxz.com/2020/09/03/use-vscode-to-remotely-develop-dde/"/>
    <id>https://blog.justforlxz.com/2020/09/03/use-vscode-to-remotely-develop-dde/</id>
    <published>2020-09-03T11:14:38.000Z</published>
    <updated>2020-09-17T08:26:18.396Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍如何使用VSCode的远程开发套件连接到Deepin主机，进行DDE和其他软件的开发与调试.</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Visual Studio Code（简称VS Code）是一个由微软开发，同时支持Windows 、 Linux和macOS等操作系统的免费代码编辑器，它支持测试，并内置了Git 版本控制功能，同时也具有开发环境功能，例如代码补全（类似于 IntelliSense）、代码片段和代码重构等。该编辑器支持用户个性化配置，例如改变主题颜色、键盘快捷方式等各种属性和参数，同时还在编辑器中内置了扩展程序管理的功能。</p><p>在VSCode出来之前，Sublime曾经是前端开发者必备的软件，它使用python作为插件运行环境，并且也拥有不少的插件，但是很遗憾的是插件不能更改界面元素，可玩性不是很高。</p><p>再后来Atom作为GitHub的顶梁柱出现了，它基于使用Chromium和Node.js的跨平台应用框架Electron（最初名为Atom Shell），并使用CoffeeScript和Less撰写，并且支持js开发的插件，一时间拥有非常多的用户，并且从Sublime那里拉拢了非常多的前端开发者。</p><p>但是一切都在VSCode面世以后变了。VSCode同样也是基于Chromim和Electron开发，并且支持TypeScript开发插件，而且启动速度比Atom快很多，而且作为微软面向开源社区的主力产品，它和TypeScript一样，吸收了社区的很多意见和贡献，使得软件越来越好用。在语言支持方面，对 C#、JavaScript、和 TypeScript 等编程语言的原生支持最为完善。</p><h2 id="安装VS-Code"><a href="#安装VS-Code" class="headerlink" title="安装VS Code"></a>安装VS Code</h2><p>官网提供的有vscode的安装包，windows用户下载stable版本的exe(System Installer)。</p><p>System Installer可以自动下载对应语言的环境包，推荐安装此版本。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/W1KvXk0ylxHa9w8E.png" class="" title="图片"><p>安装完成后就可以安装插件了。</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>插件系统是一个编辑器的左膀右臂，emacs和vim作为终端下开发经常使用的编辑器，就拥有非常丰富的插件，几乎每个大佬使用的emacs和vim都不能互换使用。</p><p>dde的项目几乎都是cmake的项目，所以需要安装cmake插件和c++的插件，安装了这两个插件以后。vscode打开项目工程就会自动解析CMakeLists.txt，并且开启vscode的快速调试功能，还可以开始构建项目和调试项目了。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/XvMxNUQrs9oyEYJF.png" class="" title="图片"><p>安装CMake、CMake Tools这两个插件就可以开发了。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/tBB60YiLW79oMLC1.png" class="" title="图片"><p>安装C/C++和C++ Intellisense这两个插件可以对项目中的c++代码进行智能感知和代码补全，推荐安装。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/idQexXGZXPrqCBby.png" class="" title="图片"><p>安装Remote - SSH插件，可以让vscode通过ssh连接到目标机器，打开远程机器的目录和文件，并且在该模式下，部分插件可以自动切换成本地/远程模式，这样就可以在本机直接开发，但是操作的内容都是远程环境的。</p><p>安装完Remote - SSH插件以后，vscode的左下角就会有一个绿色的按钮，可以用来切换模式。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/MWorTAHEAsJRt47E.png" class="" title="图片"><h2 id="配置远程环境"><a href="#配置远程环境" class="headerlink" title="配置远程环境"></a>配置远程环境</h2><p>因为是要在Windows上进行远程开发，如果是直接在UOS或者Deepin上开发DDE，这一部分是可以不用看的，上面的插件安装完成以后就可以开发项目了。</p><p>点击左下角的绿色按钮，在弹出的面板选择Remote-SSH: Connect to Host。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/WFN9jpqyRRXORtuP.png" class="" title="图片"><p>会继续弹出一个面板，用来选择配置ssh的连接。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/Cw7Z7sF3rb8RiBzZ.png" class="" title="图片"><p>选择Add New SSH Host添加一个服务器。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/qcXsO8ayHXyTMr62.png" class="" title="图片"><p>输入ssh的命令，例如 ssh <a href="mailto:&#x6c;&#x78;&#x7a;&#x40;&#49;&#x30;&#46;&#x32;&#x30;&#x2e;&#x33;&#50;&#x2e;&#x35;&#52;">&#x6c;&#x78;&#x7a;&#x40;&#49;&#x30;&#46;&#x32;&#x30;&#x2e;&#x33;&#50;&#x2e;&#x35;&#52;</a>。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/9Cla2rDtfzfsHVSh.png" class="" title="图片"><p>然后选择一个保存配置的位置，一般默认选择用户家目录的.ssh目录即可。然后就提示添加成功，此时可以点击Connect按钮进行连接。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/Do8KoBS0lwM1g09G.png" class="" title="图片"><p>输入密码</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/J7dPRyLYI4QBcma5.png" class="" title="图片"><p>登录以后会打开一个新的窗口，并提示正在连接。连接成功以后可以在左下角看到机器的信息。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/LjLHBXGQeuvXMk8k.png" class="" title="图片"><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/VJQhRC7LXbhWyWdN.png" class="" title="图片"><p>然后打开命令面板，选择在SSH中安装本地扩展。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/XJEqsfmwIO5FpUKS.png" class="" title="图片"><p>在打开的列表选择全选，然后安装。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/zmVjGPVL7gphBZ7h.png" class="" title="图片"><p>等待全部安装成功。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/P1yXbz7pkrwXOEAS.png" class="" title="图片"><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/WbxesoOf0RF1QqtZ.png" class="" title="图片"><h2 id="开发和调试"><a href="#开发和调试" class="headerlink" title="开发和调试"></a>开发和调试</h2><h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>CMake插件提供了编译、运行和调试的功能和命令，可以点击下方面板中的select target，选择要运行的目标程序，选择切换编译模式，可以选择Debug或者Release。还可以选择使用哪个编译器进行构建。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/je8iADCEbmCT7sMZ.png" class="" title="图片"><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/uUIxae7PVFDwSyUB.png" class="" title="图片"><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/Ah6NUPpjjoDIL93K.png" class="" title="图片"><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/UbibgDc1gL0tXNPy.png" class="" title="图片"><h3 id="设置启动参数"><a href="#设置启动参数" class="headerlink" title="设置启动参数"></a>设置启动参数</h3><p>如果程序启动不需要提供参数，则可以直接点击下方面板的Debug按钮，或者打开命令面板选择CMake Debug Target，如果没有选择过Target，则会询问一次设置Target。</p><p>点击左侧的调试按钮，选择添加配置。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/kTjwUYxwt19QlwPt.png" class="" title="图片"><p>在弹出的面板选择GDB</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/5Q4JOQWUZnDMtBNx.png" class="" title="图片"><p>此时vscode会创建出一个json文件，并生成了默认的配置文件。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/l1IZdMrxfd0dH45a.png" class="" title="图片"><p>我们需要进行一些调整，以便使用该配置文件进行调试。</p><p>program字段是程序二进制文件的位置，一般情况下我们是要手动写好路径，但是如果项目的二进制特别多，更换配置文件就会非常麻烦，而且配置文件里写死路径也不是很方便，我查阅了CMake插件的文档，发现CMake插件提供了两个很重要的变量，可以让我们方便的查找到路径。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;program&quot;: &quot;$&#123;command:cmake.launchTargetPath&#125;&quot;</span><br></pre></td></tr></table></figure><p>CMake插件提供了launchTargetPath的变量，它对应的是CMake插件选择的默认target，启动调试之前需要我们先选择好Target。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;value&quot;: &quot;$PATH:$&#123;command:cmake.launchTargetDirectory&#125;&quot;</span><br></pre></td></tr></table></figure><p>CMake插件还提供了launchTargetDirectory变量，用于获取程序启动所在的目录，一般需要我们指定到本次调试所需的环境变量中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;environment&quot;: [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;PATH&quot;,</span><br><span class="line">    &quot;value&quot;: &quot;$PATH:$&#123;command:cmake.launchTargetDirectory&#125;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后我们就可以添加启动参数了。<br>args字段保存了程序启动会传递的参数列表，例如这里会给fuse传递-d和/tmp/x。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;args&quot;: [</span><br><span class="line">  &quot;-d&quot;,</span><br><span class="line">  &quot;&#x2F;tmp&#x2F;x&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>完整的配置如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;(gdb) fuse&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;command:cmake.launchTargetPath&#125;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;-d&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/tmp/x&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;environment&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;PATH&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;$PATH:$&#123;command:cmake.launchTargetDirectory&#125;&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;为 gdb 启用整齐打印&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h3><p>此时我们就可以先通过CMake插件构建整个项目，再切换到运行面板，启动调试。</p><p>点击下方面板的Build按钮，构建项目。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/FAkfeLuV4JBsc4Mx.png" class="" title="图片"><p>再点击左侧的gdb fuse(deepin-turbo)按钮，因为配置文件里面我们起的名字是gdb fuse。我们在main函数添加一个断点，用来测试gdb是否工作正常。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/mKDIuN2GI1pSfVpQ.png" class="" title="图片"><p>一切都工作正常，在调试控制台可以使用-exec作为前缀来执行gdb的命令。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/sxNL1dJG5uFm22O1.png" class="" title="图片"><h3 id="调试图形程序"><a href="#调试图形程序" class="headerlink" title="调试图形程序"></a>调试图形程序</h3><p>调试图形程序稍微有一些麻烦，因为是远程开发，图形程序又只能工作在目标机器，这里提供两个可行的方案。</p><ol><li>synergy之类的键盘鼠标共享软件</li><li>在windows安装xserver</li></ol><p>第一种方案是通过共享本机的键盘鼠标到远程机器，这样就可以在远程环境上面进行直接操作，好处是除了调试，也可以同时操作远程机器进行使用。</p><p>第二种方案是利用X11协议的网络透明，既图形程序和显示服务不一定在同一台机器上运行，我们只需要在Windows安装XServer程序，就可以让远程机器上的程序的画面显示到当前机器，并且可以操作。但是此方案有缺点，虽然设计上这种分离结构设计的很巧妙，但是因为远程OpenGL调用并不支持，所以图形无法调用3D程序渲染，并且和远程机器沟通需要大量的带宽，所以用起来体验并不好。</p><p>为了使用这两种方案，我们都需要在调试的launch.json中添加一个环境变量。</p><p>在运行面板点击齿轮按钮，可以编辑当前方案。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/X32Q5bhGX2B7CLGg.png" class="" title="图片"><p>在打开的json文件中，找到environment字段，添加DISPLAY环境变量。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;environment&quot;: [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;DISPLAY&quot;,</span><br><span class="line">    &quot;value&quot;: &quot;:0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样程序启动就有DISPLAY环境变量，我们就可以让程序在目标机器的屏幕上运行了。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/7JuWfnnURIt1NrdR.png" class="" title="图片"><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/20200903_023112910_iOS.jpg" class="" title="图片"><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/20200903_023116260_iOS.jpg" class="" title="图片"><p>还有一种自动化测试的方案，该方案是我个人认为所有开发都应该掌握的，通过自动化测试，我们就可以完全使用远程开发来完成开发任务，调试的时候只需要等待自动测试结果返回即可，设想一下，某个模块需要点击很多地方才可以重现一个问题，我们只需要设置好断点，让程序自动开始执行所有函数，并在最终出现问题的地方停下，我们就可以开始手动单步跟踪问题，完全不需要使用鼠标人工点击。（然而理想很美好，现实很残酷，我个人目前都没有掌握自动化测试的方式，现在也是只能通过鼠标点点点来重现问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍如何使用VSCode的远程开发套件连接到Deepin主机，进行DDE和其他软件的开发与调试.&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://blog.justforlxz.com/categories/Linux/"/>
    
    <category term="技术" scheme="https://blog.justforlxz.com/categories/Linux/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Linux" scheme="https://blog.justforlxz.com/tags/Linux/"/>
    
    <category term="VS Code" scheme="https://blog.justforlxz.com/tags/VS-Code/"/>
    
    <category term="Windows" scheme="https://blog.justforlxz.com/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>在ArchLinux上开发startdde</title>
    <link href="https://blog.justforlxz.com/2020/08/06/develop-startdde-on-archlinux/"/>
    <id>https://blog.justforlxz.com/2020/08/06/develop-startdde-on-archlinux/</id>
    <published>2020-08-06T16:14:26.000Z</published>
    <updated>2020-09-17T08:26:18.336Z</updated>
    
    <content type="html"><![CDATA[<p>dde 后端使用 go 作为主要的开发语言，使用 dbus 提供接口，主要使用 gsettings 来保存配置。 所以在进行后端开发前需要对以上内容有基本的了解，这里假定本文档的阅读者熟悉 dbus 和 gsettings，并有一定的开发经验。</p><a id="more"></a><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>虽然本项目是go语言开发的，但是我们并没有直接使用go的mod作为依赖管理方案，而是走系统包管理器的方式，所以要先安装startdde的编译依赖。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -Sy golang-github-linuxdeepin-go-dbus-factory golang-deepin-gir golang-deepin-lib golang-deepin-dde-api go git jq golang-golang-x-net golang-github-linuxdeepin-go-x11-client</span><br></pre></td></tr></table></figure><p>这些包会被安装到系统的/usr/share/gocode目录下。还需要手动go get一个依赖到本地的GOPATH中。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get -v github.com/cryptix/wav</span><br></pre></td></tr></table></figure><h2 id="设置GOPATH"><a href="#设置GOPATH" class="headerlink" title="设置GOPATH"></a>设置GOPATH</h2><p>为了方便以后的开发，可以将GOPATH环境变量定义到~/.xprofile等文件中，或者shell的配置文件。例如我使用的zsh：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export GOPATH=$HOME/Develop/Go:/usr/share/gocode</span><br><span class="line">export PATH=$HOME/Develop/Go/bin:$PATH</span><br></pre></td></tr></table></figure><h2 id="设置项目目录"><a href="#设置项目目录" class="headerlink" title="设置项目目录"></a>设置项目目录</h2><p>go要求项目目录必须在GOPATH中，所以要将startdde放到GOPATH的pkg.deepin.io/dde/目录下，但是GOPATH每次进入不方便，可以采用软链的形式将startdde的目录链接到GOPATH下。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/Develop/Deepin</span><br><span class="line">git clone https://github.com/linuxdeepin/startdde</span><br><span class="line">mkdir -p ~/Develop/Go/src/pkg.deepin.io/dde/</span><br><span class="line">ln -sf ~/Develop/Deepin/startdde ~/Develop/Go/src/pkg.deepin.io/dde/startdde</span><br></pre></td></tr></table></figure><p>这样就可以在一个方便的目录进行开发了。</p><h2 id="vscode开发工具"><a href="#vscode开发工具" class="headerlink" title="vscode开发工具"></a>vscode开发工具</h2><p>我个人推荐使用vscode当作开发工具，打开vscode安装go的插件，打开startdde目录，vscode会提示安装一些go的工具，选择全部安装即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;dde 后端使用 go 作为主要的开发语言，使用 dbus 提供接口，主要使用 gsettings 来保存配置。 所以在进行后端开发前需要对以上内容有基本的了解，这里假定本文档的阅读者熟悉 dbus 和 gsettings，并有一定的开发经验。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://blog.justforlxz.com/categories/Linux/"/>
    
    
    <category term="dde" scheme="https://blog.justforlxz.com/tags/dde/"/>
    
    <category term="go" scheme="https://blog.justforlxz.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>use github action to check dde-launcher</title>
    <link href="https://blog.justforlxz.com/2020/07/27/use-github-action-to-check-dde-launcher/"/>
    <id>https://blog.justforlxz.com/2020/07/27/use-github-action-to-check-dde-launcher/</id>
    <published>2020-07-27T18:14:21.000Z</published>
    <updated>2020-09-17T08:26:18.356Z</updated>
    
    <content type="html"><![CDATA[<p>本来打算7月份给dde添加github action验证，但是被各种事情耽误了，然后发现麒麟居然抢在我前面部署了全套的github action，这不能忍，赶紧把dde的github action也提上日程。并且打算听<a href="https://github.com/felixonmars">肥肥猫</a>大佬的话，在aur给dde弄一套commit构建包，这样就可以在arch上使用比testing仓库更testing的dde了！</p><a id="more"></a><p>github actions是github官方出的持续集成功能，以前大家在github上的项目都使用的第三方的Travis CI或者自建jenkins构建，但是github被微软收购以后，微软为了表现出给社区和用户的诚意，将大量github的付费功能免费公开给开发者使用，希望能将github打造成开发者中心，于是在2019年微软推出了免费的github actions，每个项目都可以免费使用官方提供的持续集成和持续部署功能，这对第三方业务无疑是个巨大的打击，虽然Travis CI和jenkins等方式仍然有一定的市场，但是对于中小项目的开源项目，使用官方提供的功能无疑是方便的。</p><p>github actions的配置十分简单，只需要几个简单的步骤就可以实现构建、执行和测试代码。并且可以使用Linux、Windows和MacOS环境，机器性能也十分强劲，编译速度非常的快。</p><p>这是给dde-launcher的一份基础配置，需要将配置文件放在.github/workflows/目录下，以build.yaml文件名保存。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">CI</span> <span class="string">Build</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">uos</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">uos</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">archlinux:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Archlinux</span> <span class="string">Build</span> <span class="string">Check</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">container:</span> <span class="string">docker.io/library/archlinux:latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">branch</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Refresh</span> <span class="string">pacman</span> <span class="string">repository</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">pacman</span> <span class="string">-Syy</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">build</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">pacman</span> <span class="string">-S</span> <span class="string">--noconfirm</span> <span class="string">base-devel</span> <span class="string">cmake</span> <span class="string">ninja</span> <span class="string">qt5-tools</span> <span class="string">deepin-qt-dbus-factory</span> <span class="string">dtkwidget</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CMake</span> <span class="string">&amp;</span> <span class="string">Make</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">mkdir</span> <span class="string">build</span></span><br><span class="line">          <span class="string">cd</span> <span class="string">build</span></span><br><span class="line">          <span class="string">cmake</span> <span class="string">../</span> <span class="string">-G</span> <span class="string">Ninja</span></span><br><span class="line">          <span class="string">ninja</span></span><br></pre></td></tr></table></figure><p>介绍一下配置文件吧，name是设置ci的名字，github允许有多个ci存在，可以做不同的事情，例如部署三个ci，一个做语法检查，一个做静态检查，一个做编译检查。name就是用来在界面上显示的。on是设置ci对哪些事件感兴趣，在这里我设置了push和pull_request，当发生push和pull request时，这个ci就会被启动，执行接下来的jobs的内容。jobs里是可以设置多个任务的，同样name字段也是用来展示本次动作的名称。runs-on是设置该job工作的环境，ubuntu-latest是linux环境，container是指使用哪个docker容器，github actions是可以使用docker的，也可以将自己的ci配置共享给其他人使用。run就是执行命令了，在配置文件中我手动运行了刷新仓库和编译项目所需的命令。job的steps可以理解成shell中一次动作的执行，uses是使用其他人封装好的命令，run则是执行本地命令。</p><p>可以看出github actions的配置是十分简单的，并且构建速度也非常的快，并且构建环境是使用的arch linux环境，为什么要选择arch作为ci的基础构建环境呢，原因当然不是因为和肥肥猫有py交易，arch上的dde更新速度很快，并且很多用户都使用arch+dde的方式使用linux，deepin自己维护的发行版因为基础仓库更新较慢，不适合一些用户，所以为了能让dde被更多的人接受和使用，在arch上及时更新dde是十分有必要的。所以才选择actions的环境为arch linux。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本来打算7月份给dde添加github action验证，但是被各种事情耽误了，然后发现麒麟居然抢在我前面部署了全套的github action，这不能忍，赶紧把dde的github action也提上日程。并且打算听&lt;a href=&quot;https://github.com/felixonmars&quot;&gt;肥肥猫&lt;/a&gt;大佬的话，在aur给dde弄一套commit构建包，这样就可以在arch上使用比testing仓库更testing的dde了！&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.justforlxz.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Linux" scheme="https://blog.justforlxz.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用perf工具分析程序性能</title>
    <link href="https://blog.justforlxz.com/2020/07/21/use-perf-to-analytics-program/"/>
    <id>https://blog.justforlxz.com/2020/07/21/use-perf-to-analytics-program/</id>
    <published>2020-07-21T09:15:11.000Z</published>
    <updated>2020-09-17T08:26:18.364Z</updated>
    
    <content type="html"><![CDATA[<p>最近在对DDE进行性能优化，所以补习了一下linux下的各种分析工具的使用方法。</p><img src="/2020/07/21/use-perf-to-analytics-program/bpf_performance_tools_book.png" class="" title="bpf_performance_tools_book.png"><p>这张图是来自Brendan Gregg大佬提供的linux分析工具的应用场景，可以看出几乎包含了系统每个地方应该用什么工具去分析。</p><a id="more"></a><h2 id="Linux-Perf-Tool"><a href="#Linux-Perf-Tool" class="headerlink" title="Linux Perf Tool"></a>Linux Perf Tool</h2><h3 id="允许系统进行分析"><a href="#允许系统进行分析" class="headerlink" title="允许系统进行分析"></a>允许系统进行分析</h3><p>为了能够正常分析，首先需要打开系统的调试功能，允许我们去对其他进程进行访问。</p><h3 id="SysCtl"><a href="#SysCtl" class="headerlink" title="SysCtl"></a>SysCtl</h3><p>较新的Linux内核具有sysfs可调参数<code>/proc/sys/kernel/perf_event_paranoid</code>，该参数允许用户调整perf_events非root用户的可用功能，数量越大则越安全（相应地提供较少的功能）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Consider tweaking &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;perf_event_paranoid:</span><br><span class="line"> -1 - Not paranoid at all</span><br><span class="line">  0 - Disallow raw tracepoint access for unpriv</span><br><span class="line">  1 - Disallow cpu events for unpriv</span><br><span class="line">  2 - Disallow kernel profiling for unpriv</span><br></pre></td></tr></table></figure><p>默认值是不允许获取任何信息，所以我们需要修改为1或者0，允许我们访问CPU的事件信息。</p><ul><li>临时修改</li></ul><p>执行命令向内核接口直接写入值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tee &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;perf_event_paranoid &lt;&lt;&lt; 1</span><br></pre></td></tr></table></figure><ul><li>永久修改</li></ul><p>使用sysctl来配置其值，创建<code>/etc/sysctl.d/50_perf_event_paranoid.conf</code>文件，并写入<code>kernel.perf_event_paranoid=1</code>，执行<code>sysctl -p</code>来刷新系统配置。</p><h3 id="perf-采样"><a href="#perf-采样" class="headerlink" title="perf 采样"></a>perf 采样</h3><blockquote><p>性能优化相关的三种类型的工具，一种是sampling类型的，即采样，这种工具就是不停“询问”程序在做什么，perf在我们使用的这种模式下就是 sampling模式，如果是追踪某些event，就工作在trace模式，实际上就是第二种类型的工具，这种工具主要依靠事件或者hook，程序在运行的过程中不停主动告诉工具它自己在做什么，比如 strace；第三种是 instrument 类型的，这种主要就是依赖编译器进行插桩，精确知道代码行级别的执行情况（参考gcc instrumentation ）。</p><p>by hualet on <a href="https://docsin.uniontech.com/?p=735">deepin 15.7</a></p></blockquote><p>我们通过perf record命令才对程序进行采样记录。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perf record -g --call-graph&#x3D;dwarf -F 99 &#x2F;usr&#x2F;bin&#x2F;dde-shutdown</span><br></pre></td></tr></table></figure><p>命令介绍：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-g: 即采样全部信息</span><br><span class="line">--call-graph: 设置并启用调用图（堆栈链&#x2F;回溯）记录，参数有fp(frame pointers)、dwarf(debug information)和lbr(Last Branch Record)。</span><br><span class="line">-F: 采样率</span><br></pre></td></tr></table></figure><p>perf可以直接启动一个程序进行分析，也可以使用-p参数指定一个pid进行采样。</p><h3 id="查看-perf-的采样结果"><a href="#查看-perf-的采样结果" class="headerlink" title="查看 perf 的采样结果"></a>查看 perf 的采样结果</h3><p>当我们通过perf record完成采样以后，会在执行目录生成perf.data文件，此时我们就可以使用perf report命令对data文件进行数据分析了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perf report --stdio</span><br></pre></td></tr></table></figure><p>perf report会自动打开当前目录下的perf.data文件，当然也可以在最后指定perf.data文件的路径。</p><p>perf report会根据–call-graph参数来生成不同的图，使用dwarf参数时会以函数调用栈的顺序来显示，使用这种方式可以方便的看出哪个函数执行的时间比较长，因为每次采样都能落到该函数上，也就意味着函数执行的时间非常长，再通过调用栈的深度来分析函数执行期间都在做什么事情。</p><h3 id="hotspot火焰图"><a href="#hotspot火焰图" class="headerlink" title="hotspot火焰图"></a>hotspot火焰图</h3><p>在命令行下查看函数调用不是特别方便，所以就有图形化的工具用来方便的查看perf工具的生成结果，其中使用比较友好的是kde开发的hotspot工具，该工具可以直接打开perf.data文件，并生成对应的火焰图，火焰图是函数调用的另一种表现形式，火焰越高，也就意味着调用栈越深，火焰越广，也就意味着函数执行的时间很长。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在对DDE进行性能优化，所以补习了一下linux下的各种分析工具的使用方法。&lt;/p&gt;
&lt;img src=&quot;/2020/07/21/use-perf-to-analytics-program/bpf_performance_tools_book.png&quot; class=&quot;&quot; title=&quot;bpf_performance_tools_book.png&quot;&gt;

&lt;p&gt;这张图是来自Brendan Gregg大佬提供的linux分析工具的应用场景，可以看出几乎包含了系统每个地方应该用什么工具去分析。&lt;/p&gt;</summary>
    
    
    
    <category term="优化" scheme="https://blog.justforlxz.com/categories/%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Linux" scheme="https://blog.justforlxz.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CTest &amp; QTest/GTest</title>
    <link href="https://blog.justforlxz.com/2020/06/16/CTest%20&amp;%20QTEST/"/>
    <id>https://blog.justforlxz.com/2020/06/16/CTest%20&amp;%20QTEST/</id>
    <published>2020-06-16T15:11:40.000Z</published>
    <updated>2020-09-17T08:26:18.336Z</updated>
    
    <content type="html"><![CDATA[<p>本文会介绍一下QTest和GTest的一些功能和区别。</p><a id="more"></a><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><h2 id="ctest"><a href="#ctest" class="headerlink" title="ctest"></a>ctest</h2><p>ctest是CMake提供的运行单元测试的工具，在使用CMakeLists.txt文件编译工程的时候，CTest会自动configure、build、test和展现测试结果。</p><p>ctest有两个模式：</p><ul><li>模式一：使用CMake configure和build工程，在CMakeLists.txt，使用特殊的命令创建tests。使用CTest来执行那些测试。</li><li>模式二：使用CTest来执行一个script，这个script的语法必须和CMakeLists.txt相同。</li></ul><p>使用方法：</p><p>在CMakeLists.txt使用include(CTest)和include(Dart)来导入CTest模块和开启ctest。使用add_test()来添加一个测试程序，测试程序是一个普通的二进制，只不过内部运行的是qtest或者gtest编写的测试用例。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include(CTest)</span><br><span class="line">include(Dart)</span><br><span class="line">add_executable(tests tests&#x2F;test.cpp)</span><br><span class="line">add(NAME tests COMMAND $&lt;TARGET_FILE:tests&gt;)</span><br></pre></td></tr></table></figure><h2 id="qt-qtest"><a href="#qt-qtest" class="headerlink" title="qt qtest"></a>qt qtest</h2><p>qtest是Qt提供的单元测试框架，Qt Test是用于对基于Qt的应用程序和库进行单元测试的框架。Qt Test提供了单元测试框架中常见的所有功能以及用于测试图形用户界面的扩展。</p><p>Qt测试旨在简化基于Qt的应用程序和库的单元测试的编写：</p><table><thead><tr><th align="left">特征</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">轻量</td><td align="left">Qt Test大约有6000行代码和60个导出符号组成</td></tr><tr><td align="left">自成体系</td><td align="left">Qt Test仅需要Qt Core模块中的几个符号即可进行非GUI测试</td></tr><tr><td align="left">快速测试</td><td align="left">Qt Test不需要特殊的测试运行程序，没有特殊的测试注册</td></tr><tr><td align="left">数据驱动测试</td><td align="left">可以使用不同的数据进行多次的测试</td></tr><tr><td align="left">基本的GUI测试</td><td align="left">Qt Test提供了用于鼠标和键盘的模拟功能</td></tr><tr><td align="left">标杆管理</td><td align="left">Qt Test支持基准测试，并提供多个测量后端</td></tr><tr><td align="left">IDE友好</td><td align="left">Qt Test输出可以由Qt Creator、Visual Studio等IDE解释的消息</td></tr><tr><td align="left">线程安全</td><td align="left">错误报告是线程安全和原子的</td></tr><tr><td align="left">类型安全</td><td align="left">模板的广泛使用可以防止隐式类型转换引起的错误</td></tr><tr><td align="left">易于扩展</td><td align="left">可以将自定义类型轻松添加到测试数据和测试输出中</td></tr></tbody></table><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>QVERIFY() 用于验证数据是否正确。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QVERIFY(<span class="number">1</span> == <span class="number">1</span>);</span><br><span class="line">QVERIFY2(<span class="number">1</span> != <span class="number">1</span>, <span class="string">&quot;1不等于1&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>QFETCH_GLOBAL() 该宏从全局数据表中的一行中获取类型类型为name的变量。 名称和类型必须与全局数据表中的列匹配。 这是断言，如果断言失败，则测试将中止。</p><p>QFETCH() 宏会在堆栈上创建一个类型为name的本地变量。 名称和类型必须与测试数据表中的列匹配。 这是断言，如果断言失败，则测试将中止。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QFETCH(QString, aString);</span><br><span class="line">QFETCH_GLOBAL(QLocale, locale);</span><br></pre></td></tr></table></figure><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>QCOMPARE宏用于判断两个值是否相等，如果实际值和预期值匹配，将会继续运行，否则将失败记录在测试日至中，并且测试将被终止，不会尝试任何后续操作。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QCOMPARE(QString(<span class="string">&quot;hello&quot;</span>).toUpper(), QString(<span class="string">&quot;HELLO&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p>通过在包含_data()的函数中调用QTest::addColumn和QTest::newRow向测试用例增加数据，并通过QFETCH宏在测试用例中访问数据。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestQString::toInt_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QTest::addColumn&lt;QString&gt;(<span class="string">&quot;aString&quot;</span>);</span><br><span class="line">    QTest::addColumn&lt;<span class="keyword">int</span>&gt;(<span class="string">&quot;expected&quot;</span>);</span><br><span class="line">    QTest::newRow(<span class="string">&quot;positive value&quot;</span>) &lt;&lt; <span class="string">&quot;42&quot;</span> &lt;&lt; <span class="number">42</span>;</span><br><span class="line">    QTest::newRow(<span class="string">&quot;negative value&quot;</span>) &lt;&lt; <span class="string">&quot;-42&quot;</span> &lt;&lt; <span class="number">-42</span>;</span><br><span class="line">    QTest::newRow(<span class="string">&quot;zero&quot;</span>) &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestQString::toInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     QFETCH(QString, aString);</span><br><span class="line">     QFETCH(<span class="keyword">int</span>, expected);</span><br><span class="line">     QCOMPARE(aString.toInt(), expected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建测试"><a href="#创建测试" class="headerlink" title="创建测试"></a>创建测试</h3><p>要创建测试，需要派生自QObject，并添加一个或多个专用槽函数。每个专用槽函数都是测试中的一个测试功能且必须为private。函数命名方法以casen_函数名或者以test结尾的方式。</p><p>使用QTest::qExec()可用于执行测试对象中的所有测试功能。</p><p>此外，还可以定义不用于测试功能的专用槽函数。如果存在，它们将由测试框架执行，并用于初始化和清除整个测试或当前的测试功能。</p><ul><li><strong>initTestCase()</strong> 将在第一个测试功能执行之前被调用</li><li><strong>initTestCase_data()</strong> 将被调用以创建全局测试数据表</li><li><strong>cleanupTestCase()</strong> 在最后一个测试函数执行后被调用</li><li><strong>init()</strong> 将在每个测试功能执行之前被调用</li><li><strong>cleanup()</strong> 将在每个测试函数之后调用</li></ul><p>使用initTestCase()准备测试。每次测试都应使系统处于可用状态，因此可以重复运行。清理操作应在cleanupTestCase()中处理，因此即使测试失败也可以运行清理操作。</p><p>使用init()创建测试功能。每个测试功能都应使系统保持可用状态，以便可以重复运行。清理操作应在cleanup()中，即使测试功能失败并提前退出，清理动作也可以运行。</p><p>另外，可以使用RAII,并在析构函数中调用清除操作，以确保他们在测试函数返回且对象移出作用域时发生。</p><p>如果initTestCase()失败，将不执行任何测试功能。如果init()失败，则不执行以下测试功能，测试将继续进行下一个测试功能。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">  Q_OBJECT</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">verify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">initTestCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">&quot;init test case&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">firstTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QVERIFY(<span class="literal">true</span>);</span><br><span class="line">    QCOMPARE(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">secondTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QVERIFY(verify());</span><br><span class="line">    QVERIFY(<span class="number">1</span> != <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cleanupTestCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">&quot;clean test case&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后，如果测试类具有静态且公共的void initMain()方法，则在实例化QApplication对象之前，由QTEST_MAIN宏调用该方法。例如，这允许设置应用程序的属性，例如Qt::AA_DisableHighDpiScaling。这是在Qt5.14添加的。</p><h3 id="使用CMake和CTest构建测试项目"><a href="#使用CMake和CTest构建测试项目" class="headerlink" title="使用CMake和CTest构建测试项目"></a>使用CMake和CTest构建测试项目</h3><p>CMake还有其他优点。例如，几乎可以毫不费力地使用CDash将测试运行的结果发布到Web服务器上。</p><p>CTest可以扩展到非常不同的单元测试框架，并且可以与QTest一起使用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">project(mytest LANGUAGES CXX)</span><br><span class="line">include(CTest)</span><br><span class="line">include(Dart)</span><br><span class="line">find_package(Qt5 COMPONENTS Test REQUIRED)</span><br><span class="line">set(CMAKE_INCLUDE_CURRENT_DIR ON)</span><br><span class="line">set(CMAKE_AUTOMOC ON)</span><br><span class="line">add_executable(mytest tst_mytest.cpp)</span><br><span class="line">add_test(NAME mytest COMMAND mytest)</span><br><span class="line">target_link_libraries(mytest PRIVATE Qt5::Test)</span><br></pre></td></tr></table></figure><h2 id="google-test"><a href="#google-test" class="headerlink" title="google test"></a>google test</h2><p>google test(gtest)是google公司推出的c++单元测试框架，基于xUnit架构，并且支持Linux、Windows和mac，并且支持任何类型的测试和模拟，而不仅仅是单元测试。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>当使用gtest时，通过编写断言来检查条件是否为真。断言的结果可能是成功、非致命失败或者致命失败。如果发生致命故障，将终止当前功能，否则将继续运行。</p><p>一个测试套件包含一个或者多个测试。当测试套件中的多个测试需要共享通用对象和子例程时，可以将他们放入一个测试桶中。</p><p>一个测试程序可以包含多个测试套件。</p><h3 id="断言-1"><a href="#断言-1" class="headerlink" title="断言"></a>断言</h3><p>gtest断言类似于函数调用的宏，可以通过断言其行为来测试类或者函数。断言失败时，gtest会输出断言的源文件和行号位置以及失败消息。还可以提供自定义失败消息，该消息将会附加到gtest的消息之后。</p><p>断言成对出现，测试相同的事物，但是对当前函数有不同的影响。ASSERT_<em>版本失败时会产生致命错误，并终止当前功能。EXPECT_</em>会产生非致命错误，不会导致当前测试失败。通常EXPECT_<em>是首选，因为他们允许在测试中报告多个鼓掌，但是如果在断言失败时继续运行将没有意义时应当使用ASSERT_</em>。</p><p>由于ASSERT_*失败会从当前函数立即返回，可能会跳过其后的清理代码，导致内存泄漏。</p><h3 id="基本断言"><a href="#基本断言" class="headerlink" title="基本断言"></a>基本断言</h3><p>基本断言可以进行基本的真/假条件测试</p><table><thead><tr><th align="left">致命断言</th><th align="left">非致命断言</th><th align="left">验证</th></tr></thead><tbody><tr><td align="left">ASSERT_TRUE(condition);</td><td align="left">EXPECT_TRUE(condition);</td><td align="left">condition是真的</td></tr><tr><td align="left">ASSERT_FALSE(condition);</td><td align="left">EXPECT_FLASE(condition);</td><td align="left">condition是假的</td></tr></tbody></table><p>请记住，当它们失败时，将导致ASSERT_<em>致命故障并从当前函数返回，而当它们发生EXPECT_</em>非致命故障时，将允许该函数继续运行。无论哪种情况，断言失败都意味着其包含测试失败。</p><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>该组中的断言比较两个C字符串。如果要比较两个string对象，请改用EXPECT_EQ，EXPECT_NE等。</p><table><thead><tr><th align="center">致命断言</th><th align="center">非致命断言</th><th align="center">验证</th></tr></thead><tbody><tr><td align="center">ASSERT_STREQ(str1,str2);</td><td align="center">EXPECT_STREQ(str1,str2);</td><td align="center">这两个C字符串的内容相同</td></tr><tr><td align="center">ASSERT_STRNE(str1,str2);</td><td align="center">EXPECT_STRNE(str1,str2);</td><td align="center">两个C字符串的内容不同</td></tr><tr><td align="center">ASSERT_STRCASEEQ(str1,str2);</td><td align="center">EXPECT_STRCASEEQ(str1,str2);</td><td align="center">两个C字符串的内容相同，忽略大小写</td></tr><tr><td align="center">ASSERT_STRCASENE(str1,str2);</td><td align="center">EXPECT_STRCASENE(str1,str2);</td><td align="center">两个C字符串的内容不同，忽略大小写</td></tr></tbody></table><p>注意，断言名称中的“ CASE”表示忽略大小写。一个NULL 指针和一个空字符串被认为是不同的。</p><p><em>STREQ</em>并<em>STRNE</em>接受宽C字符串（wchar_t*）。如果两个宽字符串的比较失败，则它们的值将打印为UTF-8窄字符串。</p><h3 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h3><p>创建测试：</p><ol><li>使用TEST()宏定义和命名测试功能。这些是没有返回值的普通C++函数。</li><li>在此函数，要与包含的所有有效C++语句一起使用各种gtest断言来检查。</li><li>测试结果由断言确定，如果测试中的任何声明失败（致命或非致命），或者测试崩溃，整个测试都会失败，否则测试应当成功。</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TEST(TestSuiteName, TestName) &#123;</span><br><span class="line">  ...测试代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TEST()函数第一个参数是测试套件的名称，第二个参数是测试套件内的测试名称。这两个名称都必须是有效的C++标识符，并且不应包含任何下划线。来自不同测试套件的测试可以具有相同的名称。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><h2 id="qtest"><a href="#qtest" class="headerlink" title="qtest"></a>qtest</h2><p><a href="https://doc.qt.io/qt-5/qtest.html">https://doc.qt.io/qt-5/qtest.html</a></p><h2 id="gtest"><a href="#gtest" class="headerlink" title="gtest"></a>gtest</h2><p><a href="https://github.com/google/googletest/blob/master/googletest/docs/primer.md">https://github.com/google/googletest/blob/master/googletest/docs/primer.md</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文会介绍一下QTest和GTest的一些功能和区别。&lt;/p&gt;</summary>
    
    
    
    <category term="unit test" scheme="https://blog.justforlxz.com/categories/unit-test/"/>
    
    
    <category term="Qt" scheme="https://blog.justforlxz.com/tags/Qt/"/>
    
    <category term="C++" scheme="https://blog.justforlxz.com/tags/C/"/>
    
    <category term="CMake" scheme="https://blog.justforlxz.com/tags/CMake/"/>
    
    <category term="GTest" scheme="https://blog.justforlxz.com/tags/GTest/"/>
    
    <category term="CTest" scheme="https://blog.justforlxz.com/tags/CTest/"/>
    
  </entry>
  
  <entry>
    <title>CPP项目的一些坑</title>
    <link href="https://blog.justforlxz.com/2020/06/15/CPP%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
    <id>https://blog.justforlxz.com/2020/06/15/CPP%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</id>
    <published>2020-06-15T11:11:40.000Z</published>
    <updated>2020-09-17T08:26:18.336Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章记录这几年项目中C++的一些问题和优化方法。需要注意的是，代码优化没有一本万利的方法，只能见招拆招，而且还要避免过早优化等问题，代码优化一定是要中后期才可以，而且不要为了优化而优化。</p><a id="more"></a><h2 id="const和const-amp"><a href="#const和const-amp" class="headerlink" title="const和const &amp;"></a>const和const &amp;</h2><p>在接收一个返回值或者声明局部只读变量时没有使用const修饰。const的目的不仅仅是为了只读，更多的是编译器可以在此处提供优化。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QRect rect = m_displayInter-&gt;primaryRawRect();</span><br><span class="line">qreal scale = qApp-&gt;primaryScreen()-&gt;devicePixelRatio();</span><br></pre></td></tr></table></figure><p>在这两行例子中，react和scale都在当前函数内没有任何修改，而且不应该修改，需要添加const来修饰只读，并且QRect应该使用&amp;来减少内存复制带来的额外影响。</p><h2 id="类型强转"><a href="#类型强转" class="headerlink" title="类型强转"></a>类型强转</h2><p>在部分代码中，经常能看到C风格的代码强转，应当根据具体情况使用static_cast、dynamic_cast和reinterpret_cast。</p><p>static_cast是使用的比较多的cast，经常用于派生类和基类之间转换。dynamic_cast也用于派生类和基类的转换，如果类型T是指针类型，若转换失败，则返回T类型的空指针，如果时T是引用类型，则会抛出异常，返回std::bad_cast。reinterpret_cast并不会做实际的转换，只会在编译时进行检查，如果不能进行cast转换，则编译报错。</p><h2 id="过多的嵌套"><a href="#过多的嵌套" class="headerlink" title="过多的嵌套"></a>过多的嵌套</h2><p>过多的嵌套会严重影响代码阅读，经常出现只有if通过才会进入执行的情况，这种情况应该修改为不通过就不要继续执行，或者安排合理的if将条件限制在之前。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BluetoothWorker::setAdapterPowered</span><span class="params">(<span class="keyword">const</span> Adapter *adapter, <span class="keyword">const</span> <span class="keyword">bool</span> &amp;powered)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QDBusObjectPath <span class="title">path</span><span class="params">(adapter-&gt;id())</span></span>;</span><br><span class="line">    <span class="comment">//关闭蓝牙之前删除历史蓝牙设备列表，确保完全是删除后再设置开关</span></span><br><span class="line">    <span class="keyword">if</span> (!powered) &#123;</span><br><span class="line">        QDBusPendingCall call = m_bluetoothInter-&gt;ClearUnpairedDevice();</span><br><span class="line">        QDBusPendingCallWatcher *watcher = <span class="keyword">new</span> QDBusPendingCallWatcher(call, <span class="keyword">this</span>);</span><br><span class="line">        connect(watcher, &amp;QDBusPendingCallWatcher::finished, [ = ] &#123;</span><br><span class="line">            <span class="keyword">if</span> (!call.isError()) &#123;</span><br><span class="line">                QDBusPendingCall adapterPoweredOffCall  = m_bluetoothInter-&gt;SetAdapterPowered(path, <span class="literal">false</span>);</span><br><span class="line">                QDBusPendingCallWatcher *watcher = <span class="keyword">new</span> QDBusPendingCallWatcher(adapterPoweredOffCall, <span class="keyword">this</span>);</span><br><span class="line">                connect(watcher, &amp;QDBusPendingCallWatcher::finished, [<span class="keyword">this</span>, adapterPoweredOffCall, adapter] &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!adapterPoweredOffCall.isError()) &#123;</span><br><span class="line">                        setAdapterDiscoverable(adapter-&gt;id());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        qWarning() &lt;&lt; adapterPoweredOffCall.error().message();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                qWarning() &lt;&lt; call.error().message();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        QDBusPendingCall adapterPoweredOnCall  = m_bluetoothInter-&gt;SetAdapterPowered(path, <span class="literal">true</span>);</span><br><span class="line">        QDBusPendingCallWatcher *watcher = <span class="keyword">new</span> QDBusPendingCallWatcher(adapterPoweredOnCall, <span class="keyword">this</span>);</span><br><span class="line">        connect(watcher, &amp;QDBusPendingCallWatcher::finished, [<span class="keyword">this</span>, adapterPoweredOnCall, adapter] &#123;</span><br><span class="line">            <span class="keyword">if</span> (!adapterPoweredOnCall.isError()) &#123;</span><br><span class="line">                setAdapterDiscoverable(adapter-&gt;id());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                qWarning() &lt;&lt; adapterPoweredOnCall.error().message();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码其实是可以优化的，我们可以通过三元表达式获取某个QDBusPendingCall，这样就可以使用一个QDBusPendingCallWatcher对象，然后将原本的lambda内容提取到其他函数内，在新的lambda中同样使用三元表达式运行对应的函数，这样拆分代码的好处是，阅读代码时的顺序会和执行顺序一致，分支判断对机器和人类都不是太友好，特别是判断体内有很长的代码段，找到else段是一件不容易的事情，通过降低if else块来提高代码可读性。同时应提取相同动作的代码到公共区域，以免将来修改时发现没有将所有的地方都做修改。</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>避免使用数组的方式来访问元素，使用迭代器的方式统一循环方式。</p><p>我注意到有些情况下，有人在for循环内直接定义静态变量，这种方式使用的时候需要注意，静态变量将会永远存在，但是大部分for循环内需要保存的数据都是成员变量，否则内存空间将永远不会释放，对内存有浪费。</p><p>而且经常遇到的问题就是foreach宏和for混用，在语法上就没有统一使用。</p><p>我推荐的方式是for+迭代器的方式，如果是简单遍历，使用原生的foreach语法即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原生foreach语法，推荐只读遍历使用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> item: <span class="built_in">list</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for+迭代器，只读遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">list</span>.cbegin(); it != <span class="built_in">list</span>.cend(); ++it) &#123;</span><br><span class="line">    <span class="comment">// it是迭代器对象，需要解引用使用。</span></span><br><span class="line">    *it</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for+迭代器方式，推荐需要修改容器的长度使用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">list</span>.begin(); it != <span class="built_in">list</span>.end();) &#123;</span><br><span class="line">    <span class="comment">// 注意，如果要移除某个元素，需要手动下一步</span></span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">2</span>) &#123;</span><br><span class="line">        it = <span class="built_in">list</span>.erase(it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>经常遇到使用容器将指针保存下来的场景，但是当对象被析构或者容器被清空的时候，有时候会忘记删除内部的对象，或者删除了不该删除的对象。对数据的处理应该保持RAII原则，避免直接使用裸指针，而是通过智能指针将指针保存起来，当最后一个对象不再持有智能指针对象时，智能指针会删除持有的对象，完成内存释放。</p><p>智能指针的类型</p><p>智能指针包含有三种：独占指针<code>unique_ptr</code>、共享指针<code>shared_ptr</code>和弱引用指针<code>week_ptr</code>。</p><h3 id="独占指针"><a href="#独占指针" class="headerlink" title="独占指针"></a>独占指针</h3><p>独占指针<code>std::unique_ptr</code>可以避免对象被转移到其他对象中，如果某个对象持有<code>unique_ptr</code>，则该ptr不允许转移给其他对象，但是可以使用<code>std::move</code>来转移控制权，注意这和普通的转移不一样，<code>unique_ptr</code>禁止的是拷贝，但是没有禁止移动，我们可以转移控制转，<code>unique_ptr</code>保证的是只有一个智能指针持有对象。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; p1 = <span class="built_in">std</span>::move(ptr);</span><br></pre></td></tr></table></figure><h3 id="共享指针"><a href="#共享指针" class="headerlink" title="共享指针"></a>共享指针</h3><p>共享指针<code>std::shared_ptr</code>顾名思义是用作共享的，和独占指针不同的是，它支持复制，内部通过引用计数来维持对象的生命周期，当没有任何一个对象持有共享指针时，也就意味着没有任何一个对象可以访问到内部对象了，就可以安全的删除对象，释放内存。</p><h4 id="弱引用指针"><a href="#弱引用指针" class="headerlink" title="弱引用指针"></a>弱引用指针</h4><p>弱引用指针<code>std::week_ptr</code>是为了避免两个共享指针相互持有导致引用计数永远不会归零，导致内存永远不释放而提出的解决方案，具体就是弱引用指针不会导致引用计数增加，但是week_ptr同样不支持复制，必须转换为共享指针<code>std::shared_ptr</code>。</p><h2 id="优化判断条件"><a href="#优化判断条件" class="headerlink" title="优化判断条件"></a>优化判断条件</h2><p>对于常数的判断，尽量使用宏或者定义静态常量来避免直接使用数字或者字符判断。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>发现很多人在需要排序的时候总是使用冒泡算法，我介绍几个比较方便的排序方法。</p><h3 id="使用std-sort"><a href="#使用std-sort" class="headerlink" title="使用std::sort"></a>使用std::sort</h3><p>C++标准库提供了<code>std::sort</code>方法来方便的排序，它有三个参数，第一个参数是容器的begin迭代器，第二个参数是end迭代器，第三个参数接收一个返回值为bool类型的函数，该函数用于实现手动控制排序的判断。</p><p>我们可以提供一个lambda表达式来方便的控制排序，或者提供一个函数指针。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>&#123; <span class="number">10</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::sort(<span class="built_in">list</span>.begin(), <span class="built_in">list</span>.end(), [](<span class="keyword">int</span> num1, <span class="keyword">int</span> num2) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 &lt; num2;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种排序方式是直接对原始容器进行操作的，如果不希望数据成为脏数据，应该先复制一份。</p><h3 id="使用容器"><a href="#使用容器" class="headerlink" title="使用容器"></a>使用容器</h3><p>使用容器的方式比较麻烦一些，我们需要对象自己支持大小比较，或者顺序是外部某个列表列表控制的。</p><p>我们可以使用map将内部数据和标记数据建立映射关系，再通过外部的list或者其他方式，从map中将数据读出来，添加到新的列表容器中，从而完成排序。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="string">&quot;page1&quot;</span>, <span class="string">&quot;page2&quot;</span>, <span class="string">&quot;page3&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;String, QWidget*&gt; <span class="built_in">map</span>;</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> StringList &amp; <span class="built_in">list</span> = QJsonDocument::fromJson(readAll(“order.json”)).toStdList();</span><br><span class="line"></span><br><span class="line">QList&lt;QWidget*&gt; pages;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> QString&amp; key : <span class="built_in">list</span>) &#123;</span><br><span class="line">    pages &lt;&lt; <span class="built_in">map</span>[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇文章记录这几年项目中C++的一些问题和优化方法。需要注意的是，代码优化没有一本万利的方法，只能见招拆招，而且还要避免过早优化等问题，代码优化一定是要中后期才可以，而且不要为了优化而优化。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://blog.justforlxz.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>使用inquirer提供交互式git commit</title>
    <link href="https://blog.justforlxz.com/2020/06/15/%E4%BD%BF%E7%94%A8inquirer%E6%8F%90%E4%BE%9B%E4%BA%A4%E4%BA%92%E5%BC%8Fgit-commit/"/>
    <id>https://blog.justforlxz.com/2020/06/15/%E4%BD%BF%E7%94%A8inquirer%E6%8F%90%E4%BE%9B%E4%BA%A4%E4%BA%92%E5%BC%8Fgit-commit/</id>
    <published>2020-06-15T10:36:19.000Z</published>
    <updated>2020-09-17T08:26:18.428Z</updated>
    
    <content type="html"><![CDATA[<p>公司计划规范所有commit提交，开发部门综合出来了一份模板。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">title（应当使用陈述句，简短的描述这个提交所做的事情）</span><br><span class="line"></span><br><span class="line">Description（详细说明代码的改动，包含代码的实现思路，以及为什么这么做，可能会影响哪些功能。对于代码的审核者，需要从这段描述中能完全理解代码中所有改动的内容）</span><br><span class="line"></span><br><span class="line">Log: 写一段面向于产品的总结性内容，用于自动生成crp上的changlog，需要注意的事，这段描述必须从产品的角度考虑。</span><br><span class="line">Bug: https://xxxxxxxxxxx 对应pms bug的链接</span><br><span class="line">Issue: fix #xx 所修复的bug对于的github issue，其中 &quot;fix #xx&quot;是github关闭issue的规则，此处内容只需要满足github的要求即可，详情请参考 https://help.github.com/en/enterprise/2.16/user/github/managing-your-work-on-github/closing-issues-using-keywords</span><br><span class="line">Task: http://xxxxxxxxxxxx 对应pms任务的链接</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="python-inquirer"><a href="#python-inquirer" class="headerlink" title="python inquirer"></a>python inquirer</h2><p>之前在掘金上看到有人在使用交互式的commit来规范commit信息，觉得用起来挺不错的，刚好符合本次公司的要求，不过原项目是nodejs的，项目里肯定不能让每个开发都安装一个node,所以就找一下代替品，然后就发现了<a href="https://github.com/magmax/python-inquirer">python-inquirer</a>。</p><p>使用起来也非常的方便，通过inquirer.Text、inquirer.List、inquirer.Checkbox就可以创建相应的交互，并把组合好的列表交给inquirer.prompt处理，返回一个对象，内部包含了所有做出的选择。</p><h3 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> inquirer</span><br><span class="line">questions = [</span><br><span class="line">  inquirer.Text(<span class="string">&#x27;name&#x27;</span>, message=<span class="string">&quot;What&#x27;s your name&quot;</span>),</span><br><span class="line">  inquirer.Text(<span class="string">&#x27;surname&#x27;</span>, message=<span class="string">&quot;What&#x27;s your surname&quot;</span>),</span><br><span class="line">  inquirer.Text(<span class="string">&#x27;phone&#x27;</span>, message=<span class="string">&quot;What&#x27;s your phone number&quot;</span>,</span><br><span class="line">                validate=<span class="keyword">lambda</span> _, x: re.match(<span class="string">&#x27;\+?\d[\d ]+\d&#x27;</span>, x),</span><br><span class="line">                )</span><br><span class="line">]</span><br><span class="line">answers = inquirer.prompt(questions)</span><br></pre></td></tr></table></figure><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> inquirer</span><br><span class="line">questions = [</span><br><span class="line">  inquirer.List(<span class="string">&#x27;size&#x27;</span>,</span><br><span class="line">                message=<span class="string">&quot;What size do you need?&quot;</span>,</span><br><span class="line">                choices=[<span class="string">&#x27;Jumbo&#x27;</span>, <span class="string">&#x27;Large&#x27;</span>, <span class="string">&#x27;Standard&#x27;</span>, <span class="string">&#x27;Medium&#x27;</span>, <span class="string">&#x27;Small&#x27;</span>, <span class="string">&#x27;Micro&#x27;</span>],</span><br><span class="line">            ),</span><br><span class="line">]</span><br><span class="line">answers = inquirer.prompt(questions)</span><br></pre></td></tr></table></figure><h3 id="CheckBox"><a href="#CheckBox" class="headerlink" title="CheckBox"></a>CheckBox</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> inquirer</span><br><span class="line">questions = [</span><br><span class="line">  inquirer.Checkbox(<span class="string">&#x27;interests&#x27;</span>,</span><br><span class="line">                    message=<span class="string">&quot;What are you interested in?&quot;</span>,</span><br><span class="line">                    choices=[<span class="string">&#x27;Computers&#x27;</span>, <span class="string">&#x27;Books&#x27;</span>, <span class="string">&#x27;Science&#x27;</span>, <span class="string">&#x27;Nature&#x27;</span>, <span class="string">&#x27;Fantasy&#x27;</span>, <span class="string">&#x27;History&#x27;</span>],</span><br><span class="line">                    ),</span><br><span class="line">]</span><br><span class="line">answers = inquirer.prompt(questions)</span><br></pre></td></tr></table></figure><h2 id="公司的模板"><a href="#公司的模板" class="headerlink" title="公司的模板"></a>公司的模板</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> inquirer</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> Template</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">number_validation</span>(<span class="params">answers, current</span>):</span></span><br><span class="line">  <span class="keyword">return</span> int(current)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">empty_validation</span>(<span class="params">answers, current</span>):</span></span><br><span class="line">  <span class="keyword">return</span> bool(current)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">no_validation</span>(<span class="params">answers, current</span>):</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addList</span>(<span class="params">name, message, list</span>):</span></span><br><span class="line">  <span class="keyword">return</span> inquirer.List(name, message, list)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addText</span>(<span class="params">name, message, valid</span>):</span></span><br><span class="line">  <span class="keyword">return</span> inquirer.Text(name, message, validate=valid)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addCheck</span>(<span class="params">_name, _message, _choices</span>):</span></span><br><span class="line">  <span class="keyword">return</span> inquirer.Checkbox(_name, message=_message, choices=_choices)</span><br><span class="line"></span><br><span class="line">questions = [</span><br><span class="line">  addCheck(<span class="string">&quot;action&quot;</span>, <span class="string">&quot;选择非选项&quot;</span>, [<span class="string">&#x27;Bug&#x27;</span>, <span class="string">&#x27;Issue&#x27;</span>, <span class="string">&#x27;Task&#x27;</span>])</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">optinalAnswers = inquirer.prompt(questions)</span><br><span class="line"></span><br><span class="line">questions = [</span><br><span class="line">  addList(<span class="string">&#x27;action&#x27;</span>, <span class="string">&quot;select you action&quot;</span>, [<span class="string">&#x27;fix&#x27;</span>, <span class="string">&#x27;feat&#x27;</span>, <span class="string">&#x27;refactor&#x27;</span>, <span class="string">&#x27;docs&#x27;</span>, <span class="string">&#x27;chore&#x27;</span>, <span class="string">&#x27;style&#x27;</span>, <span class="string">&#x27;pref&#x27;</span>, <span class="string">&#x27;test&#x27;</span>]),</span><br><span class="line">  addText(<span class="string">&quot;module&quot;</span>, <span class="string">&quot;input module name&quot;</span>, no_validation),</span><br><span class="line">  addText(<span class="string">&#x27;title&#x27;</span>, <span class="string">&quot;input title&quot;</span>, empty_validation),</span><br><span class="line">  addText(<span class="string">&#x27;description&#x27;</span>, <span class="string">&quot;input description&quot;</span>, empty_validation),</span><br><span class="line">  addText(<span class="string">&quot;log&quot;</span>, <span class="string">&quot;input log&quot;</span>, empty_validation),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">optinal = &#123;</span><br><span class="line">  <span class="string">&quot;Bug&quot;</span>: addText(<span class="string">&quot;bug&quot;</span>, <span class="string">&quot;input bug id&quot;</span>, number_validation),</span><br><span class="line">  <span class="string">&quot;Issue&quot;</span>: addText(<span class="string">&quot;issue&quot;</span>, <span class="string">&quot;input issue id&quot;</span>, empty_validation),</span><br><span class="line">  <span class="string">&quot;Task&quot;</span>: addText(<span class="string">&quot;task&quot;</span>, <span class="string">&quot;input task id&quot;</span>, number_validation),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">optinalMap = &#123;</span><br><span class="line">  <span class="string">&quot;Bug&quot;</span>: <span class="string">&quot;bug&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Issue&quot;</span>: <span class="string">&quot;issue&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Task&quot;</span>: <span class="string">&quot;task&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> action <span class="keyword">in</span> optinalAnswers[<span class="string">&quot;action&quot;</span>]:</span><br><span class="line">  questions.append(optinal[action])</span><br><span class="line"></span><br><span class="line">answers = inquirer.prompt(questions)</span><br><span class="line"></span><br><span class="line">template = <span class="string">&#x27;$&#123;action&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> answers[<span class="string">&quot;module&quot;</span>]:</span><br><span class="line">  template += <span class="string">&#x27;($&#123;module&#125;)&#x27;</span></span><br><span class="line"></span><br><span class="line">template += <span class="string">&#x27;: $&#123;title&#125;\n\nDescription: $&#123;description&#125;\n\nLog: $&#123;log&#125;\n&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> action <span class="keyword">in</span> optinalAnswers[<span class="string">&quot;action&quot;</span>]:</span><br><span class="line">  template += action + <span class="string">&quot;: $&#123;&quot;</span> + optinalMap[action] + <span class="string">&quot;&#125;\n&quot;</span></span><br><span class="line"></span><br><span class="line">subprocess.run([<span class="string">&quot;git&quot;</span>, <span class="string">&quot;commit&quot;</span>, <span class="string">&quot;-m&quot;</span>, Template(template).substitute(answers)])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="修改git-editor"><a href="#修改git-editor" class="headerlink" title="修改git editor"></a>修改git editor</h3><p>将上面的内容保存到/usr/bin/git-inquirer。</p><p>当我们执行git inquirer的时候就能看到交互，当操作完成后可以看到git log中message已经是按模板填充了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;公司计划规范所有commit提交，开发部门综合出来了一份模板。&lt;/p&gt;
&lt;figure class=&quot;highlight text&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;title（应当使用陈述句，简短的描述这个提交所做的事情）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Description（详细说明代码的改动，包含代码的实现思路，以及为什么这么做，可能会影响哪些功能。对于代码的审核者，需要从这段描述中能完全理解代码中所有改动的内容）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Log: 写一段面向于产品的总结性内容，用于自动生成crp上的changlog，需要注意的事，这段描述必须从产品的角度考虑。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Bug: https://xxxxxxxxxxx 对应pms bug的链接&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Issue: fix #xx 所修复的bug对于的github issue，其中 &amp;quot;fix #xx&amp;quot;是github关闭issue的规则，此处内容只需要满足github的要求即可，详情请参考 https://help.github.com/en/enterprise/2.16/user/github/managing-your-work-on-github/closing-issues-using-keywords&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Task: http://xxxxxxxxxxxx 对应pms任务的链接&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://blog.justforlxz.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>vue-router路由复用后页面没有刷新</title>
    <link href="https://blog.justforlxz.com/2020/06/01/vue-router%E8%B7%AF%E7%94%B1%E5%A4%8D%E7%94%A8%E5%90%8E%E9%A1%B5%E9%9D%A2%E6%B2%A1%E6%9C%89%E5%88%B7%E6%96%B0/"/>
    <id>https://blog.justforlxz.com/2020/06/01/vue-router%E8%B7%AF%E7%94%B1%E5%A4%8D%E7%94%A8%E5%90%8E%E9%A1%B5%E9%9D%A2%E6%B2%A1%E6%9C%89%E5%88%B7%E6%96%B0/</id>
    <published>2020-06-01T10:35:41.000Z</published>
    <updated>2020-09-17T08:26:18.428Z</updated>
    
    <content type="html"><![CDATA[<p>vue-router提供了页面路由功能，可以用来构建单页面应用，在使用vue-router的动态路由匹配的时候，遇到了url变化了，但是页面却没有任何动静的问题，记录一下。</p><a id="more"></a><p>动态路由匹配url变化了，但是组件没有变化是因为vue进行了组件复用，因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会再被调用。所以我们需要手动进行数据刷新。</p><p>我们可以简单的使用watch来监听当前的路由变化，从而实现数据刷新。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; watch &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&quot;./router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">        <span class="comment">// vue2</span></span><br><span class="line">        <span class="comment">// watch: &#123;</span></span><br><span class="line">        <span class="comment">//     $route(to, from) &#123;</span></span><br><span class="line">        <span class="comment">//         // 对路由变化作出响应...</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// vue3</span></span><br><span class="line">        watch(router.currentRoute, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;路由发生了变化&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可以使用2.2中新加的beforeRouteUpdate路由守卫：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    beforeRouteUpdate(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 不要在这里调用next</span></span><br><span class="line">        <span class="comment">// 通过to来判断是否重载数据</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;路由发生了变化&quot;</span>);</span><br><span class="line">    &#125;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是vue3中使用vue-router-next来处理动态路由变化导致页面不刷新的方法。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;vue-router提供了页面路由功能，可以用来构建单页面应用，在使用vue-router的动态路由匹配的时候，遇到了url变化了，但是页面却没有任何动静的问题，记录一下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Web" scheme="https://blog.justforlxz.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>vue3升级遇到的坑</title>
    <link href="https://blog.justforlxz.com/2020/05/31/vue3-upgrade/"/>
    <id>https://blog.justforlxz.com/2020/05/31/vue3-upgrade/</id>
    <published>2020-05-31T21:11:43.000Z</published>
    <updated>2020-09-17T08:26:18.428Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直忙工作上的事，对提高自身能力的事有点落下了，趁着今天把之前思考的一些问题都给解决了，也顺手给自己的VueBlog把vue和webpack都升级到最新的beta版本，然后遇到了很多坑，今天就把坑都记录一下，免的以后忘了。</p><p>VueBlog目前使用的是webpack5 + vue3 + vue-router-next + typescript构建，目的在于替换当前的hexo站点，同样也是一个静态博客生成器，不过和hexo的定位不同，我使用的是单页面设计，而不是给每个页面生成对应的html文件，所以对SEO不友好，以后再想办法吧。</p><a id="more"></a><h2 id="升级Vue3"><a href="#升级Vue3" class="headerlink" title="升级Vue3"></a>升级Vue3</h2><p>首先使用<code>vue add vue-next</code>来升级vue到beta版本，执行以后vue会对代码进行一次转换，将旧版本的一些api转换为新版本。</p><h3 id="App"><a href="#App" class="headerlink" title="App"></a>App</h3><p>例如将main.ts中创建App对象的代码转换为新的，在vue2中，我们通过new Vue()来创建app对象，并调用$mount函数挂在元素。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import App from &quot;.&#x2F;App.vue&quot;;</span><br><span class="line">const app &#x3D; new Vue(App);</span><br><span class="line">app.$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure><p>在vue3中，主体思想都尽量通过函数来进行了，因为可以通过函数的参数和返回值进行类型推导。在vue3中，创建app对象通过createApp函数来进行，再通过mount函数挂载dom元素。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import App from &quot;.&#x2F;App.vue&quot;;</span><br><span class="line">const app &#x3D; createApp(APp);</span><br><span class="line">app.mount(&quot;#app&quot;);</span><br></pre></td></tr></table></figure><h3 id="Vur-Router"><a href="#Vur-Router" class="headerlink" title="Vur Router"></a>Vur Router</h3><p>如果使用的有vue-router之类的插件，使用方法也有一些变化，router也需要通过对应的create函数创建。首先需要先升级vue-router，vue-router的下一个版本叫<a href="https://github.com/vuejs/vue-router-next">vue-router-next</a>。在vue-router中，创建router对象的函数从VueRouter函数改为createRouter。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default router;</span><br></pre></td></tr></table></figure><p>在vue3中则需要使用新的函数返回：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const router &#x3D; createRouter(&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default router;</span><br></pre></td></tr></table></figure><p>内容也改了一部分，可以访问<a href="https://github.com/vuejs/vue-router-next">github</a>仓库来看文档。</p><h3 id="composition-API"><a href="#composition-API" class="headerlink" title="composition API"></a>composition API</h3><p>composition api是vue3提出的核心功能，其核心目的是通过将分散在各处的数据都整合到一个setup函数中进行初始化，并依赖vue的响应式数据改变来完成功能实现。</p><p>在RFC中就有composition api的动机。</p><blockquote><h4 id="更好的逻辑复用与代码组织"><a href="#更好的逻辑复用与代码组织" class="headerlink" title="更好的逻辑复用与代码组织"></a>更好的逻辑复用与代码组织</h4><ol><li>随着功能的增长，复杂组件的代码变得越来越难以阅读和理解。这种情况在开发人员阅读他人编写的代码时尤为常见。根本原因是 Vue 现有的 API 迫使我们通过选项组织代码，但是有的时候通过逻辑关系组织代码更有意义。</li><li>目前缺少一种简洁且低成本的机制来提取和重用多个组件之间的逻辑。<h4 id="更好的类型推导"><a href="#更好的类型推导" class="headerlink" title="更好的类型推导"></a>更好的类型推导</h4>另一个来自大型项目开发者的常见需求是更好的 TypeScript 支持。Vue 当前的 API 在集成 TypeScript 时遇到了不小的麻烦，其主要原因是 Vue 依靠一个简单的 this 上下文来暴露 property，我们现在使用 this 的方式是比较微妙的。（比如 methods 选项下的函数的 this 是指向组件实例的，而不是这个 methods 对象）。</li></ol><p>换句话说，Vue 现有的 API 在设计之初没有照顾到类型推导，这使适配 TypeScript 变得复杂。<br>相比较过后，本 RFC 中提出的方案更多地利用了天然对类型友好的普通变量与函数。用该提案中的 API 撰写的代码会完美享用类型推导，并且也不用做太多额外的类型标注。</p><p>这也同样意味着你写出的 JavaScript 代码几乎就是 TypeScript 的代码。即使是非 TypeScript 开发者也会因此得到更好的 IDE 类型支持而获益。</p><p><a href="https://composition-api.vuejs.org/zh/api.html">composition api</a> 文档官方</p><p><a href="https://composition-api.vuejs.org/zh">vue3 rfc</a> rfc网站</p></blockquote><p>setup函数用起来确实舒服，所有有用的东西都可以放在一块，代码整理也方便，不像以前一样需要分散到各种hook和计算属性、data函数中。但是也有我用起来不舒服的地方，基本类型和对象都需要使用ref函数和reactive函数进行包装，有的时候用起来就各种麻烦，需要多注意一些。不过这个问题倒不是什么大问题，和写c++的时候所有的对象用智能指针包裹一层一样，用多了就习惯了。</p><p>这是一个vue2的经典例子，通过data函数和计算属性来返回不同的数据。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default new Vue(&#123;</span><br><span class="line">    data: function() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            message: &quot;hello&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        reversedMessage: function () &#123;</span><br><span class="line">            return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在vue3中就可以全部集中到setup函数，并且一并返回，模板可以直接使用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; ref, computed &#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">        const message &#x3D; ref(&quot;hello&quot;);</span><br><span class="line">        const reversedMessage &#x3D; computed(() &#x3D;&gt; &#123;</span><br><span class="line">            return message.value.split(&#39;&#39;).reverse().join(&#39;&#39;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return &#123; message, reversedMessage &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出使用setup函数可以将模板所需的内容一块返回，结构更为清晰，vue2的模式也是可以的，只不过侧重点不一样，vue2的目的是一种动作的数据应该被放在一块，而vue3的setup函数则是将数据处理都放在一块，这样对数据的的整理比较方便和集中。</p><h3 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h3><p>props是在组件上注册的自定义属性，当一个值传递给props的时候，它就会成为那个组件的一个property。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;hello v-bind:message&#x3D;&quot;message&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>hello组件可以通过定义props函数来接收自定义属性。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default new Vue(&#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">        message: String</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样就可以在helle.vue中使用message这个属性，不过需要注意的是，hello组件不要修改传递进来的message,否则会破坏数据的流向。</p><p>在vue3中使用会更加方便，因为类型推导更加方便。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Props &#123;</span><br><span class="line">    message?: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">        message: &#123;</span><br><span class="line">            type: String,</span><br><span class="line">            require: false,</span><br><span class="line">            default: &quot;&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    setup(props: Props) &#123;</span><br><span class="line">        const reversedMessage &#x3D; computed(() &#x3D;&gt; &#123;</span><br><span class="line">            if (props.message &#x3D;&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">                return String;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            const innerMessage &#x3D; props.message;</span><br><span class="line">            return innerMessage.split(&#39;&#39;).reverse().join(&#39;&#39;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return &#123; reversedMessage &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在vue3和typescript中使用props需要有一些注意的地方，首先Props里需要设置值可能为空，否则setup函数的签名将无法匹配。其次访问props数据需要开启setup函数的props参数，还有一个context参数，可以访问上下文的内容。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近一直忙工作上的事，对提高自身能力的事有点落下了，趁着今天把之前思考的一些问题都给解决了，也顺手给自己的VueBlog把vue和webpack都升级到最新的beta版本，然后遇到了很多坑，今天就把坑都记录一下，免的以后忘了。&lt;/p&gt;
&lt;p&gt;VueBlog目前使用的是webpack5 + vue3 + vue-router-next + typescript构建，目的在于替换当前的hexo站点，同样也是一个静态博客生成器，不过和hexo的定位不同，我使用的是单页面设计，而不是给每个页面生成对应的html文件，所以对SEO不友好，以后再想办法吧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="web" scheme="https://blog.justforlxz.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript建造者模式</title>
    <link href="https://blog.justforlxz.com/2020/02/01/JavaScript%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://blog.justforlxz.com/2020/02/01/JavaScript%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-02-01T20:52:58.000Z</published>
    <updated>2020-09-17T08:26:18.336Z</updated>
    
    <content type="html"><![CDATA[<p>建造者模式就是指将类的构造和其表示分离开来，调用者可以通过不同的构建过程创造出不同表示的对象。主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，由于需求的变化，这个复杂对象的某些部分经常面临着剧烈的变化，一些基本部件不会变。所以需要将变与不变分离。与抽象工厂的区别：在建造者模式里，有个指导者(Director)，由指导者来管理建造者，用户是与指导者联系的，指导者联系建造者最后得到产品。即建造者模式可以强制实行一种分步骤进行的建造过程。</p><a id="more"></a><h2 id="建造者模式四要素"><a href="#建造者模式四要素" class="headerlink" title="建造者模式四要素"></a>建造者模式四要素</h2><ol><li>产品类Product: 一般是一个较为复杂的对象，也就是说创建对象的过程比较复杂，一般会有较多的代码。</li><li>抽象建造者类Builder: 将建造的具体过程交予它的子类来实现。</li><li>建造者类ConcreateBuilder: 组件产品，返回组件好的产品</li><li>指导类Director: 负责调用适当的建造者来组件产品，指导类一般不与产品类发生依赖关系，与指导类直接交互的是建造者类。</li></ol><h2 id="建造者模式的优点"><a href="#建造者模式的优点" class="headerlink" title="建造者模式的优点"></a>建造者模式的优点</h2><p>建造者模式的封装很好，使用建造者模式可以进行有效的封装变化，在使用建造者模式的场景中，产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指导者类中对整体可以取得比较好的稳定性。</p><p>建造者类也很方便扩展，如果有新的需求，只需要实现一个新的建造者类即可。</p><p>产品类 product.ts</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Product &#123;</span><br><span class="line">    private _name: String;</span><br><span class="line">    public name(): String &#123;</span><br><span class="line">        return this._name;</span><br><span class="line">    &#125;</span><br><span class="line">    public setName(name: String) &#123;</span><br><span class="line">        this._name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象建造类 builder.ts</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Builder &#123;</span><br><span class="line">    _product: Product;</span><br><span class="line">    setName(name: String): Product;</span><br><span class="line">    build(): Product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建造类 concreatebuilder.ts</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ConcreateBuilder implements Builder &#123;</span><br><span class="line">    _product: Product &#x3D; new Product;</span><br><span class="line">    public setName(name: String): Product &#123;</span><br><span class="line">        this._product.setName(name);</span><br><span class="line">        return this._product;</span><br><span class="line">    &#125;</span><br><span class="line">    public build(): Product &#123;</span><br><span class="line">        return this._product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HelloworldBuilder extends ConcreateBuilder &#123;</span><br><span class="line">    public build(): Product &#123;</span><br><span class="line">        this._product.setName(&quot;hello world!&quot;);</span><br><span class="line">        return this._product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指导类 director.ts</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Director &#123;</span><br><span class="line">    private _defaultBuilder: ConcreateBuilder &#x3D; new ConcreateBuilder;</span><br><span class="line">    private _helloworldBuilder: HelloworldBuilder &#x3D; new HelloworldBuilder;</span><br><span class="line">    public buildForDefault(): Product  &#123;</span><br><span class="line">        return this._defaultBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line">    public buildForHelloworld(): Product &#123;</span><br><span class="line">        return this._helloworldBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试运行:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let director &#x3D; new Director();</span><br><span class="line">console.log(director.buildForDefault().name());</span><br><span class="line">console.log(director.buildForHelloworld().name());</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">undefined</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p>通过不同的builder就可以构建不同的对象出来，当需求变动的时候，我们只需要扩展出不同的Builder和Director就可以满足。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;建造者模式就是指将类的构造和其表示分离开来，调用者可以通过不同的构建过程创造出不同表示的对象。主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，由于需求的变化，这个复杂对象的某些部分经常面临着剧烈的变化，一些基本部件不会变。所以需要将变与不变分离。与抽象工厂的区别：在建造者模式里，有个指导者(Director)，由指导者来管理建造者，用户是与指导者联系的，指导者联系建造者最后得到产品。即建造者模式可以强制实行一种分步骤进行的建造过程。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://blog.justforlxz.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Javascript" scheme="https://blog.justforlxz.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Javascript构造器模式</title>
    <link href="https://blog.justforlxz.com/2020/01/31/%E6%B5%85%E8%B0%88Javascript%E6%9E%84%E9%80%A0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://blog.justforlxz.com/2020/01/31/%E6%B5%85%E8%B0%88Javascript%E6%9E%84%E9%80%A0%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-01-31T23:15:23.000Z</published>
    <updated>2020-09-17T08:26:18.436Z</updated>
    
    <content type="html"><![CDATA[<p>为了简化操作，JavaScript提供了new关键字。new关键字用于创建一个用户定义类型的实例，或者具有构造函数的内置对象的实例。</p><a id="more"></a><p>每当我们在一个函数调用前使用new关键字，该函数便会以一种特殊模式——构造模式来运行，在此模式中，JavaScript可以自动完成一些操作。基本上它是指解释器在你的代码中嵌入几行操作代码。</p><p>在JavaScript中，构造函数通常是认为用来实现实例的，但是JavaScript中没有类的概念，但是有特殊的构造函数，通过new关键字来调用定义的构造函数，你可以告诉JavaScript你需要创建一个新对象，并且新对象的成员声明都是构造函数里定义的。在构造函数内部，this引用的是新创建的对象。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function People(name: String, age: Number) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    this.output &#x3D; function() &#123;</span><br><span class="line">        return this.name + &quot;已经&quot; + this.age + &quot;岁了&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let people &#x3D; new People(&quot;justforlxz&quot;, 24);</span><br><span class="line"></span><br><span class="line">console.log(people.output());</span><br></pre></td></tr></table></figure><p>上面是个很简单的构造函数模式，我们从字面上this是people对象，但是其实并不是这样的，new运算符帮助我们生成了this的初始化代码。</p><p>new运算符一共做了三件事：</p><ol><li>创建一个空对象</li><li>将空对象的原型赋值为构造器函数的原型</li><li>更改构造器函数内部的this，将其指向新创建的对象</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let tmp &#x3D; new Object();</span><br><span class="line">tmp.__proto__ &#x3D; People.prototype;</span><br><span class="line">People.call(tmp);</span><br></pre></td></tr></table></figure><p>最后会经过一个判断，如果构造器函数设置了返回值，并且返回值是一个Object类型的话，就直接返回该Object，否则就会返回新创建的空对象。</p><p>总结一下： JavaScript没有类的概念，但是为了实现OOP，就通过new关键字实现对函数进行插入代码来实现对象实例的初始化。构造器模式就是通过一个方法来new出一个对象，这个操作就叫构造器模式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;为了简化操作，JavaScript提供了new关键字。new关键字用于创建一个用户定义类型的实例，或者具有构造函数的内置对象的实例。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://blog.justforlxz.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Javascript" scheme="https://blog.justforlxz.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>2019 Review</title>
    <link href="https://blog.justforlxz.com/2020/01/01/2019review/"/>
    <id>https://blog.justforlxz.com/2020/01/01/2019review/</id>
    <published>2020-01-01T21:25:54.000Z</published>
    <updated>2020-09-17T08:26:18.336Z</updated>
    
    <content type="html"><![CDATA[<p>上一次写年终总结还是18年回家的动车上，可惜写了一半没发表，觉得一年了没有什么能够回想起来的，就又删除了。今年不同了，今年有好多想说的。</p><a id="more"></a><h2 id="脱单"><a href="#脱单" class="headerlink" title="脱单"></a>脱单</h2><p><strong>第一件重要的事是我遇到了生命中的她。</strong></p><p>自从工作以后，我妈天天念叨我的就是找对象，和我预想的没错，上学的时候盼我毕业，毕业以后盼我工作，工作以后盼我找对象结婚，找对象以后盼我赶紧生个娃让她抱。<del>（大家的父母应该都这样）</del></p><h2 id="加薪"><a href="#加薪" class="headerlink" title="加薪"></a>加薪</h2><p>这件事确实也令我挺开心的，我的工资在2019年成功涨到了0.375乔(1乔等于**元  <a href="https://blog.nanpuyue.com/">@nanpuyue</a>)</p><p>涨工资谁不高兴，我估计也就马云不高兴了，毕竟他看不上钱。</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>今年看了很多C++的资料，对C++和编译器都有了更深的了解。想2016年半夜<a href="https://zcc.rs/">@zccrs</a>在家教我编译原理，到现在我可以理解一门语言从设计到实现，再到使用模板完成编译时计算，我走了快三年，这三年里我一直没停下学习的脚步，在学习各种知识，从各种编程语言到各种框架原理，到图形界面的实现。还学习了单元测试，并且<a href="https://hualet.org/">@hualet</a>大佬给我讲了单元测试是什么，以及单元测试的重要性，从那以后我才算真正的了解单元测试的重要性，也使我在写代码的时候注重通过单元测试来保障我的功能。</p><p>去年对深度学习进行了一波学习，今年对Web工程化和TypeScript也学习了一下，也算是对目前最热门的两个领域进行了一定的了解。</p><h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>去年买的TensorFlow看了没一半，今年倒是没买书，开始在微信读书上读书，利用一些空余时间读一点，我也推荐大家多利用空闲时间读读书，少刷抖音和bilibili。</p><ul><li>《TensorFlow》未读完</li><li>《TypeScript实战》正在读</li></ul><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><p>2019年我一共水了15篇文章。</p><ul><li><p>12-26 <a href="https://blog.justforlxz.com/2019/12/26/use-serial-port-debug-deepin-on-archlinux/">在ArchLinux通过串口调试VMware虚拟机中的deepin</a></p></li><li><p>12-26 <a href="https://blog.justforlxz.com/2019/12/26/cpp-sort/">使用标准库std::sort函数进行排序</a></p></li><li><p>12-09 <a href="https://blog.justforlxz.com/2019/12/09/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AA%E5%9D%91%E7%88%B9%E7%9A%84usb%E7%BD%91%E5%8D%A1/">记录一个坑爹的usb网卡</a></p></li><li><p>12-09 <a href="https://blog.justforlxz.com/2019/12/09/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AA%E5%9D%91%E7%88%B9%E7%9A%84usb%E7%BD%91%E5%8D%A1/">使用github actions自动部署hexo文章到html仓库</a></p></li><li><p>12-08 <a href="https://blog.justforlxz.com/2019/12/08/vue-component-props/">Vue父子组件传值 —— props &amp; $emit</a></p></li><li><p>12-08 <a href="https://blog.justforlxz.com/2019/12/08/vue-transitions/">添加Vue动画</a></p></li><li><p>11-25 <a href="https://blog.justforlxz.com/2019/11/25/%E4%BD%BF%E7%94%A8webpack-dev-server%E6%9D%A5%E7%9B%91%E5%90%AC%E9%A1%B9%E7%9B%AE%E5%8F%98%E5%8C%96/">使用webpack-dev-server来监听项目变化</a></p></li><li><p>10-24 <a href="https://blog.justforlxz.com/2019/10/24/%E7%BB%99Archlinux%E5%BC%80%E5%90%AFBFQ%E5%92%8CMuQSS/">给Archlinux开启BFQ和MuQSS</a></p></li><li><p>10-22 <a href="https://blog.justforlxz.com/2019/10/22/%E4%BD%BF%E7%94%A8webpack%E6%89%93%E5%8C%85Vue%E5%92%8CTypeScript/">使用webpack打包Vue和TypeScript</a></p></li><li><p>10-14 <a href="https://blog.justforlxz.com/2019/10/14/webpack%E5%85%A5%E9%97%A8/">webpack入门</a></p></li><li><p>06-16 <a href="https://blog.justforlxz.com/2019/06/16/wsl2%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/">wsl2的使用体验</a></p></li><li><p>06-15 <a href="https://blog.justforlxz.com/2019/06/15/%E5%85%A5%E5%9D%91typescript%E4%BA%86/">入坑typescript了</a></p></li><li><p>05-23 <a href="https://blog.justforlxz.com/2019/05/23/CMake-CTests-for-dde-control-center/">CMake CTests for dde-control-center</a></p></li><li><p>02-21 <a href="https://blog.justforlxz.com/2019/02/21/how-to-use-LNMP-on-deepin/">如何在Deepin上使用LNMP</a></p></li><li><p>02-23 <a href="https://blog.justforlxz.com/2019/01/23/fuck-taobao/">解决用了xposed后淘宝闪退</a></p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019</span><br><span class="line">├── 01</span><br><span class="line">│   └── 23</span><br><span class="line">│       └── fuck-taobao</span><br><span class="line">│           └── index.html</span><br><span class="line">├── 02</span><br><span class="line">│   └── 21</span><br><span class="line">│       └── how-to-use-LNMP-on-deepin</span><br><span class="line">│           └── index.html</span><br><span class="line">├── 05</span><br><span class="line">│   └── 23</span><br><span class="line">│       └── CMake-CTests-for-dde-control-center</span><br><span class="line">│           └── index.html</span><br><span class="line">├── 06</span><br><span class="line">│   ├── 15</span><br><span class="line">│   │   └── 入坑typescript了</span><br><span class="line">│   │       ├── 深度录屏_选择区域_20190615202044.gif</span><br><span class="line">│   │       └── index.html</span><br><span class="line">│   └── 16</span><br><span class="line">│       └── wsl2的使用体验</span><br><span class="line">│           ├── index.html</span><br><span class="line">│           ├── Snipaste_2019-06-16_21-49-15.png</span><br><span class="line">│           └── Snipaste_2019-06-16_21-52-42.png</span><br><span class="line">├── 10</span><br><span class="line">│   ├── 14</span><br><span class="line">│   │   └── webpack入门</span><br><span class="line">│   │       └── index.html</span><br><span class="line">│   ├── 22</span><br><span class="line">│   │   └── 使用webpack打包Vue和TypeScript</span><br><span class="line">│   │       └── index.html</span><br><span class="line">│   └── 24</span><br><span class="line">│       └── 给Archlinux开启BFQ和MuQSS</span><br><span class="line">│           └── index.html</span><br><span class="line">├── 11</span><br><span class="line">│   └── 25</span><br><span class="line">│       └── 使用webpack-dev-server来监听项目变化</span><br><span class="line">│           └── index.html</span><br><span class="line">└── 12</span><br><span class="line">    ├── 08</span><br><span class="line">    │   ├── vue-component-props</span><br><span class="line">    │   │   └── index.html</span><br><span class="line">    │   └── vue-transitions</span><br><span class="line">    │       └── index.html</span><br><span class="line">    ├── 09</span><br><span class="line">    │   ├── 记录一个坑爹的usb网卡</span><br><span class="line">    │   │   └── index.html</span><br><span class="line">    │   └── use-github-actions-to-depoly-hexo</span><br><span class="line">    │       └── index.html</span><br><span class="line">    └── 26</span><br><span class="line">        ├── cpp-sort</span><br><span class="line">        │   └── index.html</span><br><span class="line">        └── use-serial-port-debug-deepin-on-archlinux</span><br><span class="line">            └── index.html</span><br><span class="line"></span><br><span class="line">34 directories, 18 files</span><br></pre></td></tr></table></figure><h2 id="科普视频"><a href="#科普视频" class="headerlink" title="科普视频"></a>科普视频</h2><ol><li>妈咪叔 (一个较真的理工男)</li></ol><p>这个名字我第一眼看到的时候，还以为是个卖母婴的，没想到居然是个搞科普的，而且内容讲的也很好，有数学、物理、化学和天文学。</p><ol start="2"><li>李永乐老师</li></ol><p>以前偶尔看过老师的视频，因为一直都在热榜，所以没想到关注，后来是youtube上看到了，就点了关注，youtube上更新的和bilibili的还不是一样的，看最后结尾的时候youtube的只说youtube帐号关注，而bilibili的是bilibili，有时候还要多个平台去看。</p><ol start="3"><li>萝王二号</li></ol><p>之前在科普区随便看的时候，对生物学产生了一些兴趣，萝王讲的风格我很喜欢，特别是他注重昆虫分类学(骨包皮，皮包骨啊2333)，还有一些辟谣视频。</p><ol start="4"><li>芳斯塔夫 (鬼古)</li></ol><p>也使对生物学产生了一些兴趣，鬼古说以他很中二的风格带领我学习了一波古生物的相关知识(旧日支配者！！！)。</p><ol start="5"><li>木偶君</li></ol><p>和鬼古一样是专门讲古生物的，不过每次结束的比较仓促，突然就结束了。</p><ol start="6"><li>木鱼水心</li></ol><p>木鱼并不是今年才关注的，最开始关注是他做EVA剧场版解析，后来《木鱼说》开始做一些科普，我开始一直关注了。</p><ol start="7"><li>宇宙视觉 (永远不要停止思考)</li></ol><p>一个讲天文的科普up，不过年底的时候换了配音，疑似配音出去单干了。</p><h2 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h2><ol><li>流浪地球</li><li>阿丽塔：战斗天使</li><li>战狼2</li><li>惊奇队长</li><li>复仇者联盟4</li><li>何以为家</li><li>速度与激情： 特别行动</li><li>叶问4</li></ol><h2 id="纪录片"><a href="#纪录片" class="headerlink" title="纪录片"></a>纪录片</h2><ol><li>混沌：数学探秘</li><li>维度：数学漫步</li></ol><h2 id="动漫"><a href="#动漫" class="headerlink" title="动漫"></a>动漫</h2><ol><li>刀剑神域</li><li>紫罗兰永恒花园</li><li>darling in the franxx</li><li>心理测量者</li><li>进击的巨人第三季</li><li>五等分的新娘</li><li>citrus～柑橘味香气～</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一次写年终总结还是18年回家的动车上，可惜写了一半没发表，觉得一年了没有什么能够回想起来的，就又删除了。今年不同了，今年有好多想说的。&lt;/p&gt;</summary>
    
    
    
    <category term="年度总结" scheme="https://blog.justforlxz.com/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="2019" scheme="https://blog.justforlxz.com/tags/2019/"/>
    
  </entry>
  
  <entry>
    <title>使用伪元素创建一个圆点</title>
    <link href="https://blog.justforlxz.com/2020/01/01/%E4%BD%BF%E7%94%A8%E4%BC%AA%E5%85%83%E7%B4%A0%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9C%86%E7%82%B9/"/>
    <id>https://blog.justforlxz.com/2020/01/01/%E4%BD%BF%E7%94%A8%E4%BC%AA%E5%85%83%E7%B4%A0%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9C%86%E7%82%B9/</id>
    <published>2020-01-01T11:11:12.000Z</published>
    <updated>2020-09-17T08:26:18.428Z</updated>
    
    <content type="html"><![CDATA[<p>我最早接触到CSS中的伪元素是在一次写背景模糊的时候，CSS中的blur会模糊下面所有的元素，但是可以通过伪元素在before中先模糊，这样下层是没有任何元素的，自然也不会有元素被模糊。</p><p>伪元素就如同它的名字一样，是假的元素，只是CSS引擎在排版的时候创建出来的，在DOM树中是不存在的，所以javascript是没办法操作伪元素的。伪元素分为before和after，可以在元素的前面或者后面创建一个假的元素，伪元素选择器的标志符号是<code>::</code>。</p><ol><li><code>div::before</code> 在div元素的前面创建一个元素，配合content属性一起使用。</li><li><code>div::after</code> 在div元素的后面创建一个元素，配合content属性一起使用。</li></ol><img src="/2020/01/01/%E4%BD%BF%E7%94%A8%E4%BC%AA%E5%85%83%E7%B4%A0%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9C%86%E7%82%B9/16-57-30%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" class="" width="1657"><p>使用伪元素选择器需要注意一点的是，必须使用content属性，否则将不起任何作用。</p><p>伪元素选择器生效以后，可以在DOM中看到::before或者::after，这里提供一个例子。</p><p>html部分：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        Text</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><p>css部分：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div::before &#123;</span><br><span class="line">  content: &quot;This is before Text, &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div::after &#123;</span><br><span class="line">  content: &quot;, This is after Text.&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时页面上会看到输出这么一句话，<code>This  is before Text, Text , This is after Text.</code>，并且使用鼠标只能选择到最中间的Text文本。</p><img src="/2020/01/01/%E4%BD%BF%E7%94%A8%E4%BC%AA%E5%85%83%E7%B4%A0%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9C%86%E7%82%B9/16-57-16.png" class="" width="1657"><p>代码可以点击<a href="https://jsfiddle.net/justforlxz/shg21kvb/18/">这里</a>查看。</p><p>今天写这篇文章呢，是因为今天我在实现hexo的Next主题，看到它在列表中使用after创建了一个小圆点，并且我遇到了一个问题，所以写这篇文章记录一下。</p><p>Next用的是浮动布局来实现的，而我决定flex一把梭，整体布局是垂直的flex，首页、分类等列表内部是用水平的inline-flex实现的，最左边是图标，来自fortawesome，中间的文本使用span包裹一下，实现左对齐，然后通过伪元素在最右边创建一个小圆点，设置a元素的宽度为100%，就可以实现圆点在最右边。</p><p>坑就是在这里遇到的，如果a元素的宽度设置为100%，伪元素创建的小圆点就不能完全显示，少1像素或者多1像素就可以完全显示。最终的解决办法是给小圆点的周围增加了1像素的padding解决了，但是原因位置，谁看到这篇文章并且恰好知道原因的，还请帮忙评论回复一下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;site-nav&quot;&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for&#x3D;&quot;item in items&quot; v-bind:key&#x3D;&quot;item.title&quot;&gt;</span><br><span class="line">      &lt;a v-bind:href&#x3D;&quot;item.link&quot;&gt;</span><br><span class="line">        &lt;span id&#x3D;&quot;menu-left&quot; v-bind:class&#x3D;&quot;item.class&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span id&#x3D;&quot;menu-text&quot;&gt;</span><br><span class="line">          &#123;&#123; item.title &#125;&#125;</span><br><span class="line">        &lt;&#x2F;span&gt;</span><br><span class="line">      &lt;&#x2F;a&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#site-nav &#123;</span><br><span class="line">  background: white;</span><br><span class="line">  padding: 20px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ul &#123;</span><br><span class="line">  margin: 0;</span><br><span class="line">  padding: 0 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#site-nav li &#123;</span><br><span class="line">  list-style-type: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#site-nav li a &#123;</span><br><span class="line">  padding: 5px 0px;</span><br><span class="line">  text-align: left;</span><br><span class="line">  line-height: inherit;</span><br><span class="line">  transition-property: background-color;</span><br><span class="line">  transition-duration: 0.2s;</span><br><span class="line">  transition-timing-function: ease-in-out;</span><br><span class="line">  transition-delay: 0s;</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: space-between;</span><br><span class="line">  align-items: center;</span><br><span class="line">  text-decoration: none;</span><br><span class="line">  font-size: 13px;</span><br><span class="line">  border-bottom: 1px solid transparent;</span><br><span class="line">  color: #555;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#site-nav li a:hover &#123;</span><br><span class="line">  background: #f9f9f9;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#menu-left &#123;</span><br><span class="line">  align-content: center;</span><br><span class="line">  margin-left: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#menu-text &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  margin-left: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#site-nav li a::after &#123;</span><br><span class="line">  content: &#39; &#39;;</span><br><span class="line">  background: #bbb;</span><br><span class="line">  width: 6px;</span><br><span class="line">  height: 6px;</span><br><span class="line">  border-radius: 50%;</span><br><span class="line">  margin: 0 10px 0 0;</span><br><span class="line">  min-width: 6px;</span><br><span class="line">  min-height: 6px;</span><br><span class="line">  max-height: 6px;</span><br><span class="line">  max-width: 6px;</span><br><span class="line">  display: block;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我提取了基本结构和css，demo是能够正常显示小圆点的，但是自己的Vue却不能正常显示，后来发现是display写成块级元素用的flex了，改成inline-flex就能正常显示了，但是在调整宽度的时候，就发现了上面的问题，它又不正常显示了，实在解决不了了，就用padding处理了。</p><p>参考资料： <a href="https://github.com/qianguyihao/Web/blob/master/02-CSS%E5%9F%BA%E7%A1%80/10-CSS3%E9%80%89%E6%8B%A9%E5%99%A8%E8%AF%A6%E8%A7%A3.md">千古壹号</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我最早接触到CSS中的伪元素是在一次写背景模糊的时候，CSS中的blur会模糊下面所有的元素，但是可以通过伪元素在before中先模糊，这样下层是没有任何元素的，自然也不会有元素被模糊。&lt;/p&gt;
&lt;p&gt;伪元素就如同它的名字一样，是假的元素，只是CSS引擎在排版的时候创建出来</summary>
      
    
    
    
    <category term="Web" scheme="https://blog.justforlxz.com/categories/Web/"/>
    
    
    <category term="CSS" scheme="https://blog.justforlxz.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>在ArchLinux通过串口调试VMware虚拟机中的deepin</title>
    <link href="https://blog.justforlxz.com/2019/12/26/use-serial-port-debug-deepin-on-archlinux/"/>
    <id>https://blog.justforlxz.com/2019/12/26/use-serial-port-debug-deepin-on-archlinux/</id>
    <published>2019-12-26T17:26:13.000Z</published>
    <updated>2020-09-17T08:26:18.396Z</updated>
    
    <content type="html"><![CDATA[<p>电脑主板上的接口：进行串行传输的接口，它一次只能传输1Bit。串行端口可以用于连接外置调制解调器、绘图仪或串行打印机。它也可以控制台连接的方式连接网络设备，例如路由器和交换机，主要用来配置它们。消费性电子已经由USB取代串列接口；但在非消费性用途，如网络设备等，串列接口仍是主要的传输控制方式。</p><a id="more"></a><p>首先给虚拟机分配一个串口设备，选择Settings-&gt;Add-&gt;Serial Port。分配好串口设备以后，我们需要选择一个串口设备的调试方式，一个是将输出转向一个文件，或者是通过socket。</p><p>如果只是查看方式，选择outpu file即可。如果需要调试，则可以通过socket方式来进行。</p><p>socket方式需要给一个固定的路径分配/tmp/<socket>，我调试的时候给出的是/tmp/vhost，From选择Server，To选择An Application。From的意思是信息从哪里来，信息是虚拟机里的系统发出的，所以这里选择的是Server，如果是反向操作，需要选择Client。To也是有两个选项，第一个是An Virtual Machine，第二个是An Application。用于把消息发送给另外的虚拟机，或者是宿主机的一个应用程序。</p><p>安装minicom包，用于进行调试，minicom这个东西，不是太好用，退出方式是先按Ctrl+A，然后按q，有时候还不一定管用，不知道是没接受到，还是按错了。</p><p>先minicom -s 进行初始化，选择<code>Serial port setup</code>，按A编辑<code>Serial Device</code>，这里需要注意一下，通过socket进行调试，需要使用<code>unix#</code>前缀，然后加上在虚拟机里写的路径 <code>unix#/tmp/vhost</code>。然后保存，选择Exit，退出以后其实重启minicom，就进入minicom的调试界面了，然后此时开启虚拟机，给内核添加一个console=ttyS0的参数，就看到minicom显示输出的信息了，还可以交互。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[    3.855725] [drm:vmw_fb_setcolreg [vmwgfx]] *ERROR* Bad regno 254.</span><br><span class="line">[    3.857125] [drm:vmw_fb_setcolreg [vmwgfx]] *ERROR* Bad regno 255.</span><br><span class="line">deepin Login:</span><br><span class="line"></span><br><span class="line">CTRL-A Z for help | unix-socket | NOR | Minicom 2.7.1 | VT102 | Offline | unix#&#x2F;tmp&#x2F;vhost</span><br></pre></td></tr></table></figure><p>此时就可以交互了，用法和tty一样，最后一行是minicom的输出，可以看到CTRL-A Z可以看help，minicom的版本，和访问的串口socket。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;电脑主板上的接口：进行串行传输的接口，它一次只能传输1Bit。串行端口可以用于连接外置调制解调器、绘图仪或串行打印机。它也可以控制台连接的方式连接网络设备，例如路由器和交换机，主要用来配置它们。消费性电子已经由USB取代串列接口；但在非消费性用途，如网络设备等，串列接口仍是主要的传输控制方式。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://blog.justforlxz.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.justforlxz.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用标准库std::sort函数进行排序</title>
    <link href="https://blog.justforlxz.com/2019/12/26/cpp-sort/"/>
    <id>https://blog.justforlxz.com/2019/12/26/cpp-sort/</id>
    <published>2019-12-26T17:24:23.000Z</published>
    <updated>2020-09-17T08:26:18.336Z</updated>
    
    <content type="html"><![CDATA[<p>std的sort方法接受两个迭代器begin和end。通过迭代器来抽象元素的访问，隐藏内部实现。</p><a id="more"></a><p>这是一个简单的例子:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::list&lt;int&gt; list &#123;</span><br><span class="line">    0,</span><br><span class="line">    4,</span><br><span class="line">    2,</span><br><span class="line">    1,</span><br><span class="line">    3,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::sort(list.begin(), list.end());</span><br></pre></td></tr></table></figure><p>结果就是list被排序了，至于使用了什么排序算法，我们并不需要关心。实际上标准库会通过元素的数量来决定使用什么算法，基于Introspective Sorting(内省式排序)。<br>它是一种混合式的排序算法：</p><ul><li><p>在数据量很大时采用正常的快速排序，此时效率为O(logN)。</p></li><li><p>一旦分段后的数据量小于某个阈值，就改用插入排序，因为此时这个分段是基本有序的，这时效率可达O(N)。</p></li><li><p>在递归过程中，如果递归层次过深，分割行为有恶化倾向时，它能够自动侦测出来，使用堆排序来处理，在此情况下，使其效率维持在堆排序的O(N logN)，但这又比一开始使用堆排序好。</p></li></ul><p>默认情况下排序是升序排序，既结果从小到大，我们可以通过使用std::equal_to<T>、std::not_equal_to<T>、std::greater<T>、std::less<T>、std::greater_equal<T>和std::less_equal<T>来控制排序。</p><p>以上是通过标准库内置的一些方式来控制排序，且适用于元素已实现了自定义比较(Compare)的要求。</p><p>比较 (Compare) 是一些标准库设施针对用户提供的函数对象类型所期待的一组要求。</p><p>对满足比较 (Compare) 的类型的对象运用函数调用操作的返回值，当按语境转换成 bool 时，若此类型所引入的严格弱序关系中，该调用的第一实参先于第二实参，则生成 true，否则生成 false。</p><p>与任何二元谓词 (BinaryPredicate) 相同，不允许该表达式的求值通过解引用的迭代器调用非 const 函数。</p><p>用人话来说就是，Compare必须提供出对比结果。</p><p>看一个例子:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Test &#123;</span><br><span class="line">    int i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::list&lt;Test&gt; list &#123;</span><br><span class="line">    new Test(2),</span><br><span class="line">    new Test(1),</span><br><span class="line">    new Test(4),</span><br><span class="line">    new Test(3),</span><br><span class="line">    new Test(5),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::sort(list.begin(), list.end(), [&#x3D;] (const Test&amp; test1, const Test&amp; test2) -&gt; bool &#123;</span><br><span class="line">    return test1.i &lt; test2.i;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个例子提供了一个Compare，通过lambda来提供自定义的对比函数，返回值必须是bool，否则将不满足对比函数的要求。</p><p>通过以上三种方式可以看出，标准库的sort函数可以很方便的为使用者提供标准对比和自定义对比。如果元素自己已实现operator&lt;，则只需要使用标准库内置的对比函数即可，但是大部分情况其实并不会涉及到元素的排序，仅在临时情况下需要列表有序，所以我个人倾向于通过lambda提供Compare函数来完成列表的排序。</p><p><a href="https://zh.cppreference.com/w/cpp/algorithm/sort">std::sort</a><br><a href="http://feihu.me/blog/2014/sgi-std-sort/">知无涯之std::sort源码剖析</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;std的sort方法接受两个迭代器begin和end。通过迭代器来抽象元素的访问，隐藏内部实现。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>记录一个坑爹的usb网卡</title>
    <link href="https://blog.justforlxz.com/2019/12/09/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AA%E5%9D%91%E7%88%B9%E7%9A%84usb%E7%BD%91%E5%8D%A1/"/>
    <id>https://blog.justforlxz.com/2019/12/09/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AA%E5%9D%91%E7%88%B9%E7%9A%84usb%E7%BD%91%E5%8D%A1/</id>
    <published>2019-12-09T19:31:04.000Z</published>
    <updated>2020-09-17T08:26:18.436Z</updated>
    
    <content type="html"><![CDATA[<p>网卡型号是Realtek RTL8811CU/RTL8821CU USB Wi-Fi adapter，买来是为了让黑苹果上网的，windows下也会自动下载和安装驱动，但是linux比较难受，内核不提供这样的驱动，只能去官方拿源码搞，今天在arch上打算装一下驱动，结果遇到了很多问题。</p><p>wiki上推荐的8821应该使用rtl88xxau-aircrack-dkms-git，但是我安装以后压根不能用，一点变化都没有，而且modprobe也没有作者给出的88XXau，无奈只得放弃。</p><p>继续谷歌之，在<a href="https://forum.mxlinux.org/viewtopic.php?f=107&t=50579">https://forum.mxlinux.org/viewtopic.php?f=107&amp;t=50579</a>看到了别人给的方案，然后果断clone并make,然后就因为没有适配5.x的内核编译失败，这可不行，翻了一下issue，看到作者在<a href="https://github.com/whitebatman2/rtl8821CU/issues/33">https://github.com/whitebatman2/rtl8821CU/issues/33</a>提到了一个<a href="https://github.com/whitebatman2/rtl8821CU/issues/23">#23</a>，这标题写的够可以，<code>Newer version 5.4.1 (Support Linux versions from 4.4.x up to 5.4.x) </code>，赶紧搞起，去源地址clone和make,成功使用上了驱动，按照作者提到的安装<code>usb_modeswitch</code>，并切换usb模式，我成功的使用上了这个usb网卡。</p><blockquote><p>吐槽一下，开发环境还是linux下舒服，仓库的包安装一下就可以开发了，windows下要自己写路径，mac下brew限制太死，一些库安装以后还要自己手动做些处理，一不小心就把shell的环境变量搞不行了，或者压根不能正常工作。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网卡型号是Realtek RTL8811CU/RTL8821CU USB Wi-Fi adapter，买来是为了让黑苹果上网的，windows下也会自动下载和安装驱动，但是linux比较难受，内核不提供这样的驱动，只能去官方拿源码搞，今天在arch上打算装一下驱动，结果遇到</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.justforlxz.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.justforlxz.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用github actions自动部署hexo文章到html仓库</title>
    <link href="https://blog.justforlxz.com/2019/12/09/use-github-actions-to-depoly-hexo/"/>
    <id>https://blog.justforlxz.com/2019/12/09/use-github-actions-to-depoly-hexo/</id>
    <published>2019-12-09T13:19:11.000Z</published>
    <updated>2020-09-17T08:26:18.356Z</updated>
    
    <content type="html"><![CDATA[<p>请先允许我大喊一声：微软牛逼！</p><p>本文没有啥含金量，就是简单的说一下如何部署github-actions来自动生成hexo的public，并且再推送到html仓库的。</p><p>我的博客仓库一共分为两个，blog仓库是私有的，需要通过我的私钥才能访问，html仓库是公开的，hexo生成的静态内容会被上传到这里。</p><p>首先在package.json中添加一些命令，方便我们一键编译和提交:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;build&quot;: &quot;hexo clean &amp;&amp; hexo g&quot;,</span><br><span class="line">  &quot;deploy&quot;: &quot;yarn run build &amp;&amp; hexo d&quot;,</span><br><span class="line">  &quot;backup&quot;: &quot;hexo b&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为CI环境需要提交代码到仓库，所以申请一个个人用的token，访问<a href="https://github.com/settings/tokens">https://github.com/settings/tokens</a>创建一个新的，勾选上<code>repo</code>，生成完token以后，修改一下<code>_config.yml</code>中对deploy仓库的url，格式固定为<code>https://x-access-token:你的token@github.com/你的名字/仓库名.git</code>,例如我这里是<code>https://x-access-token:xxxxxxxxxx@github.com/justforlxz/html.git</code>。</p><p>然后新家一个github actions，选择nodejs环境，我们只需要修改最后一个步骤，执行我们自己的命令即可。</p><ul><li>设置git的用户名和邮箱地址</li><li>npm install -g yarn</li><li>yarn run deploy</li></ul><p>如果你还有一些其他步骤，可以自行扩展，比如我就有主题相关的操作，具体的内容如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- name: npm install, build, and deploy</span><br><span class="line">  run: |</span><br><span class="line">    git config --global user.email &quot;justforlxz@gmail.com&quot;</span><br><span class="line">    git config --global user.name &quot;justforlxz&quot;</span><br><span class="line">    git submodule update --init</span><br><span class="line">    cd themes&#x2F;next</span><br><span class="line">    git checkout dev</span><br><span class="line">    cd ..&#x2F;..&#x2F;</span><br><span class="line">    npm install -g yarn</span><br><span class="line">    yarn</span><br><span class="line">    yarn run deploy</span><br></pre></td></tr></table></figure><p>然后就可以愉快的自动部署了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;请先允许我大喊一声：微软牛逼！&lt;/p&gt;
&lt;p&gt;本文没有啥含金量，就是简单的说一下如何部署github-actions来自动生成hexo的public，并且再推送到html仓库的。&lt;/p&gt;
&lt;p&gt;我的博客仓库一共分为两个，blog仓库是私有的，需要通过我的私钥才能访问，htm</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue父子组件传值 —— props &amp; $emit</title>
    <link href="https://blog.justforlxz.com/2019/12/08/vue-component-props/"/>
    <id>https://blog.justforlxz.com/2019/12/08/vue-component-props/</id>
    <published>2019-12-08T21:08:00.000Z</published>
    <updated>2020-09-17T08:26:18.428Z</updated>
    
    <content type="html"><![CDATA[<p>Vue的父子组件传值比较有意思，父组件通过属性绑定，把自身的值和子组件的一个属性绑定起来，子组件通过props属性接收，该属性类型为数组，是Vue对象中比较少有的类型，data、computer、methods等方法都是对象的形式，props则是数组的形式。父组件通过v-on来监听子组件发出的事件来接收子组件的调用。在这里我是理解成子组件发送信号来通知上层，毕竟调用的是this.$emit来做到的。</p><a id="more"></a><p>我们假设子组件名为<hello>，我们通过v-bind来绑定一个值给它。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;#app&quot;&gt;</span><br><span class="line">        &#x2F;&#x2F; 通过v-bind绑定父子组件的属性</span><br><span class="line">        &lt;hello v-bind:messageFromParent&#x3D;&quot;message&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line">import Hello from &#39;.&#x2F;Hello.vue&#39;;</span><br><span class="line">export default Vue.extend(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: &quot;this message from parent&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        &quot;hello&quot;: Hello</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>子组件hello.vue通过props属性接收，内容是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &#123;&#123; messageFromParent &#125;&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line">export default Vue.extend(&#123;</span><br><span class="line">    &#x2F;&#x2F; 通过props数组接收</span><br><span class="line">    props: [ &quot;messageFromParent&quot; ]</span><br><span class="line">&#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>这里有个需要注意的地方，父组件给子组件的数据是单向的，虽然子组件也可以修改父组件传入的数据，但是会产生一个错误，并打印在终端里。</p><p>那么我们怎么才能修改父组件的值呢？答案是<code>this.$emit</code>。</p><p>我们给子组件绑定上v-on，来监听子组件的事件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;#app&quot;&gt;</span><br><span class="line">        &#x2F;&#x2F; 通过v-bind绑定父子组件的属性，通过v-on监听子组件的属性变化</span><br><span class="line">        &lt;hello v-bind:messageFromParent&#x3D;&quot;message&quot; v-on:changeParentData&#x3D;&quot;changeData&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line">import Hello from &#39;.&#x2F;Hello.vue&#39;;</span><br><span class="line">export default Vue.extend(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: &quot;this message from parent&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        &quot;hello&quot;: Hello</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        changeData: function(data: string) &#123;</span><br><span class="line">            message &#x3D; data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>子组件只需要发送出修改即可：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;button v-on:click&#x3D;&quot;change&quot;&gt;修改父组件数据&lt;&#x2F;button&gt;</span><br><span class="line">        &#123;&#123; messageFromParent &#125;&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line">export default Vue.extend(&#123;</span><br><span class="line">    &#x2F;&#x2F; 通过props数组接收</span><br><span class="line">    props: [ &quot;messageFromParent&quot; ],</span><br><span class="line">    methods: &#123;</span><br><span class="line">        change: function() &#123;</span><br><span class="line">            &#x2F;&#x2F; 调用this.$emit方法第一个参数是事件的名称，后面全部都是参数。</span><br><span class="line">            &#x2F;&#x2F; this.$emit方法其实是自定义了一个事件，通过这种方式来完成子组件向父组件传递消息。</span><br><span class="line">            this.$emit(&quot;changeParentData&quot;, &quot;change data by child&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>以上就是Vue父子组件传值的一种常用方法，适用于相邻组件的，如果隔代了，那么这种方式就不好用了，中间路过的组件都需要转发这个事件，处理这种情况就需要使用<code>provide/ inject</code>了，不过那就是另一篇文章啦。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Vue的父子组件传值比较有意思，父组件通过属性绑定，把自身的值和子组件的一个属性绑定起来，子组件通过props属性接收，该属性类型为数组，是Vue对象中比较少有的类型，data、computer、methods等方法都是对象的形式，props则是数组的形式。父组件通过v-on来监听子组件发出的事件来接收子组件的调用。在这里我是理解成子组件发送信号来通知上层，毕竟调用的是this.$emit来做到的。&lt;/p&gt;</summary>
    
    
    
    <category term="Vue" scheme="https://blog.justforlxz.com/categories/Vue/"/>
    
    
    <category term="Vue" scheme="https://blog.justforlxz.com/tags/Vue/"/>
    
  </entry>
  
</feed>
