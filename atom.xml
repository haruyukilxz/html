<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小竹&#39;s blog</title>
  
  <subtitle>永远不要停止思考</subtitle>
  <link href="https://blog.justforlxz.com/atom.xml" rel="self"/>
  
  <link href="https://blog.justforlxz.com/"/>
  <updated>2021-03-04T07:40:49.317Z</updated>
  <id>https://blog.justforlxz.com/</id>
  
  <author>
    <name>小竹</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何给Arch打一个包</title>
    <link href="https://blog.justforlxz.com/2021/03/04/package-manager-for-arch/"/>
    <id>https://blog.justforlxz.com/2021/03/04/package-manager-for-arch/</id>
    <published>2021-03-04T11:23:42.000Z</published>
    <updated>2021-03-04T07:40:49.317Z</updated>
    
    <content type="html"><![CDATA[<p>Arch 使用的是 pacman 包管理器，包格式是 tar.zst。Arch 提供了一些工具用于创建 tar.zst 包，首先需要安装 base-devel 包和 dev-tools 包。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S base-devel dev-tools</span><br></pre></td></tr></table></figure><p>Arch 的打包流程是这样的，要先写一个 PKGBUILD 文件，这个文件描述了构建一个包所需的全部信息，如从哪里下载源码，依赖有哪些，构建的版本是多少，如何进行构建等。</p><h1 id="PKGBUILD"><a href="#PKGBUILD" class="headerlink" title="PKGBUILD"></a>PKGBUILD</h1><p>一个基本的 PKGBUILD 格式如下：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># Maintainer: justforlxz &lt;justforlxz@gmail.com&gt;</span><br><span class="line"></span><br><span class="line">pkgname=dtkcore-git</span><br><span class="line">pkgver=5.4.0.r1.ge7e7a99</span><br><span class="line">pkgrel=1</span><br><span class="line">pkgdesc=&#x27;DTK core modules&#x27;</span><br><span class="line">arch=(&#x27;x86_64&#x27;)</span><br><span class="line">url=&quot;https://github.com/linuxdeepin/dtkcore&quot;</span><br><span class="line">license=(&#x27;LGPL3&#x27;)</span><br><span class="line">depends=(&#x27;dconf&#x27; &#x27;deepin-desktop-base-git&#x27; &#x27;python&#x27; &#x27;gsettings-qt&#x27; &#x27;lshw&#x27;)</span><br><span class="line">makedepends=(&#x27;git&#x27; &#x27;qt5-tools&#x27; &#x27;gtest&#x27;)</span><br><span class="line">conflicts=(&#x27;dtkcore&#x27;)</span><br><span class="line">provides=(&#x27;dtkcore&#x27;)</span><br><span class="line">groups=(&#x27;deepin-git&#x27;)</span><br><span class="line">source=(&quot;$pkgname::git://github.com/linuxdeepin/dtkcore.git&quot;)</span><br><span class="line">sha512sums=(&#x27;SKIP&#x27;)</span><br><span class="line"></span><br><span class="line">pkgver() &#123;</span><br><span class="line">    cd $pkgname</span><br><span class="line">    git describe --long --tags | sed &#x27;s/\([^-]*-g\)/r\1/;s/-/./g&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build() &#123;</span><br><span class="line">  cd $pkgname</span><br><span class="line">  qmake-qt5 PREFIX=/usr DTK_VERSION=$pkgver LIB_INSTALL_DIR=/usr/lib</span><br><span class="line">  make</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package() &#123;</span><br><span class="line">  cd $pkgname</span><br><span class="line">  make INSTALL_ROOT=&quot;$pkgdir&quot; install</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 dtkcore 为例，整个配置文件十分清晰明了，一看就知道构建工具是如何一步步制作出一个包的。</p><p>将配置文件保存到目录里，以 <code>PKGBUILD</code> 命名，然后执行 <code>makepkg</code>。</p><p>makepkg 是用于执行 PKGBUILD 文件的工具，它根据文件中的描述，进行包的构建。</p><h1 id="如何提交一个包到-aur"><a href="#如何提交一个包到-aur" class="headerlink" title="如何提交一个包到 aur"></a>如何提交一个包到 aur</h1><p>当你希望自己打的包可以被别人使用的时候，一般都会请求上传到官方仓库，但是进入官方仓库的流程异常繁琐，而且对贡献者的要求会比较高。Arch 提供了一个用户仓库，供用户自由分享配置文件，只需要下载配置文件，在本机打包就可以了。</p><p>根据 aur 的 <a href="https://wiki.archlinux.org/index.php/AUR_submission_guidelines">贡献指南</a>，我们可以很轻松的上传自己的配置文件，并借用yay等aur工具自动下载和构建软件包。</p><blockquote><p>用户可以通过 Arch User Repository 分享 PKGBUILD。AUR 中不包含任何二进制包，仅包含用户上传的 PKGBUILD，供其他用户下载使用。所有软件包都是非官方的，使用风险自担。</p></blockquote><p>提交aur之前，需要先了解一下 aur 的一些要求，<a href="https://wiki.archlinux.org/index.php/AUR_submission_guidelines#Rules_of_submission">Rules of submission</a> 提供了一些规则，只要我们按照规则来，就可以上传和维护我们自己的包。</p><p>首先需要去 <a href="https://aur.archlinux.org/">aur官网</a> 注册一个账号，并上传自己的 ssh key 我们通过克隆一个新的仓库来作为上传的方式。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone ssh://aur@aur.archlinux.org/&lt;pkgname&gt;.git</span><br></pre></td></tr></table></figure><p>以dtkcore为例，克隆的时候把pkgname改成dtkcore。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone ssh://aur@aur.archlinux.org/dtkcore.git</span><br></pre></td></tr></table></figure><p><strong>如果是第一次创建，会提示你克隆的一个空仓库。</strong></p><p>把 PKGBUILD 文件复制到克隆的目录，然后执行 <code>makepkg --printsrcinfo &gt; .SRCINFO</code> 创建一个软件包信息，将 <code>.SRCINFO</code> 和 <code>PKGBUILD</code> 文件都添加到 git 中，然后提交 commit 信息，推送到服务器。</p><blockquote><p>注意： 如果您忘记在首次提交中包含 .SRCINFO，您可以使用 rebasing with –root 或是 filtering the tree 使得 AUR 接受您的第一次推送</p></blockquote><blockquote><p>提示： 为了保持工作目录和提交尽可能的干净，可以创建 gitignore 文件来排除所有文件，然后再按需添加文件。</p></blockquote><p>参考资料：</p><blockquote><p><a href="https://wiki.archlinux.org/index.php/PKGBUILD">https://wiki.archlinux.org/index.php/PKGBUILD</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Arch 使用的是 pacman 包管理器，包格式是 tar.zst。Arch 提供了一些工具用于创建 tar.zst 包，首先需要安装 base-devel 包和 dev-tools 包。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;tabl</summary>
      
    
    
    
    
    <category term="Linux" scheme="https://blog.justforlxz.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>timemachine</title>
    <link href="https://blog.justforlxz.com/2021/02/27/timemachine/"/>
    <id>https://blog.justforlxz.com/2021/02/27/timemachine/</id>
    <published>2021-02-27T11:35:29.000Z</published>
    <updated>2021-03-04T07:40:49.317Z</updated>
    
    <content type="html"><![CDATA[<p>接着上篇的 <a href="/samba">samba</a>，我给家里配置了 samba 服务器，为家里提供共享存储服务。</p><p>我在我笔记本上安装了黑苹果，所以也想顺便试试传说中的 <code>Time Machine</code> 自动备份，说不定还能整一套给 deepin 使用呢。</p><p>话不多说开干。</p><h1 id="安装-avahi"><a href="#安装-avahi" class="headerlink" title="安装 avahi"></a>安装 avahi</h1><p>Avahi 是一种免费的零配置网络实现，包括用于多播 DNS / DNS-SD服务发现的系统。它可以帮助我们广播 samba 服务器，这样网络内其他机器就可以查找到 samba 服务器了。</p><p>在 arch 上安装 avahi。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S avahi</span><br></pre></td></tr></table></figure><p>我们并不需要配置什么，直接开启服务就行了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable --now avahi-daemon</span><br></pre></td></tr></table></figure><h1 id="配置-samba"><a href="#配置-samba" class="headerlink" title="配置 samba"></a>配置 samba</h1><p>我们还需要稍微配置一下 samba 服务，专门开辟一个用于备份的目录。</p><p>修改 <code>/etc/samba/smb.conf</code>，添加一个 timemachine 的条目。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[timemachine]</span><br><span class="line">    comment = macos time machine backup</span><br><span class="line">    path = /home/lxz/TimeMachine</span><br><span class="line">    valid users = lxz</span><br><span class="line">    browseable = yes</span><br><span class="line">    writeable = yes</span><br><span class="line">    writelist = lxz</span><br><span class="line">    create mask = 0777</span><br><span class="line">    # 加载模块以支持AAPL拓展，注意顺序很重要！</span><br><span class="line">    vfs objects = catia fruit streams_xattr</span><br><span class="line">    # 支持aapl</span><br><span class="line">    fruit:aapl = yes</span><br><span class="line">    # 存储os x的元数据</span><br><span class="line">    fruit:metadata = stream</span><br><span class="line">    # 设置服务器在finder中的图标</span><br><span class="line">    fruit:model = MacPro</span><br><span class="line">    # 支持time machine，非常重要！</span><br><span class="line">    fruit:time machine = yes</span><br><span class="line">    # 文件清理的一些配置</span><br><span class="line">    fruit:posix_rename = yes</span><br><span class="line">    fruit:veto_appledouble = no</span><br><span class="line">    fruit:wipe_intentionally_left_blank_rfork = yes</span><br><span class="line">    fruit:delete_empty_adfiles = yes</span><br></pre></td></tr></table></figure><p>还需要设置 smb 协议的版本和开启苹果的支持，在配置文件中查找或者添加新的，注意，这里的配置文件必须是在上面条目的上方，我推荐是放在 <code>dns proxy</code> 的下方。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">min protocol = SMB2</span><br><span class="line">ea support = yes</span><br></pre></td></tr></table></figure><p>然后我们重启一下 samba 和 avahi的服务。</p><p>此时 TimeMachine 和 Finder 都会显示 samba 服务器了。</p><img src="/2021/02/27/timemachine/finder.png" class="lazy" data-srcset="/2021/02/27/timemachine/finder.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="timemachine&#x2F;finder.png"><h1 id="开启-time-machine"><a href="#开启-time-machine" class="headerlink" title="开启 time machine"></a>开启 time machine</h1><p>打开设置，进入时间机器，打开选择一个硬盘。</p><img src="/2021/02/27/timemachine/timemachine.png" class="lazy" data-srcset="/2021/02/27/timemachine/timemachine.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="timemachine&#x2F;timemachine.png"><p>选择共享的timemachine，点击使用硬盘，然后会弹出来认证的对话框，输入用户名和密码即可。</p><img src="/2021/02/27/timemachine/timemachine1.png" class="lazy" data-srcset="/2021/02/27/timemachine/timemachine1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="timemachine&#x2F;timemachine1.png"><img src="/2021/02/27/timemachine/finished.png" class="lazy" data-srcset="/2021/02/27/timemachine/finished.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="timemachine&#x2F;finished.png"><p>配置就算完成了，只需要等待自动备份，或者选择下面的在菜单栏中显示时间机器，在菜单栏里选择立即备份。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;接着上篇的 &lt;a href=&quot;/samba&quot;&gt;samba&lt;/a&gt;，我给家里配置了 samba 服务器，为家里提供共享存储服务。&lt;/p&gt;
&lt;p&gt;我在我笔记本上安装了黑苹果，所以也想顺便试试传说中的 &lt;code&gt;Time Machine&lt;/code&gt; 自动备份，说不定还能整一套</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>samba</title>
    <link href="https://blog.justforlxz.com/2021/02/27/samba/"/>
    <id>https://blog.justforlxz.com/2021/02/27/samba/</id>
    <published>2021-02-27T10:42:53.000Z</published>
    <updated>2021-03-04T07:40:49.317Z</updated>
    
    <content type="html"><![CDATA[<p>samba 是一个linux下开源的SMB/CIFS协议的免费软件，最初 SMB 协议是 Microsoft 开发的网络通讯协议，后来微软又把 SMB 改名为 CIFS（Common Internet File System），即公共 Internet 文件系统，并且加入了许多新的功能，这样一来，使得Samba具有了更强大的功能。</p><p>samba目前最大的作用是文件共享，服务器只需要提供账号和密码，就可以由 samba 客户端访问，并挂载到本地系统上。</p><p>我在家用了一个 macmini 当做家庭 nas，并且使用 archlinux 当做服务器系统，我在上面部署了 samba 服务，seafile 服务，nextcloud 服务，plex 服务，arai2c 下载机。</p><p>除了 samba 服务，其他服务都是运行在 docker 中，所以 samba 服务需要我手动配置。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>archlinux 安装 samba 服务很简单，只需要使用 pacman 安装 samba 包即可。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S samba</span><br></pre></td></tr></table></figure><p>安装完成以后我们就可以创建用户和配置共享目录了。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>由于 samba 不提供配置文件，所以我们要从网上下载基本的 <a href="https://man.archlinux.org/man/smb.conf.5">配置文件</a>。</p><h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><p>我们需要先在系统创建对应的用户，以我的用户名 lxz 为例。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd -m -g users -G wheel lxz</span><br></pre></td></tr></table></figure><h2 id="禁用用户登录"><a href="#禁用用户登录" class="headerlink" title="禁用用户登录"></a>禁用用户登录</h2><p>由于该用户只是为了权限相关的操作，所以我并没有计划使用该账户，如果需要在系统中使用该账户，则不需要进行接下来的禁用操作。</p><p><strong>禁用本地登录</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">usermod --shell /usr/bin/nologin --lock lxz</span><br></pre></td></tr></table></figure><p><strong>禁用ssh登录</strong></p><p>修改 <code>/etc/ssh/sshd_config</code> ，修改 <code>AllowUsers</code>。</p><h2 id="创建-samba-用户"><a href="#创建-samba-用户" class="headerlink" title="创建 samba 用户"></a>创建 samba 用户</h2><p>我们需要区分的是，尽管 samba 的用户和 Linux 系统本身的用户是同一个，但是密码则是分开存放的，我们需要使用 samba 提供的命令修改用户的密码。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">smbpasswd -a lxz</span><br></pre></td></tr></table></figure><p>修改密码则不使用 <code>-a</code> 参数：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">smbpasswd lxz</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>到此，我们已经完成了基本的 samba 配置，配置文件里默认开启了用户的家目录访问，所以我们使用 smb 客户端进行登录的时候，可以直接访问家目录。</p><h2 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable smb</span><br><span class="line">systemctl start smb</span><br></pre></td></tr></table></figure><p>使用 smbclient 可以验证本机服务。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">smbclient -L localhost -U%</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@LXZ-MacMini ~]# smbclient -L localhost -U%</span><br><span class="line"></span><br><span class="line">Sharename       Type      Comment</span><br><span class="line">---------       ----      -------</span><br><span class="line">timemachine     Disk      macos time machine backup</span><br><span class="line"><span class="meta">IPC$</span><span class="bash">            IPC       IPC Service (Samba Server)</span></span><br><span class="line">SMB1 disabled -- no workgroup available</span><br></pre></td></tr></table></figure><h1 id="添加其他的共享目录"><a href="#添加其他的共享目录" class="headerlink" title="添加其他的共享目录"></a>添加其他的共享目录</h1><p>除了用户家目录，我们还可以共享特定的目录。</p><p>例如我创建一个 data 目录，允许任何人只读访问。</p><p>修改 <code>/etc/samba/smb.conf</code> 文件，在末尾处添加配置。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Guests]</span><br><span class="line">  comment = Allow all users to read</span><br><span class="line">  path = /data</span><br><span class="line">  public = yes</span><br><span class="line">  only guest = yes</span><br><span class="line">  writable = no</span><br><span class="line">  printable = no</span><br></pre></td></tr></table></figure><p>然后重启 samba 服务，使用 smbclient 验证。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@LXZ-MacMini ~]# systemctl restart smb</span><br><span class="line">[root@LXZ-MacMini ~]# smbclient -L localhost -U%</span><br><span class="line"></span><br><span class="line">Sharename       Type      Comment</span><br><span class="line">---------       ----      -------</span><br><span class="line">timemachine     Disk      macos time machine backup</span><br><span class="line">Guests          Disk      Allow all users to read</span><br><span class="line"><span class="meta">IPC$</span><span class="bash">            IPC       IPC Service (Samba Server)</span></span><br><span class="line">SMB1 disabled -- no workgroup available</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;samba 是一个linux下开源的SMB/CIFS协议的免费软件，最初 SMB 协议是 Microsoft 开发的网络通讯协议，后来微软又把 SMB 改名为 CIFS（Common Internet File System），即公共 Internet 文件系统，并且加入了</summary>
      
    
    
    
    
    <category term="Linux" scheme="https://blog.justforlxz.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2020 Review</title>
    <link href="https://blog.justforlxz.com/2021/02/26/2020review/"/>
    <id>https://blog.justforlxz.com/2021/02/26/2020review/</id>
    <published>2021-02-26T22:51:45.000Z</published>
    <updated>2021-03-04T07:40:49.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h1><p>拖了这么久才更新博客，想必大家都在 2020 年过的挺不好的，年初武汉的疫情打了全国一个措不及防，甚至已经一整年了，全球疫情还是十分紧张。截止到 2021 年 2 月 26 日，全球每日新增仍然有30 多万，而且全球累计死亡已有 250 万人之多。</p><h1 id="疫情"><a href="#疫情" class="headerlink" title="疫情"></a>疫情</h1><p>生命是如此的脆弱。有些时候和朋友们一起吃饭，会说起一月份时大家是如何 <code>逃离</code> 武汉的，在家隔离又多了哪些事情，我们活着是多么的不容易。虽然人类已经可以生产 5 纳米的芯片了，但是就如同我们对这个宇宙的认知一样，几百亿光年外任我们看，可太阳系内有什么我们都不知道，甚至在地球上还有很多我们未知的东西。</p><h1 id="计划失误"><a href="#计划失误" class="headerlink" title="计划失误"></a>计划失误</h1><p>2020 年我的计划几乎没有一件事是完成的，我计划应该一整年掌握 <code>TypeScript</code> 和 <code>web</code> 开发，并开发自己的blog系统，但是方案被我推到重来了三次，我就没耐心继续开发了，只完成了基本的 <code>md</code> 文件编译和服务器渲染就暂停了。计划阅读 <code>《1984》</code> 、 <code>《TensorFlow》</code> 和 <code>《TypeScript实战》</code> ，然而只有 <code>《TypeScript实战》</code>阅读完了，剩余两本书我则是只看了一丢丢，看来只能放到 2021 年读完了。</p><h1 id="她"><a href="#她" class="headerlink" title="她"></a>她</h1><p>在 <code>2019Review</code> 的文章里，我提到了我遇到了生命中的那个她，而 2020 年，我和她 <code>结婚</code> 啦。</p><p>在家隔离的日子里，有她陪伴着我，虽然老家的人都挺敌视从武汉回来的我，但是大门一关我谁也看不到，眼不见心不烦，在家一块搓麻将挺好的，还一起练 (zao) 习 (ta)了厨艺，朋友圈做饭比赛第一名。</p><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><p>虽然我读书拉后了，但是我的英语 <code>坚持</code> 了下来，我使用多邻国进行英语和日语的学习，已经坚持快6个月了，需要继续加油努力，争取早日把学校里拉下的英语 <code>补</code> 回来。</p><img src="/2021/02/26/2020review/Untitled.png" class="lazy" data-srcset="/2021/02/26/2020review/Untitled.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="2020review&#x2F;Untitled.png"><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>2020 年最大的收益可能是创建了 <code>deepin-git</code> 的仓库，提供了 <code>dde</code> 所有组件在 <code>arch</code> 上的git版，并且还成功申请到了 <code>archlinuxcn</code> 的贡献者。</p><h1 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h1><p>2020 年一共水了18篇文章。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">12</span>-<span class="number">23</span>   ccls</span><br><span class="line"><span class="number">11</span>-<span class="number">17</span>   Qt多线程</span><br><span class="line"><span class="number">09</span>-<span class="number">17</span>   deepin-wine中文乱码</span><br><span class="line"><span class="number">09</span>-<span class="number">08</span>   使用rEFInd来安全启动系统</span><br><span class="line"><span class="number">09</span>-<span class="number">06</span>   deepin git version</span><br><span class="line"><span class="number">09</span>-<span class="number">03</span>   使用VSCode远程开发DDE</span><br><span class="line"><span class="number">08</span>-<span class="number">06</span>   在ArchLinux上开发startdde</span><br><span class="line"><span class="number">07</span>-<span class="number">27</span>   use github action to check dde-launcher</span><br><span class="line"><span class="number">07</span>-<span class="number">21</span>   使用perf工具分析程序性能</span><br><span class="line"><span class="number">06</span>-<span class="number">16</span>   CTest &amp; QTest/GTest</span><br><span class="line"><span class="number">06</span>-<span class="number">15</span>   CPP项目的一些坑</span><br><span class="line"><span class="number">06</span>-<span class="number">15</span>   使用inquirer提供交互式git commit</span><br><span class="line"><span class="number">06</span>-<span class="number">01</span>   vue-router路由复用后页面没有刷新</span><br><span class="line"><span class="number">05</span>-<span class="number">31</span>   vue3升级遇到的坑</span><br><span class="line"><span class="number">02</span>-<span class="number">01</span>   JavaScript建造者模式</span><br><span class="line"><span class="number">01</span>-<span class="number">31</span>   浅谈Javascript构造器模式</span><br><span class="line"><span class="number">01</span>-<span class="number">01</span>   <span class="number">2019</span> Review</span><br><span class="line"><span class="number">01</span>-<span class="number">01</span>   使用伪元素创建一个圆点</span><br></pre></td></tr></table></figure><p>研究了 <code>vscode</code> 的插件，开发了一个 <code>qmake</code> 的插件原型，可以打开 <code>dtk</code> 等 <code>qt pro</code> 的项目，利用 <code>bear</code> 拦截 <code>make</code> 的编译信息，生成 <code>ccls</code> 需要的数据库，这样就可以为项目提供自动补全和语法检查等功能了。</p><p>写了一些关于远程开发的文章，也是利用 <code>vscode</code> 的远程功能，不得不说 <code>vscode</code> 真的可以说是宇宙第一编辑器了，让老牌的 <code>vim</code> 和 <code>emacs</code> 知道了什么叫易用性的力量。</p><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>2021 年，不能松懈，今年要继续努力学习，努力提升自己。</p><p>在 2021 年里，我将会负责 <code>deepin</code> 的社区，由于前两年公司需要快速扩张，导致忽略了社区，现在我们的首要任务就是恢复社区，并让社区良性的自由发展，社区是我们的根本。</p><p>挖了很多坑，今年争取都填一下。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>又搬家了，找了一个一室一厅，开启了二人的小日子，过了年以后把狗子也带来了，现在天天早上起来打狗，晚上回来打狗。</p><p>我又给 <code>肝疼3</code> 氪了一个月卡，这次只忘了一天没登录，不然 <code>30</code> 块大洋又要白花了。</p><p>祝大家幸福安康，新年快乐！(<em>^▽^</em>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2020&quot;&gt;&lt;a href=&quot;#2020&quot; class=&quot;headerlink&quot; title=&quot;2020&quot;&gt;&lt;/a&gt;2020&lt;/h1&gt;&lt;p&gt;拖了这么久才更新博客，想必大家都在 2020 年过的挺不好的，年初武汉的疫情打了全国一个措不及防，甚至已经一整年了，全球疫情</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ccls</title>
    <link href="https://blog.justforlxz.com/2020/12/23/ccls/"/>
    <id>https://blog.justforlxz.com/2020/12/23/ccls/</id>
    <published>2020-12-23T16:27:39.000Z</published>
    <updated>2021-03-04T07:40:49.293Z</updated>
    
    <content type="html"><![CDATA[<p>LSP(Language Server Protocol) 语言服务协议，此协议定义了在编辑器或IDE与语言服务器之间使用的协议，该语言服务器提供了例如自动补全，转到定义，查找所有引用等的功能；语言服务器索引格式的目标是支持在开发工具中进行丰富的代码导航或者一个无需本地源码副本的WebUI。</p><p>而ccls就是为c/c++开发的一个的lsp服务，可以为vim、emacs和vscode等工具提供自动补全，定义跳转等功能。</p><p>根据本文的指导，你可以将vim配置成一个不错的c++开发工具。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>由于公司部分项目并不是CMake开发的，所以vscode无法完成胜任开发工作，所以我开始使用vim。系统我使用的是ArchLinux,我会尽量使用仓库中的包，而不是通过pip等工具安装组件。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装neovim、ccls和bear,bear目前只在archlinuxcn仓库，需要注意。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S neovim ccls bear python node</span><br></pre></td></tr></table></figure><p>下载SpaceVim，由于我使用的是neovim,所以下载配置时选择了neovim.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -sLf https:&#x2F;&#x2F;spacevim.org&#x2F;cn&#x2F;install.sh | bash -s -- --install neovim</span><br></pre></td></tr></table></figure><p>创建自己的配置文件目录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir ~&#x2F;.SpaceVim.d&#x2F;</span><br></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>首先要先创建基本的SpaceVim配置文件，配置文件参考了<a href="https://github.com/Martins3/My-Linux-config">https://github.com/Martins3/My-Linux-config</a>。</p><p>整个配置都在~/.SpaceVim.d目录下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.SpaceVim.d</span><br><span class="line">├── autoload</span><br><span class="line">│   └── myspacevim.vim</span><br><span class="line">├── coc-settings.json</span><br><span class="line">├── init.toml</span><br><span class="line">└── plugin</span><br><span class="line">    ├── coc.nvim</span><br><span class="line">    └── defx.nvim</span><br><span class="line">2 directories, 5 files</span><br></pre></td></tr></table></figure><p>在.SpaceVim.d目录下创建init.toml</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 所有的 SpaceVim 选项都列在 [options] 之下</span><br><span class="line">[options]</span><br><span class="line">    # 设置 SpaceVim 主题及背景，默认的主题是 gruvbox，如果你需要使用更</span><br><span class="line">    # 多的主题，你可以载入 colorscheme 模块</span><br><span class="line">    colorscheme &#x3D; &quot;gruvbox&quot;</span><br><span class="line">    # 背景可以取值 &quot;dark&quot; 或 &quot;light&quot;</span><br><span class="line">    colorscheme_bg &#x3D; &quot;dark&quot;</span><br><span class="line">    # 启用&#x2F;禁用终端真色，在目前大多数终端下都是支持真色的，当然也有</span><br><span class="line">    # 一小部分终端不支持真色，如果你的 SpaceVim 颜色看上去比较怪异</span><br><span class="line">    # 可以禁用终端真色，将下面的值设为 false</span><br><span class="line">    enable_guicolors &#x3D; true</span><br><span class="line">    # 设置状态栏上分割符号形状，如果字体安装失败，可以将值设为 &quot;nil&quot; 以</span><br><span class="line">    # 禁用分割符号，默认为箭头 &quot;arrow&quot;</span><br><span class="line">    statusline_separator &#x3D; &quot;nil&quot;</span><br><span class="line">    statusline_iseparator &#x3D; &quot;bar&quot;</span><br><span class="line">    # 设置顶部标签列表序号类型，有以下五种类型，分别是 0 - 4</span><br><span class="line">    # 0: 1 ➛ ➊</span><br><span class="line">    # 1: 1 ➛ ➀</span><br><span class="line">    # 2: 1 ➛ ⓵</span><br><span class="line">    # 3: 1 ➛ ¹</span><br><span class="line">    # 4: 1 ➛ 1</span><br><span class="line">    buffer_index_type &#x3D; 4</span><br><span class="line">    # 显示&#x2F;隐藏顶部标签栏上的文件类型图标，这一图标需要安装 nerd fonts，</span><br><span class="line">    # 如果未能成功安装这一字体，可以隐藏图标</span><br><span class="line">    enable_tabline_filetype_icon &#x3D; true</span><br><span class="line">    # 是否在状态栏上显示当前模式，默认情况下，不显示 Normal&#x2F;Insert 等</span><br><span class="line">    # 字样，只以颜色区分当前模式</span><br><span class="line">    enable_statusline_mode &#x3D; false</span><br><span class="line">    filemanager &#x3D; &quot;defx&quot;</span><br><span class="line">    autocomplete_method &#x3D; &quot;coc&quot;</span><br><span class="line">    bootstrap_before &#x3D; &quot;myspacevim#before&quot;</span><br><span class="line">    bootstrap_after &#x3D; &quot;myspacevim#after&quot;</span><br><span class="line"># SpaceVim 模块设置，主要包括启用&#x2F;禁用模块</span><br><span class="line"># 计算器 日历 书签等小工具</span><br><span class="line">[[layers]]</span><br><span class="line">  name &#x3D; &#39;tools&#39;</span><br><span class="line">[[layers]]</span><br><span class="line">  name &#x3D; &quot;checkers&quot;</span><br><span class="line">  enable &#x3D; false</span><br><span class="line"># 版本控制</span><br><span class="line">[[layers]]</span><br><span class="line">  name &#x3D; &quot;VersionControl&quot;</span><br><span class="line">  enable-gtm-status &#x3D; true</span><br><span class="line">[[layers]]</span><br><span class="line">  name &#x3D; &quot;git&quot;</span><br><span class="line">  git-plugin &#x3D; &quot;fugitive&quot;</span><br><span class="line">[[layers]]</span><br><span class="line">  name &#x3D; &quot;fzf&quot;</span><br><span class="line"># coc.nvim 核心配置，不要删除</span><br><span class="line">[[custom_plugins]]</span><br><span class="line">  name &#x3D; &#39;neoclide&#x2F;coc.nvim&#39;</span><br><span class="line">  merge &#x3D; 0</span><br><span class="line"># 主要用于快速搜索 文件, buffer 和 函数</span><br><span class="line">[[custom_plugins]]</span><br><span class="line">    name &#x3D; &quot;Yggdroot&#x2F;LeaderF&quot;</span><br><span class="line">    build &#x3D; &quot;.&#x2F;install.sh&quot;</span><br><span class="line"># 更加美观的 tagbar</span><br><span class="line">[[custom_plugins]]</span><br><span class="line">    name &#x3D; &#39;liuchengxu&#x2F;vista.vim&#39;</span><br><span class="line">[[custom_plugins]]</span><br><span class="line">    name &#x3D; &#39;junegunn&#x2F;fzf.vim&#39;</span><br><span class="line"># 更加方便的调节窗口的大小</span><br><span class="line">[[custom_plugins]]</span><br><span class="line">    name &#x3D; &#39;simeji&#x2F;winresizer&#39;</span><br><span class="line"># 基于lsp的高亮插件</span><br><span class="line">[[custom_plugins]]</span><br><span class="line">    name &#x3D; &#39;jackguo380&#x2F;vim-lsp-cxx-highlight&#39;</span><br><span class="line"># 从 http:&#x2F;&#x2F;cplusplus.com&#x2F; 和 http:&#x2F;&#x2F;cppreference.com&#x2F; 获取文档</span><br><span class="line">[[custom_plugins]]</span><br><span class="line">    name &#x3D; &#39;skywind3000&#x2F;vim-cppman&#39;</span><br><span class="line"># 利用 git blame 显示当前行的 commit message</span><br><span class="line">[[custom_plugins]]</span><br><span class="line">    name &#x3D; &#39;rhysd&#x2F;git-messenger.vim&#39;</span><br><span class="line">    lazy &#x3D;  1</span><br><span class="line">    on_cmd &#x3D; &#39;GitMessenger&#39;</span><br><span class="line"># 以悬浮窗口的形式打开终端</span><br><span class="line">[[custom_plugins]]</span><br><span class="line">    name &#x3D; &#39;voldikss&#x2F;vim-floaterm&#39;</span><br><span class="line"># 显示搜索的标号</span><br><span class="line">[[custom_plugins]]</span><br><span class="line">    name &#x3D; &#39;google&#x2F;vim-searchindex.git&#39;</span><br><span class="line">[[custom_plugins]]</span><br><span class="line">  name &#x3D; &#39;kenn7&#x2F;vim-arsync&#39;</span><br><span class="line">[[custom_plugins]]</span><br><span class="line">  name &#x3D; &#39;fatih&#x2F;vim-go&#39;</span><br><span class="line"># 禁用 shell 模块，禁用模块时，需要加入 enable &#x3D; false</span><br><span class="line">[[layers]]</span><br><span class="line">    name &#x3D; &quot;shell&quot;</span><br><span class="line">    enable &#x3D; false</span><br><span class="line"># 添加自定义插件</span><br><span class="line">[[custom_plugins]]</span><br><span class="line">    repo &#x3D; &quot;lilydjwg&#x2F;colorizer&quot;</span><br><span class="line">    merged &#x3D; false</span><br><span class="line">[[layers]]</span><br><span class="line">  name &#x3D; &quot;format&quot;</span><br></pre></td></tr></table></figure><p>创建plugin目录，新建两个文件。<br>coc.nvim</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot; coc.nvim 的配置, 来自于 https:&#x2F;&#x2F;github.com&#x2F;neoclide&#x2F;coc.nvim</span><br><span class="line">&quot; Use &lt;c-space&gt; for trigger completion.</span><br><span class="line">inoremap &lt;silent&gt;&lt;expr&gt; &lt;c-space&gt; coc#refresh()</span><br><span class="line">set hidden</span><br><span class="line">&quot; Some servers have issues with backup files, see #649</span><br><span class="line">set nobackup</span><br><span class="line">set nowritebackup</span><br><span class="line">&quot; 使用 Microsoft Python Language Server 不然 coc.nvim 会警告</span><br><span class="line">call coc#config(&quot;python.jediEnabled&quot;, v:false)</span><br><span class="line">call coc#config(&quot;smartf.wordJump&quot;, v:false)</span><br><span class="line">call coc#config(&quot;smartf.jumpOnTrigger&quot;, v:false)</span><br><span class="line">&quot; https:&#x2F;&#x2F;rust-analyzer.github.io&#x2F;manual.html#rust-analyzer-language-server-binary</span><br><span class="line">call coc#config(&quot;rust-analyzer.serverPath&quot;, &quot;~&#x2F;.cargo&#x2F;bin&#x2F;rust-analyzer&quot;)</span><br><span class="line">call coc#config(&#39;coc.preferences&#39;, &#123;</span><br><span class="line">\ &quot;autoTrigger&quot;: &quot;always&quot;,</span><br><span class="line">\ &quot;maxCompleteItemCount&quot;: 10,</span><br><span class="line">\ &quot;codeLens.enable&quot;: 1,</span><br><span class="line">\ &quot;diagnostic.virtualText&quot;: 1,</span><br><span class="line">\&#125;)</span><br><span class="line"></span><br><span class="line">&quot; coc.nvim 插件，用于支持 python java 等语言</span><br><span class="line">let s:coc_extensions &#x3D; [</span><br><span class="line">\ &#39;coc-python&#39;,</span><br><span class="line">\ &#39;coc-java&#39;,</span><br><span class="line">\ &#39;coc-json&#39;,</span><br><span class="line">      \ &#39;coc-css&#39;,</span><br><span class="line">      \ &#39;coc-html&#39;,</span><br><span class="line">      \ &#39;coc-word&#39;,</span><br><span class="line">      \ &#39;coc-cmake&#39;,</span><br><span class="line">      \ &#39;coc-dictionary&#39;,</span><br><span class="line">      \ &#39;coc-rust-analyzer&#39;,</span><br><span class="line">      \ &#39;coc-vimlsp&#39;,</span><br><span class="line">      \ &#39;coc-ci&#39;,</span><br><span class="line">      \ &#39;coc-snippets&#39;,</span><br><span class="line">      \ &#39;coc-vimtex&#39;,</span><br><span class="line">      \ &#39;coc-smartf&#39;,</span><br><span class="line">\]</span><br><span class="line">for extension in s:coc_extensions</span><br><span class="line">call coc#add_extension(extension)</span><br><span class="line">endfor</span><br><span class="line">inoremap &lt;silent&gt;&lt;expr&gt; &lt;TAB&gt;</span><br><span class="line">      \ pumvisible() ? &quot;\&lt;C-n&gt;&quot; :</span><br><span class="line">      \ &lt;SID&gt;check_back_space() ? &quot;\&lt;TAB&gt;&quot; :</span><br><span class="line">      \ coc#refresh()</span><br><span class="line">inoremap &lt;expr&gt;&lt;S-TAB&gt; pumvisible() ? &quot;\&lt;C-p&gt;&quot; : &quot;\&lt;C-h&gt;&quot;</span><br><span class="line">function! s:check_back_space() abort</span><br><span class="line">  let col &#x3D; col(&#39;.&#39;) - 1</span><br><span class="line">  return !col || getline(&#39;.&#39;)[col - 1]  &#x3D;~# &#39;\s&#39;</span><br><span class="line">endfunction</span><br><span class="line">&quot; 方便在中文中间使用 w 和 b 移动</span><br><span class="line">nmap &lt;silent&gt; w &lt;Plug&gt;(coc-ci-w)</span><br><span class="line">nmap &lt;silent&gt; b &lt;Plug&gt;(coc-ci-b)</span><br><span class="line"></span><br><span class="line">&quot; Use &lt;cr&gt; for confirm completion, &#96;&lt;C-g&gt;u&#96; means break undo chain at current position.</span><br><span class="line">&quot; Coc only does snippet and additional edit on confirm.</span><br><span class="line">inoremap &lt;expr&gt; &lt;cr&gt; pumvisible() ? &quot;\&lt;C-y&gt;&quot; : &quot;\&lt;C-g&gt;u\&lt;CR&gt;&quot;</span><br><span class="line">&quot; Remap keys for gotos</span><br><span class="line">nmap &lt;silent&gt; gd &lt;Plug&gt;(coc-definition)</span><br><span class="line">nmap &lt;silent&gt; gy &lt;Plug&gt;(coc-type-definition)</span><br><span class="line">nmap &lt;silent&gt; gi &lt;Plug&gt;(coc-implementation)</span><br><span class="line">nmap &lt;silent&gt; gr &lt;Plug&gt;(coc-references)</span><br><span class="line">&quot; Use K for show documentation in preview window</span><br><span class="line">nnoremap &lt;silent&gt; K :call &lt;SID&gt;show_documentation()&lt;CR&gt;</span><br><span class="line">function! s:show_documentation()</span><br><span class="line">  if &amp;filetype &#x3D;&#x3D; &#39;vim&#39;</span><br><span class="line">    execute &#39;h &#39;.expand(&#39;&lt;cword&gt;&#39;)</span><br><span class="line">  else</span><br><span class="line">    call CocAction(&#39;doHover&#39;)</span><br><span class="line">  endif</span><br><span class="line">endfunction</span><br><span class="line">&quot; Highlight symbol under cursor on CursorHold</span><br><span class="line">set updatetime&#x3D;300</span><br><span class="line">autocmd CursorHold * silent call CocActionAsync(&#39;highlight&#39;)</span><br><span class="line">autocmd CursorHoldI * sil call CocActionAsync(&#39;showSignatureHelp&#39;)</span><br><span class="line">&quot; Remap for rename current word</span><br><span class="line">nmap &lt;leader&gt;rn &lt;Plug&gt;(coc-rename)</span><br><span class="line">&quot; 注释掉，一般使用 &#96;Space&#96; &#96;r&#96; &#96;f&#96; 直接格式化整个文件</span><br><span class="line">&quot; Remap for format selected region</span><br><span class="line">&quot; vmap &lt;leader&gt;f  &lt;Plug&gt;(coc-format-selected)</span><br><span class="line">&quot; nmap &lt;leader&gt;f  &lt;Plug&gt;(coc-format-selected)</span><br><span class="line">augroup mygroup</span><br><span class="line">  autocmd!</span><br><span class="line">  &quot; Setup formatexpr specified filetype(s).</span><br><span class="line">  autocmd FileType typescript,json setl formatexpr&#x3D;CocAction(&#39;formatSelected&#39;)</span><br><span class="line">  &quot; Update signature help on jump placeholder</span><br><span class="line">  autocmd User CocJumpPlaceholder call CocActionAsync(&#39;showSignatureHelp&#39;)</span><br><span class="line">augroup end</span><br><span class="line">&quot; Remap for do codeAction of selected region, ex: &#96;&lt;leader&gt;aap&#96; for current paragraph</span><br><span class="line">vmap &lt;leader&gt;a  &lt;Plug&gt;(coc-codeaction-selected)</span><br><span class="line">nmap &lt;leader&gt;a  &lt;Plug&gt;(coc-codeaction-selected)</span><br><span class="line">&quot; Remap for do codeAction of current line</span><br><span class="line">nmap &lt;leader&gt;ac  &lt;Plug&gt;(coc-codeaction)</span><br><span class="line">&quot; Fix autofix problem of current line</span><br><span class="line">nmap &lt;leader&gt;qf  &lt;Plug&gt;(coc-fix-current)</span><br><span class="line">&quot; Use &#96;:Format&#96; for format current buffer</span><br><span class="line">&quot; command! -nargs&#x3D;0 Format :call CocAction(&#39;format&#39;)</span><br><span class="line">call SpaceVim#custom#SPC(&#39;nnoremap&#39;, [&#39;r&#39;, &#39;f&#39;], &quot;call CocAction(&#39;format&#39;)&quot;, &#39;format file with coc.nvim&#39;, 1)</span><br><span class="line">&quot; Use &#96;:Fold&#96; for fold current buffer</span><br><span class="line">command! -nargs&#x3D;? Fold :call     CocAction(&#39;fold&#39;, &lt;f-args&gt;)</span><br><span class="line">&quot; auto import for go on save</span><br><span class="line">autocmd BufWritePre *.go :call CocAction(&#39;runCommand&#39;, &#39;editor.action.organizeImport&#39;)</span><br><span class="line">&quot; 这个和 SpaceVim 的 statusline&#x2F;tabline 冲突了</span><br><span class="line">&quot; Add diagnostic info for https:&#x2F;&#x2F;github.com&#x2F;itchyny&#x2F;lightline.vim</span><br><span class="line">&quot; let g:lightline &#x3D; &#123;</span><br><span class="line">&quot;       \ &#39;colorscheme&#39;: &#39;wombat&#39;,</span><br><span class="line">&quot;       \ &#39;active&#39;: &#123;</span><br><span class="line">&quot;       \   &#39;left&#39;: [ [ &#39;mode&#39;, &#39;paste&#39; ],</span><br><span class="line">&quot;       \             [ &#39;cocstatus&#39;, &#39;readonly&#39;, &#39;filename&#39;, &#39;modified&#39; ] ]</span><br><span class="line">&quot;       \ &#125;,</span><br><span class="line">&quot;       \ &#39;component_function&#39;: &#123;</span><br><span class="line">&quot;       \   &#39;cocstatus&#39;: &#39;coc#status&#39;</span><br><span class="line">&quot;       \ &#125;,</span><br><span class="line">&quot;       \ &#125;</span><br><span class="line"></span><br><span class="line">&quot; Using CocList</span><br><span class="line">&quot; Show all diagnostics</span><br><span class="line">nnoremap &lt;silent&gt; &lt;leader&gt;d  :&lt;C-u&gt;CocList diagnostics&lt;cr&gt;</span><br><span class="line"></span><br><span class="line">&quot; 下面是 ccls 提供的 LSP Extension</span><br><span class="line">&quot; https:&#x2F;&#x2F;github.com&#x2F;MaskRay&#x2F;ccls&#x2F;wiki&#x2F;coc.nvim</span><br><span class="line">&quot; Manage extensions</span><br><span class="line">&quot; nnoremap &lt;silent&gt; &lt;space&gt;e  :&lt;C-u&gt;CocList extensions&lt;cr&gt;</span><br><span class="line">&quot; Show commands</span><br><span class="line">&quot; nnoremap &lt;silent&gt; &lt;space&gt;c  :&lt;C-u&gt;CocList commands&lt;cr&gt;</span><br><span class="line">&quot; Find symbol of current document</span><br><span class="line">&quot; nnoremap &lt;silent&gt; &lt;space&gt;o  :&lt;C-u&gt;CocList outline&lt;cr&gt;</span><br><span class="line">&quot; Search workspace symbols</span><br><span class="line">&quot; nnoremap &lt;silent&gt; &lt;space&gt;s  :&lt;C-u&gt;CocList -I symbols&lt;cr&gt;</span><br><span class="line">&quot; Do default action for next item.</span><br><span class="line">&quot; nnoremap &lt;silent&gt; &lt;space&gt;j  :&lt;C-u&gt;CocNext&lt;CR&gt;</span><br><span class="line">&quot; Do default action for previous item.</span><br><span class="line">&quot; nnoremap &lt;silent&gt; &lt;space&gt;k  :&lt;C-u&gt;CocPrev&lt;CR&gt;</span><br><span class="line">&quot; Resume latest coc list</span><br><span class="line">&quot; nnoremap &lt;silent&gt; &lt;space&gt;p  :&lt;C-u&gt;CocListResume&lt;CR&gt;</span><br><span class="line">nn &lt;silent&gt; xl :call CocLocations(&#39;ccls&#39;,&#39;$ccls&#x2F;navigate&#39;,&#123;&#39;direction&#39;:&#39;D&#39;&#125;)&lt;cr&gt;</span><br><span class="line">nn &lt;silent&gt; xk :call CocLocations(&#39;ccls&#39;,&#39;$ccls&#x2F;navigate&#39;,&#123;&#39;direction&#39;:&#39;L&#39;&#125;)&lt;cr&gt;</span><br><span class="line">nn &lt;silent&gt; xj :call CocLocations(&#39;ccls&#39;,&#39;$ccls&#x2F;navigate&#39;,&#123;&#39;direction&#39;:&#39;R&#39;&#125;)&lt;cr&gt;</span><br><span class="line">nn &lt;silent&gt; xh :call CocLocations(&#39;ccls&#39;,&#39;$ccls&#x2F;navigate&#39;,&#123;&#39;direction&#39;:&#39;U&#39;&#125;)&lt;cr&gt;</span><br><span class="line">noremap x &lt;Nop&gt;</span><br><span class="line">nn &lt;silent&gt; xb :call CocLocations(&#39;ccls&#39;,&#39;$ccls&#x2F;inheritance&#39;)&lt;cr&gt;</span><br><span class="line">&quot; bases of up to 3 levels</span><br><span class="line">nn &lt;silent&gt; xb :call CocLocations(&#39;ccls&#39;,&#39;$ccls&#x2F;inheritance&#39;,&#123;&#39;levels&#39;:3&#125;)&lt;cr&gt;</span><br><span class="line">&quot; derived</span><br><span class="line">nn &lt;silent&gt; xd :call CocLocations(&#39;ccls&#39;,&#39;$ccls&#x2F;inheritance&#39;,&#123;&#39;derived&#39;:v:true&#125;)&lt;cr&gt;</span><br><span class="line">&quot; derived of up to 3 levels</span><br><span class="line">nn &lt;silent&gt; xD :call CocLocations(&#39;ccls&#39;,&#39;$ccls&#x2F;inheritance&#39;,&#123;&#39;derived&#39;:v:true,&#39;levels&#39;:3&#125;)&lt;cr&gt;</span><br><span class="line">&quot; caller</span><br><span class="line">nn &lt;silent&gt; xc :call CocLocations(&#39;ccls&#39;,&#39;$ccls&#x2F;call&#39;)&lt;cr&gt;</span><br><span class="line">&quot; callee</span><br><span class="line">nn &lt;silent&gt; xC :call CocLocations(&#39;ccls&#39;,&#39;$ccls&#x2F;call&#39;,&#123;&#39;callee&#39;:v:true&#125;)&lt;cr&gt;</span><br><span class="line">&quot; $ccls&#x2F;member</span><br><span class="line">&quot; member variables &#x2F; variables in a namespace</span><br><span class="line">nn &lt;silent&gt; xm :call CocLocations(&#39;ccls&#39;,&#39;$ccls&#x2F;member&#39;)&lt;cr&gt;</span><br><span class="line">&quot; member functions &#x2F; functions in a namespace</span><br><span class="line">nn &lt;silent&gt; xf :call CocLocations(&#39;ccls&#39;,&#39;$ccls&#x2F;member&#39;,&#123;&#39;kind&#39;:3&#125;)&lt;cr&gt;</span><br><span class="line">&quot; nested classes &#x2F; types in a namespace</span><br><span class="line">nn &lt;silent&gt; xs :call CocLocations(&#39;ccls&#39;,&#39;$ccls&#x2F;member&#39;,&#123;&#39;kind&#39;:2&#125;)&lt;cr&gt;</span><br><span class="line">nmap &lt;silent&gt; xt &lt;Plug&gt;(coc-type-definition)&lt;cr&gt;</span><br><span class="line">nn &lt;silent&gt; xv :call CocLocations(&#39;ccls&#39;,&#39;$ccls&#x2F;vars&#39;)&lt;cr&gt;</span><br><span class="line">nn &lt;silent&gt; xV :call CocLocations(&#39;ccls&#39;,&#39;$ccls&#x2F;vars&#39;,&#123;&#39;kind&#39;:1&#125;)&lt;cr&gt;</span><br><span class="line">nn xx x</span><br></pre></td></tr></table></figure><p>defx.nvim</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot; defx 将会自动忽略如下的文件</span><br><span class="line">call defx#custom#option(&#39;_&#39;, &#123;</span><br><span class="line">    \ &#39;ignored_files&#39;: &quot;.*,*.class,*.out,*.o,*.bc,*.a,compile_commands.json,*.d,*.mod*,*.cmd,.tmp_versions&#x2F;,modules.order,Module.symvers,Mkfile.old,dkms.conf,*.ko,*.elf,*.img&quot;,</span><br><span class="line">    \ &#125;)</span><br></pre></td></tr></table></figure><p>创建autoload目录，新建myspacevim.vim</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func! myspacevim#before() abort</span><br><span class="line">    let g:coc_config_home &#x3D; &#39;~&#x2F;.SpaceVim.d&#x2F;&#39;</span><br><span class="line">    &quot; 焦点消失的时候自动保存</span><br><span class="line">    au FocusLost * :wa</span><br><span class="line">    au FocusGained,BufEnter * :checktime</span><br><span class="line">    &quot; 当文件被其他编辑器修改时，自动加载</span><br><span class="line">    set autowrite</span><br><span class="line">    set autoread</span><br><span class="line">    &quot; 设置按照syntax高亮进行折叠</span><br><span class="line">    set foldmethod&#x3D;syntax</span><br><span class="line">    set nofoldenable</span><br><span class="line">    &quot; 重新映射 leader 键</span><br><span class="line">    let g:mapleader &#x3D; &#39;,&#39;</span><br><span class="line">    &quot; 重新映射 window 键位</span><br><span class="line">    let g:spacevim_windows_leader &#x3D; &#39;c&#39;</span><br><span class="line">    call SpaceVim#custom#SPC(&#39;nnoremap&#39;, [&#39;s&#39;, &#39;f&#39;], &#39;Vista finder coc&#39;, &#39;search simbols&#39;, 1)</span><br><span class="line">    call SpaceVim#custom#SPC(&#39;nnoremap&#39;, [&#39;s&#39;, &#39;F&#39;], &#39;LeaderfFunction!&#39;, &#39;list functions&#39;, 1)</span><br><span class="line">    let g:Lf_ShortcutF &#x3D; &quot;&lt;leader&gt;s&quot;</span><br><span class="line">    &quot; 让 leaderf 可以搜索 git 的 submodule，否则是自动忽略的</span><br><span class="line">    let g:Lf_RecurseSubmodules &#x3D; 1</span><br><span class="line">    let g:spacevim_snippet_engine &#x3D; &#39;ultisnips&#39;</span><br><span class="line">    let g:table_mode_corner&#x3D;&#39;|&#39;</span><br><span class="line">    &quot; 调节 window 大小</span><br><span class="line">    let g:winresizer_start_key &#x3D; &#39;&lt;space&gt;wa&#39;</span><br><span class="line">    &quot; If you cancel and quit window resize mode by &#96;q&#96; (keycode 113)</span><br><span class="line">    let g:winresizer_keycode_cancel &#x3D; 113</span><br><span class="line">    &quot; 让file tree 显示文件图标，需要 terminal 安装 nerd font</span><br><span class="line">    let g:spacevim_enable_vimfiler_filetypeicon &#x3D; 1</span><br><span class="line">    &quot; 让 filetree 显示 git 的状态，会变得很卡，所以关掉</span><br><span class="line">    let g:spacevim_enable_vimfiler_gitstatus &#x3D; 1</span><br><span class="line">    &quot; 默认 markdown preview 在切换到其他的 buffer 或者 vim</span><br><span class="line">    &quot; 失去焦点的时候会自动关闭 preview，让</span><br><span class="line">    let g:mkdp_auto_close &#x3D; 0</span><br><span class="line">    &quot; 书签选中之后自动关闭 quickfix window</span><br><span class="line">    let g:bookmark_auto_close &#x3D; 1</span><br><span class="line">    &quot; vim-lsp-cxx-highlight 和这个选项存在冲突</span><br><span class="line">    &quot; let g:rainbow_active &#x3D; 1</span><br><span class="line">    &quot; ctrl + ] 查询 cppman</span><br><span class="line">    &quot; 如果想让该快捷键自动查询 man，将Cppman 替换为 Cppman!</span><br><span class="line">    autocmd FileType c,cpp noremap &lt;C-]&gt; &lt;Esc&gt;:execute &quot;Cppman &quot; . expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;</span><br><span class="line">    &quot; 让光标自动进入到popup window 中间</span><br><span class="line">    let g:git_messenger_always_into_popup &#x3D; v:true</span><br><span class="line">    &quot; 设置映射规则，和 spacevim 保持一致</span><br><span class="line">    call SpaceVim#custom#SPC(&#39;nnoremap&#39;, [&#39;g&#39;, &#39;m&#39;], &#39;GitMessenger&#39;, &#39;show commit message in popup window&#39;, 1)</span><br><span class="line">    call SpaceVim#custom#SPC(&#39;nnoremap&#39;, [&#39;g&#39;, &#39;l&#39;], &#39;FloatermNew lazygit&#39;, &#39;open lazygit in floaterm&#39;, 1)</span><br><span class="line">    &quot; 设置默认的pdf阅览工具</span><br><span class="line">    let g:vimtex_view_method &#x3D; &#39;zathura&#39;</span><br><span class="line">    &quot; 关闭所有隐藏设置</span><br><span class="line">let g:tex_conceal &#x3D; &quot;&quot;</span><br><span class="line">    &quot; 实现一键运行各种文件，适合非交互式的，少量的代码，比如 leetcode</span><br><span class="line">    func! QuickRun()</span><br><span class="line">        exec &quot;w&quot;</span><br><span class="line">        let ext &#x3D; expand(&quot;%:e&quot;)</span><br><span class="line">        let file &#x3D; expand(&quot;%&quot;)</span><br><span class="line">        if ext &#x3D;&#x3D;# &quot;sh&quot;</span><br><span class="line">            exec &quot;!sh %&quot;</span><br><span class="line">        elseif ext &#x3D;&#x3D;# &quot;cpp&quot;</span><br><span class="line">            exec &quot;!clang++ % -Wall -O3 -g -std&#x3D;c++17 -o %&lt;.out &amp;&amp; .&#x2F;%&lt;.out&quot;</span><br><span class="line">        elseif ext &#x3D;&#x3D;# &quot;c&quot;</span><br><span class="line">            exec &quot;!clang % -Wall -g -std&#x3D;c11 -o %&lt;.out &amp;&amp; .&#x2F;%&lt;.out&quot;</span><br><span class="line">        elseif ext &#x3D;&#x3D;# &quot;java&quot;</span><br><span class="line">            let classPath &#x3D; expand(&#39;%:h&#39;)</span><br><span class="line">            let className &#x3D; expand(&#39;%:p:t:r&#39;)</span><br><span class="line">            &quot; echo classPath</span><br><span class="line">            &quot; echo className</span><br><span class="line">            exec &quot;!javac %&quot;</span><br><span class="line">            exec &quot;!java -classpath &quot; . classPath . &quot; &quot; . className</span><br><span class="line">        elseif ext &#x3D;&#x3D;# &quot;go&quot;</span><br><span class="line">            exec &quot;!go run %&quot;</span><br><span class="line">        elseif ext &#x3D;&#x3D;# &quot;js&quot;</span><br><span class="line">            exec &quot;!node %&quot;</span><br><span class="line">        elseif ext &#x3D;&#x3D;# &quot;bin&quot;</span><br><span class="line">            exec &quot;!readelf -h %&quot;</span><br><span class="line">        elseif ext &#x3D;&#x3D;# &quot;py&quot;</span><br><span class="line">            exec &quot;!python3 %&quot;</span><br><span class="line">        elseif ext &#x3D;&#x3D;# &quot;vim&quot;</span><br><span class="line">            exec &quot;so %&quot;</span><br><span class="line">        elseif ext &#x3D;&#x3D;# &quot;html&quot;</span><br><span class="line">            exec &quot;!google-chrome-stable %&quot;</span><br><span class="line">        elseif ext &#x3D;&#x3D;# &quot;rs&quot;</span><br><span class="line">            call CargoRun()</span><br><span class="line">        else</span><br><span class="line">            echo &quot;Check file type !&quot;</span><br><span class="line">        endif</span><br><span class="line">        echo &#39;done&#39;</span><br><span class="line">    endf</span><br><span class="line">    &quot; 一键运行 rust 工程，不断向上查找直到遇到 Cargo.toml，然后执行 cargo run</span><br><span class="line">    func! CargoRun()</span><br><span class="line">      let cargo_run_path &#x3D; fnamemodify(resolve(expand(&#39;%:p&#39;)), &#39;:h&#39;)</span><br><span class="line">      while cargo_run_path !&#x3D; &quot;&#x2F;&quot;</span><br><span class="line">        if filereadable(cargo_run_path . &quot;&#x2F;Cargo.toml&quot;)</span><br><span class="line">            echo cargo_run_path</span><br><span class="line">            exec &quot;cd &quot; . cargo_run_path</span><br><span class="line">            exec &quot;!cargo run&quot;</span><br><span class="line">            exec &quot;cd -&quot;</span><br><span class="line">            return</span><br><span class="line">        endif</span><br><span class="line">       let cargo_run_path &#x3D; fnamemodify(cargo_run_path, &#39;:h&#39;)</span><br><span class="line">      endwhile</span><br><span class="line">      echo &quot;Cargo.toml not found !&quot;</span><br><span class="line">    endf</span><br><span class="line">endf</span><br><span class="line">func! myspacevim#after() abort</span><br><span class="line">    &quot; &lt;F3&gt; 打开文件树</span><br><span class="line">    nnoremap  &lt;F4&gt;  :call QuickRun()&lt;CR&gt;</span><br><span class="line">    &quot; &lt;F5&gt; floaterm toggle</span><br><span class="line">    &quot; &lt;F7&gt; 打开历史记录</span><br><span class="line">    tnoremap  &lt;Esc&gt;  &lt;C-\&gt;&lt;C-n&gt;</span><br><span class="line">    map &lt;Tab&gt; :wincmd w&lt;CR&gt;</span><br><span class="line">    &quot; press &lt;esc&gt; to cancel.</span><br><span class="line">    nmap f &lt;Plug&gt;(coc-smartf-forward)</span><br><span class="line">    nmap F &lt;Plug&gt;(coc-smartf-backward)</span><br><span class="line">    nmap ; &lt;Plug&gt;(coc-smartf-repeat)</span><br><span class="line">    nmap , &lt;Plug&gt;(coc-smartf-repeat-opposite)</span><br><span class="line">    augroup Smartf</span><br><span class="line">      autocmd User SmartfEnter :hi Conceal ctermfg&#x3D;220 guifg&#x3D;pink</span><br><span class="line">      autocmd User SmartfLeave :hi Conceal ctermfg&#x3D;239 guifg&#x3D;#504945</span><br><span class="line">    augroup end</span><br><span class="line">    inoremap   &lt;silent&gt;   &lt;C-n&gt;     :FloatermNew&lt;CR&gt;</span><br><span class="line">    nnoremap   &lt;silent&gt;   &lt;C-n&gt;    :FloatermNew&lt;CR&gt;</span><br><span class="line">    tnoremap   &lt;silent&gt;   &lt;C-n&gt;    &lt;C-\&gt;&lt;C-n&gt;:FloatermNew&lt;CR&gt;</span><br><span class="line">    inoremap   &lt;silent&gt;   &lt;C-h&gt;     :FloatermPrev&lt;CR&gt;</span><br><span class="line">    nnoremap   &lt;silent&gt;   &lt;C-h&gt;    :FloatermPrev&lt;CR&gt;</span><br><span class="line">    tnoremap   &lt;silent&gt;   &lt;C-h&gt;    &lt;C-\&gt;&lt;C-n&gt;:FloatermPrev&lt;CR&gt;</span><br><span class="line">    inoremap   &lt;silent&gt;   &lt;C-l&gt;     :FloatermNext&lt;CR&gt;</span><br><span class="line">    nnoremap   &lt;silent&gt;   &lt;C-l&gt;    :FloatermNext&lt;CR&gt;</span><br><span class="line">    tnoremap   &lt;silent&gt;   &lt;C-l&gt;    &lt;C-\&gt;&lt;C-n&gt;:FloatermNext&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">    &quot; 保证在插入模式&lt;F5&gt;可以 toggle floaterm</span><br><span class="line">    &quot; 来，提出一个自己的第一个 pull request !</span><br><span class="line">    inoremap  &lt;silent&gt;   &lt;F5&gt;   :FloatermToggle!&lt;CR&gt;</span><br><span class="line">    nnoremap  &lt;silent&gt;   &lt;F5&gt;   :FloatermToggle!&lt;CR&gt;</span><br><span class="line">    tnoremap  &lt;silent&gt;   &lt;F5&gt;   &lt;C-\&gt;&lt;C-n&gt;:FloatermToggle!&lt;CR&gt;</span><br><span class="line">    &quot; go highlight</span><br><span class="line">    &quot; https:&#x2F;&#x2F;github.com&#x2F;neoclide&#x2F;coc.nvim&#x2F;issues&#x2F;472</span><br><span class="line">    let g:go_list_type&#x3D;&quot;quickfix&quot;</span><br><span class="line">    let g:go_fmt_command&#x3D;&quot;goimports&quot;</span><br><span class="line">    let g:go_highlight_types&#x3D;1</span><br><span class="line">    let g:go_highlight_fields&#x3D;1</span><br><span class="line">    let g:go_highlight_functions&#x3D;1</span><br><span class="line">    let g:go_highlight_function_calls&#x3D;1</span><br><span class="line">    let g:go_fmt_fail_silently&#x3D;1</span><br><span class="line">endf</span><br></pre></td></tr></table></figure><p>创建coc的默认配置文件，原本coc的配置文件应该是在~/.SpaceVim下的，但是在autoload的配置文件中，设置了coc_config_home，修改为.SpaceVim.d下，方便控制。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;languageserver&quot;: &#123;</span><br><span class="line">&quot;ccls&quot;: &#123;</span><br><span class="line">&quot;command&quot;: &quot;ccls&quot;,</span><br><span class="line">&quot;filetypes&quot;: [&quot;c&quot;, &quot;cpp&quot;],</span><br><span class="line">&quot;rootPatterns&quot;: [&quot;compile_commands.json&quot;, &quot;.git&#x2F;&quot;],</span><br><span class="line">&quot;index&quot;: &#123;</span><br><span class="line">&quot;threads&quot;: 8</span><br><span class="line">&#125;,</span><br><span class="line">&quot;initializationOptions&quot;: &#123;</span><br><span class="line">&quot;cache&quot;: &#123;</span><br><span class="line">&quot;directory&quot;: &quot;build&#x2F;.ccls-cache&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;highlight&quot;: &#123;</span><br><span class="line">&quot;lsRanges&quot;: true</span><br><span class="line">&#125;,</span><br><span class="line">&quot;compilationDatabaseDirectory&quot;: &quot;build&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;client&quot;: &#123;</span><br><span class="line">&quot;snippetSupport&quot;: true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>启动nvim的时候，就会开始安装所有的插件，等带最终配置完成。</p><p>现在进去一个C++的项目里，由于ccls需要知道项目都使用了哪些文件，所以需要我们为它创建配置文件，如果项目是CMake的，可以直接执行命令生成compile_commands.json文件，如果不是CMake的项目，则需要使用bear对Makefile进行编译，bear会拦截编译信息，最终生成compile_commands.json。</p><p>CMake：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmake -DCMAKE_EXPORT_COMPILE_COMMANDS&#x3D;ON</span><br></pre></td></tr></table></figure><p>Makefile：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bear -- make</span><br></pre></td></tr></table></figure><p>等文件生成完毕后，使用ln命令将文件软链回项目根目录。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -sf build&#x2F;compile_commands.json compile_commands.json</span><br></pre></td></tr></table></figure><p>此时已经配置完成一半了，我们还需要在根目录创建.ccls文件，并写入一下配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%compile_commands.json</span><br></pre></td></tr></table></figure><p>此时ccls就可以读取compile_commands.json的信息，为我们提供自动补全等功能了。</p><img src="/2020/12/23/ccls/ccls.png" class="lazy" data-srcset="/2020/12/23/ccls/ccls.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="如果出现了找不到vimproc动态库"><a href="#如果出现了找不到vimproc动态库" class="headerlink" title="如果出现了找不到vimproc动态库"></a>如果出现了找不到vimproc动态库</h2><p>在nvim中执行 <code>:VimProcInstall</code>进行重新编译。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;LSP(Language Server Protocol) 语言服务协议，此协议定义了在编辑器或IDE与语言服务器之间使用的协议，该语言服务器提供了例如自动补全，转到定义，查找所有引用等的功能；语言服务器索引格式的目标是支持在开发工具中进行丰富的代码导航或者一个无需本地源码</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.justforlxz.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.justforlxz.com/tags/Linux/"/>
    
    <category term="vim" scheme="https://blog.justforlxz.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Qt多线程</title>
    <link href="https://blog.justforlxz.com/2020/11/17/qt-multi-thread/"/>
    <id>https://blog.justforlxz.com/2020/11/17/qt-multi-thread/</id>
    <published>2020-11-17T15:53:37.000Z</published>
    <updated>2021-03-04T07:40:49.317Z</updated>
    
    <content type="html"><![CDATA[<p>类型注册 Qt 有三种多线程的方式，分别是继承 QThread、使用 QObject 的 moveToThread 函数和 Qtconcurrent 协程。</p><p>在很多文章中，大家都推荐继承 QThread 类，并重写 run 方法，在 run 中使用耗时操作代码。这种方式让我们觉得 QThread 是线程的实体。创建一个 QThread 对象就认为是开辟了一个新的线程。这种讨巧的方法似乎能帮助我们快速入门，但是只要深度了解多线程编程就会发现，这样子做会使代码脱离我们的控制，代码越写越复杂。最典型的问题就是明明将代码放入了新线程，但是仍然在旧线程中运行。</p><a id="more"></a><p><strong>我们应该把耗时代码放在哪里？</strong></p><p>暂时不考虑多线程的情况，我们一般都会将耗时代码封装到一个类中。在考虑多线程的情况下，难道我们要将代码剥离出来放到某个地方吗？其实不用这么麻烦。在 qt4 时代，我们需要使用继承 QThread 的方法，这样会破坏我们原有的代码结构，并且 run 方法只能运行一段代码，如果我们有成千上万个函数，我们总不能封装如此多的 QThread。</p><p>所以在 Qt5 中，Qt 库完善了线程的亲和性以及信号槽机制，我们有了更为优雅的使用线程的方式，即 QObject::moveToThread()。这也是官方推荐的做法。</p><p>我们准备两个类来介绍和解释一下工作流程。</p><p>controller.hpp</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONTROLLER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONTROLLER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controller</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Controller</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">        : <span class="title">QObject</span><span class="params">(parent)</span> </span>&#123;&#125;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">requestPing</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        qDebug() &lt;&lt; Q_FUNC_INFO &lt;&lt; <span class="keyword">this</span>-&gt;thread();</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot;pong&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// CONTROLLER_H</span></span></span><br></pre></td></tr></table></figure><p>handler.hpp</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDLEER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDLEER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QThread&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Handler</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">        : <span class="title">QObject</span><span class="params">(parent)</span> </span>&#123;&#125;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">requestPong</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        qDebug() &lt;&lt; Q_FUNC_INFO &lt;&lt; <span class="keyword">this</span>-&gt;thread();</span><br><span class="line">        <span class="function">emit <span class="title">requestPong</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// HANDLEER_H</span></span></span><br></pre></td></tr></table></figure><p>在 main.cpp 中初始化对象，并连接信号和槽。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QThread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;controller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;handleer.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    QThread* handleThread = <span class="keyword">new</span> QThread;</span><br><span class="line">    Controller* controller = <span class="keyword">new</span> Controller;</span><br><span class="line">    Handler* handler = <span class="keyword">new</span> Handler;</span><br><span class="line">    <span class="comment">// 移动对象到新的线程</span></span><br><span class="line">    handler-&gt;moveToThread(handleThread);</span><br><span class="line">    handleThread-&gt;start();</span><br><span class="line">    <span class="comment">// 将对象的信号的槽绑定，注意必须在 moveToThread 之后链接。</span></span><br><span class="line">    QObject::connect(controller, &amp;Controller::requestPing, handler, &amp;Handler::ping);</span><br><span class="line">    QObject::connect(handler, &amp;Handler::requestPong, controller, &amp;Controller::pong);</span><br><span class="line">    emit controller-&gt;requestPing();</span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下执行结果:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Handler::ping() QThread(0x14ee080)</span><br><span class="line">void Controller::pong() QThread(0x14e9e60)</span><br><span class="line">pong</span><br></pre></td></tr></table></figure><p>可以看出来两个函数获取到的QThread对象并不是同一个了。<br>使用 movetothread 将一个对象移动到新的线程，并通过信号调用目标函数，从而达到在新线程执行的目的。</p><p>使用这种方式，我们可以方便的通过操作QThread对象来控制线程的执行，例如设置线程的优先级别，暂停线程或者恢复线程。并且这种方式比继承QThread可以更加直观的感受到，QThread只是一个线程的管理类，而不是线程实体，如果采用继承的方式，则会认为QThread就是线程实体，从而造成一定的认知混乱。</p><p>还有一种多线程的方式，这种方案更加的灵活，不需要我们new新的QThread对象，是一个较高层次的API封装。QtConCurrent可根据计算机的 CPU 核数，自动调整运行的线程数目。</p><p>在使用Qtconcurrent之前需要添加对应的Qt模块concurrent。</p><p>在使用的时候，我们需要添加一个QFutureWatcher对象，用来控制和执行一个QFuture对象，并且通过finished信号接收QFuture对象的执行结果。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QFutureWatcher&lt;<span class="keyword">bool</span>&gt;* watcher = <span class="keyword">new</span> QFutureWatcher&lt;<span class="keyword">bool</span>&gt;();</span><br><span class="line">QObject::connect(watcher, &amp;QFutureWatcher&lt;<span class="keyword">bool</span>&gt;::finished, watcher, [=] &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> result = watcher-&gt;result();</span><br><span class="line">    qDebug() &lt;&lt; result;</span><br><span class="line">    watcher-&gt;deleteLater();</span><br><span class="line">&#125;);</span><br><span class="line">QFuture&lt;<span class="keyword">bool</span>&gt; <span class="built_in">future</span> = QtConcurrent::run([=]() -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line">watcher-&gt;setFuture(<span class="built_in">future</span>);</span><br></pre></td></tr></table></figure><p>以上就是一个简单的例子，不难发现，Qt为我们提供了相当不错的解决方案，这种形式比较类似于QDbus对象使用QDbusPendingCallWatcher来异步获取结果的方式，使用起来非常容易上手。<br>在使用多线程的时候，我们需要注意一些事情：互斥与同步同步，类型注册，在线程中开辟线程。</p><p>在多线程开发中，我们需要注意的地方就有点多了，最重要的就是线程同步，我们需要使用一些手段，让不同线程中的函数可以正确的访问的数据。</p><ul><li>互斥：一个公共资源同一时刻只能被一个进程或线程使用，多个进程或线程不能同时使用公共资源。</li><li>同步：两个或两个以上的进程或线程在运行过程中协同步调，按预定的先后次序运行。</li></ul><p>解决方法：互斥锁，条件变量，读写锁，自旋锁，信号量（互斥与同步）。</p><p>在Qt编程中，我们可以利用Qt的信号与槽机制实现两个对象的通信，无论两个对象是否在同一个线程，但是我们传递参数需要注册给Qt的元对象系统，否则Qt将无法完成数据传递。</p><p>在Qt中注册自定义类型有两种方式，一种是qRegisterMetaType<T>()函数和Q_DECLARE_METATYPE(Type)宏。</p><p>这两种注册方式有不同的作用。使用qRegisterMetaType<T>()函数可以让自定义类型在Qt的信号槽中传递，而Q_DECLARE_METATYPE(Type)宏则是可以让注册的自定义类型使用QVariant进行包装。</p><p>在多线程开发中我们还需要注意，Qt存在半自动内存管理，这个内存管理方式会影响着我们使用多线程开发。我们在创建新的QObject对象时，如果制定了parent，则该对象将与父对象进行线程绑定。如果两个对象在不同的线程中，Qt会警告我们父对象的线程和当前对象的线程不是同一个，他们将无法使用Qt的connect函数进行消息传递。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;类型注册 Qt 有三种多线程的方式，分别是继承 QThread、使用 QObject 的 moveToThread 函数和 Qtconcurrent 协程。&lt;/p&gt;
&lt;p&gt;在很多文章中，大家都推荐继承 QThread 类，并重写 run 方法，在 run 中使用耗时操作代码。这种方式让我们觉得 QThread 是线程的实体。创建一个 QThread 对象就认为是开辟了一个新的线程。这种讨巧的方法似乎能帮助我们快速入门，但是只要深度了解多线程编程就会发现，这样子做会使代码脱离我们的控制，代码越写越复杂。最典型的问题就是明明将代码放入了新线程，但是仍然在旧线程中运行。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>deepin-wine中文乱码</title>
    <link href="https://blog.justforlxz.com/2020/09/17/deepin-wine-chinese-problem/"/>
    <id>https://blog.justforlxz.com/2020/09/17/deepin-wine-chinese-problem/</id>
    <published>2020-09-17T16:32:12.000Z</published>
    <updated>2021-03-04T07:40:49.297Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，使用wine来运行windows下的一些软件是linux用户的常用操作，deepin为社区贡献了好几款中国用户必备的软件，例如QQ、微信、企业微信，以此来让更多的人无痛的切换到linux来。近年来value也一直在linux上布局，先后推出了steam主机和proton,前者是基于kvm和steam大屏幕模式的系统，而proton则是wine的分支，value提供了几组补丁用来提高性能和与Windows游戏的兼容性。</p><p>Arch上有非常方便的aur仓库，有很多用户都自己提交一些软件到aur上面，就有几个维护者将deepin打包的deepin wine和对应的软件包移植到Arch上面来，已经是很多人在Arch上面运行QQ和微信的首选方案。</p><p>但是使用的过程中我遇到了以下几个问题：</p><ul><li>输入框中文乱码</li><li>在DDE桌面使用kwin的情况下最小化会卡死</li><li>KDE桌面环境无法使用deepin wine的程序</li></ul><p>第二个问题比较特殊，因为dde在deepin和uos下运行的是fork版本的kwin,而Arch上运行的则是原版的kwin,一些操作代码并不具备，所以会出现一些奇葩的状况。</p><p>第三个问题则是xsettings的原因，在移植者的仓库有对应的issue讨论 <a href="https://github.com/wszqkzqk/deepin-wine-ubuntu/issues/12">《KDE环境完全无法使用wine-tim》</a></p><p>第一个问题解决起来也比较简单，是因为缺少了宋体文件，从而无法正确的渲染中文字体。而比较奇葩的是，把方块复制再粘贴，就可以正确的渲染了。</p><p>解决的方法也很简单，把windows的的字体复制过来就可以了。由于版权的问题，没办法直接提供文件，需要各位自己复制了。</p><blockquote><p>引用资料</p></blockquote><p><a href="https://github.com/wszqkzqk/deepin-wine-ubuntu/issues/136#issuecomment-517576733">https://github.com/wszqkzqk/deepin-wine-ubuntu/issues/136</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;众所周知，使用wine来运行windows下的一些软件是linux用户的常用操作，deepin为社区贡献了好几款中国用户必备的软件，例如QQ、微信、企业微信，以此来让更多的人无痛的切换到linux来。近年来value也一直在linux上布局，先后推出了steam主机和pro</summary>
      
    
    
    
    <category term="技术" scheme="https://blog.justforlxz.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Linux" scheme="https://blog.justforlxz.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用rEFInd来安全启动系统</title>
    <link href="https://blog.justforlxz.com/2020/09/08/use-refind-to-boot-system/"/>
    <id>https://blog.justforlxz.com/2020/09/08/use-refind-to-boot-system/</id>
    <published>2020-09-08T19:54:26.000Z</published>
    <updated>2021-03-04T07:40:49.345Z</updated>
    
    <content type="html"><![CDATA[<p>今年的七夕，我老婆给我买了一台surface laptop 2代，8G内存 + 256G存储版本，我也成功的用上了田牌的机器。</p><a id="more"></a><blockquote><p>2020/09/17更新： 不知道为啥，反正是开了对内核签名以后，哪怕是BIOS关闭了安全启动，仍然出现mkinitcpio会卡在autodetect上，无奈全部都删掉重来了，没有弄签名，希望各位看到本文章以后解决了这个问题能回复一下，谢谢。</p></blockquote><p>surface默认是开启了安全启动(Microsoft签名)和bitlocker来保障设备和系统安全，我作为一个linux系统的开发者，当然是需要在surface上装一个linux了，但是前两年zccrs已经踩过坑了，linux不识别surface键盘，同样的触摸、网卡、声卡等设备也工作的不是很正常，本来以为我要开启远程开发的生活了，还特意写了一篇<a href="https://blog.justforlxz.com/2020/09/03/use-vscode-to-remotely-develop-dde/">《使用VSCode远程开发DDE》</a>，来给公司里有同样烦恼的人，让他们也感受一下远程开发的魅力。</p><p>苍天不负有心人，我成功的！</p><p>我成功的使用上了ArchLinux,并且工作的十分良好。这多亏了github上的一个组织<a href="https://github.com/linux-surface/linux-surface/">linux-surface</a>，有这么一些人，他们付出劳动来让手里的surface设备也用上linux,并且要和普通的x86兼容机一样工作，感谢他们的付出，也让我吃上了螃蟹，安装的过程我就不在这里详细说了，其实非常简单。</p><p>首先因为surface只有一个usb口，而键盘并不能工作，所以需要一个usb的扩展器。先按fn+f6进bios关闭掉安全启动，修改引导顺序为usb优先，之后就是正常的安装系统，但是不需要安装仓库里的内核，我们需要安装linux-surface提供的仓库里的内核。</p><p>这些都是非常正常的步骤，linux-surface提供了自己的仓库和内核，我们正常使用即可。</p><p>这里开始就是我研究了半天的内容， <strong>开启安全模式!</strong></p><p>首先我看了一下arch wiki上有关于安全启动的内容，写的挺详细的，就是看不懂。讲了各种的知识点，各种签名的方式，但是真正到我开始用的时候，我是一直失败的，失败的方式我就不说了，直接说我如何成功的。</p><p>首先我放弃了grub,一个原因是grub的安全启动我一直没有尝试成功，另外一个是我只有一个系统，没必要用grub。我换成了rEFInd来作为我的bootloader，首先安装rEFInd的引导。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yay -S refind shim-signed sbsigntools</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo refind-install --shim &#x2F;usr&#x2F;share&#x2F;shim-signed&#x2F;shimx64.efi --localkeys</span><br></pre></td></tr></table></figure><p>来解释一下上面两条明令。第一个是安装必要的软件包，refind是bootloader本体，shim-signed是aur里面的用于安全启动的包，shim提供了一种并行的安全启动验证功能，我们使用它来启动refind的efi,再通过refind的efi启动内核，达到终极套娃启动。sbsigntools是用于给文件签名的工具，我们安装完refind以后，refind会帮助我们生成一份默认的key,我们需要使用这个key来为内核进行签名。</p><p>在执行第二条明令以后，会有几次询问，都选择Y回车就行。</p><p>然后使用sbsigntools来对内核进行签名。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo sbsign --key &#x2F;etc&#x2F;refind.d&#x2F;keys&#x2F;refind_local.key --cert &#x2F;etc&#x2F;refind.d&#x2F;keys&#x2F;refind_local.crt --output &#x2F;boot&#x2F;vmlinuz-linux-surface &#x2F;boot&#x2F;vmlinuz-linux-surface</span><br></pre></td></tr></table></figure><p>准备工作已经进行一半了，我们只需要写一下refind的配置文件，就可以启动了。</p><p>refind的配置文件有两个地方，一个是boot分区下面的refind_linux.conf，还有一个是在efi分区里的EFI/refind/refind.conf，我们需要修改的是后者。</p><p>默认配置文件都是注释的，其实我们全部删了就可以了，有需要修改的地方去看原始文件或者文档就行了。</p><p>添加一个menuentry，就可以启动系统了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">also_scan_dirs +,ArchFS&#x2F;boot</span><br><span class="line">dont_scan_dirs ESP:&#x2F;EFI&#x2F;boot,EFI&#x2F;boot</span><br><span class="line">dont_scan_files shim.efi,MokManager.efi,fbx64.efi,mmx64.efi,shimx64.efi</span><br><span class="line">scan_all_linux_kernels false</span><br><span class="line"></span><br><span class="line">menuentry &quot;Arch Linux&quot; &#123;</span><br><span class="line">    icon     &#x2F;EFI&#x2F;refind&#x2F;icons&#x2F;os_arch.png</span><br><span class="line">    volume   8B131F77-62D7-4B4A-82D4-B60D7ACA2F6C</span><br><span class="line">    loader   &#x2F;ArchFS&#x2F;boot&#x2F;vmlinuz-linux-surface</span><br><span class="line">    initrd   &#x2F;ArchFS&#x2F;boot&#x2F;intel-ucode.img</span><br><span class="line">    initrd   &#x2F;ArchFS&#x2F;boot&#x2F;initramfs-linux-surface.img</span><br><span class="line">    options  &quot;root&#x3D;UUID&#x3D;9f8f9556-8ec1-4feb-9519-435beac8376f rw rootflags&#x3D;subvol&#x3D;ArchFS  loglevel&#x3D;3 quiet add_efi_memmap&quot;</span><br><span class="line">    submenuentry &quot;Boot using fallback initramfs&quot; &#123;</span><br><span class="line">        initrd &#x2F;ArchFS&#x2F;boot&#x2F;initramfs-linux-surface-fallback.img</span><br><span class="line">    &#125;</span><br><span class="line">    submenuentry &quot;Boot to terminal&quot; &#123;</span><br><span class="line">        add_options &quot;systemd.unit&#x3D;multi-user.target&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我用的是btrfs文件系统，所以配置文件有点罗嗦。解释一下上面的内容。</p><p>also_scan_dirs是指定扫描某个目录，因为我是btrfs文件系统，必须使用这个才能让refind扫描到内核文件，否则会无法启动。</p><p>dont_scan_dirs是跳过指定的目录，因为refind默认是会扫描所有的efi文件，我们自己提供了emnuentry,所以不需要让它扫描了。</p><p>dont_scan_files是跳过指定的文件，这里是防止其他目录出现对应的efi也被扫描到。</p><p>scan_all_linux_kernels是扫描所有linux内核，这样所有的内核就会出现在启动列表里，我们同样也是不需要的。</p><p>menuentry里面需要修改的地方有，volume是分区的partuuid,我因为这个uuid就测试了好几次，最后才反应过来不是filesystem uuid,要求的是partition uuid. 所有遇到ArchFS的地方都是不需要的，因为btrfs支持字卷，我的系统是在一个叫ArchFS的卷里面的，如果不是btrfs的文件系统，这个是不需要的，同样options里的rootflags选项也是不需要的，这是传递给内核的参数，让内核可以正确的加载根分区。</p><p>这样就算完工了，重启系统，然后进bios里把安全启动改成Microsoft &amp; 3rd party CA，然后重新启动。</p><p>当第一次加载rEFInd的时候，因为我们的证书是才生成的，主板并没有存储对应的签名，rEFInd会启动mmx64.efi来让我们加载证书，证书的位置在<code>/etc/refind.d/keys</code>下，选择<code>refind_local.cer</code>导入，然后选择重启，重新进入系统就可以了。</p><p>导入证书这部分我其实不太确定，因为我除了使用shim方案，我还测试了preloader方案，那个方案会一开始就启动一个MOK的工具进行证书导入，我记不太清shim到底需不需要手动导入了，如果出现了，那就导入一下就行了，没出现的话就能正常的看到引导界面和进入系统了。</p><p>还有一个后续的动作需要处理，就是内核升级以后，我们需要对内核重新签名，否则会被bios拒绝启动。</p><p>编辑<code>/etc/pacman.d/hooks/99-secureboot.hook</code>,并写入以下配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Trigger]</span><br><span class="line">Operation &#x3D; Install</span><br><span class="line">Operation &#x3D; Upgrade</span><br><span class="line">Type &#x3D; Package</span><br><span class="line">Target &#x3D; linux</span><br><span class="line">Target &#x3D; linux-surface</span><br><span class="line">Target &#x3D; systemd</span><br><span class="line"></span><br><span class="line">[Action]</span><br><span class="line">Description &#x3D; Signing Kernel for SecureBoot</span><br><span class="line">When &#x3D; PostTransaction</span><br><span class="line">Exec &#x3D; &#x2F;usr&#x2F;bin&#x2F;sh -c &quot;&#x2F;usr&#x2F;bin&#x2F;find &#x2F;boot&#x2F; -type f \( -name &#39;vmlinuz-*&#39; -o -name &#39;systemd*&#39; \) -exec &#x2F;usr&#x2F;bin&#x2F;sh -c &#39;if ! &#x2F;usr&#x2F;bin&#x2F;sbverify --list &#123;&#125; 2&gt;&#x2F;dev&#x2F;null | &#x2F;usr&#x2F;bin&#x2F;grep -q \&quot;signature certificates\&quot;; then &#x2F;usr&#x2F;bin&#x2F;sbsign --key &#x2F;etc&#x2F;refind.d&#x2F;keys&#x2F;refind_local.key --cert &#x2F;etc&#x2F;refind.d&#x2F;keys&#x2F;refind_local.crt --output &#123;&#125; &#123;&#125;; fi&#39; \;&quot;</span><br><span class="line">Depends &#x3D; sbsigntools</span><br><span class="line">Depends &#x3D; findutils</span><br><span class="line">Depends &#x3D; grep</span><br></pre></td></tr></table></figure><p>享受安全启动吧～</p><img src="/2020/09/08/use-refind-to-boot-system/IMG_1089.JPG" class="lazy" data-srcset="/2020/09/08/use-refind-to-boot-system/IMG_1089.JPG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><img src="/2020/09/08/use-refind-to-boot-system/IMG_1090.JPG" class="lazy" data-srcset="/2020/09/08/use-refind-to-boot-system/IMG_1090.JPG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><img src="/2020/09/08/use-refind-to-boot-system/IMG_1091.JPG" class="lazy" data-srcset="/2020/09/08/use-refind-to-boot-system/IMG_1091.JPG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片">]]></content>
    
    
    <summary type="html">&lt;p&gt;今年的七夕，我老婆给我买了一台surface laptop 2代，8G内存 + 256G存储版本，我也成功的用上了田牌的机器。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.justforlxz.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Linux" scheme="https://blog.justforlxz.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>deepin git version</title>
    <link href="https://blog.justforlxz.com/2020/09/06/deepin-git-version/"/>
    <id>https://blog.justforlxz.com/2020/09/06/deepin-git-version/</id>
    <published>2020-09-06T12:51:08.000Z</published>
    <updated>2021-03-04T07:40:49.297Z</updated>
    
    <content type="html"><![CDATA[<p>This repository only provides the git version of deepin. You can replace the deepin group in the community by installing the deepin-git group.</p><a id="more"></a><p>The PKGBUILD for all packages are there <a href="https://github.com/justforlxz/deepin-git-repo">https://github.com/justforlxz/deepin-git-repo</a>, Each branch saves the corresponding software.</p><p>Before adding this repository, you should first add the key used to sign the packages in it. You can do this by running the following commands:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -qO - https://packages.justforlxz.com/deepingit.asc \</span><br><span class="line">    | sudo pacman-key --add -</span><br></pre></td></tr></table></figure><p>It is recommended that you now fingerprint it by running</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman-key --finger DCAF15B4605D5BEB</span><br></pre></td></tr></table></figure><p>and in a final step, you have to locally sign the key to trust it via</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman-key --lsign-key DCAF15B4605D5BEB</span><br></pre></td></tr></table></figure><p>More infos on this process can be found at <a href="https://wiki.archlinux.org/index.php/Pacman/Package_signing#Adding_unofficial_keys">https://wiki.archlinux.org/index.php/Pacman/Package_signing#Adding_unofficial_keys</a>. You can now add the repository by editing /etc/pacman.conf and adding</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[deepingit]</span><br><span class="line">Server = https://packages.justforlxz.com/</span><br></pre></td></tr></table></figure><p>at the end of the file. See <a href="https://wiki.archlinux.org/index.php/Pacman#Repositories_and_mirrors">https://wiki.archlinux.org/index.php/Pacman#Repositories_and_mirrors</a> for details.</p><p>to install deepin git version:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -Syy deepin-git</span><br></pre></td></tr></table></figure><p>If you don’t want to use the repository anymore, you can uninstall deepin git, or install the deepin group in Community.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -Rscn deepin-git</span><br></pre></td></tr></table></figure><p>to install deepin group for community.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S deepin</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;This repository only provides the git version of deepin. You can replace the deepin group in the community by installing the deepin-git group.&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.justforlxz.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Linux" scheme="https://blog.justforlxz.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用VSCode远程开发DDE</title>
    <link href="https://blog.justforlxz.com/2020/09/03/use-vscode-to-remotely-develop-dde/"/>
    <id>https://blog.justforlxz.com/2020/09/03/use-vscode-to-remotely-develop-dde/</id>
    <published>2020-09-03T11:14:38.000Z</published>
    <updated>2021-03-04T07:40:49.377Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍如何使用VSCode的远程开发套件连接到Deepin主机，进行DDE和其他软件的开发与调试.</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Visual Studio Code（简称VS Code）是一个由微软开发，同时支持Windows 、 Linux和macOS等操作系统的免费代码编辑器，它支持测试，并内置了Git 版本控制功能，同时也具有开发环境功能，例如代码补全（类似于 IntelliSense）、代码片段和代码重构等。该编辑器支持用户个性化配置，例如改变主题颜色、键盘快捷方式等各种属性和参数，同时还在编辑器中内置了扩展程序管理的功能。</p><p>在VSCode出来之前，Sublime曾经是前端开发者必备的软件，它使用python作为插件运行环境，并且也拥有不少的插件，但是很遗憾的是插件不能更改界面元素，可玩性不是很高。</p><p>再后来Atom作为GitHub的顶梁柱出现了，它基于使用Chromium和Node.js的跨平台应用框架Electron（最初名为Atom Shell），并使用CoffeeScript和Less撰写，并且支持js开发的插件，一时间拥有非常多的用户，并且从Sublime那里拉拢了非常多的前端开发者。</p><p>但是一切都在VSCode面世以后变了。VSCode同样也是基于Chromim和Electron开发，并且支持TypeScript开发插件，而且启动速度比Atom快很多，而且作为微软面向开源社区的主力产品，它和TypeScript一样，吸收了社区的很多意见和贡献，使得软件越来越好用。在语言支持方面，对 C#、JavaScript、和 TypeScript 等编程语言的原生支持最为完善。</p><h2 id="安装VS-Code"><a href="#安装VS-Code" class="headerlink" title="安装VS Code"></a>安装VS Code</h2><p>官网提供的有vscode的安装包，windows用户下载stable版本的exe(System Installer)。</p><p>System Installer可以自动下载对应语言的环境包，推荐安装此版本。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/W1KvXk0ylxHa9w8E.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/W1KvXk0ylxHa9w8E.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><p>安装完成后就可以安装插件了。</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>插件系统是一个编辑器的左膀右臂，emacs和vim作为终端下开发经常使用的编辑器，就拥有非常丰富的插件，几乎每个大佬使用的emacs和vim都不能互换使用。</p><p>dde的项目几乎都是cmake的项目，所以需要安装cmake插件和c++的插件，安装了这两个插件以后。vscode打开项目工程就会自动解析CMakeLists.txt，并且开启vscode的快速调试功能，还可以开始构建项目和调试项目了。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/XvMxNUQrs9oyEYJF.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/XvMxNUQrs9oyEYJF.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><p>安装CMake、CMake Tools这两个插件就可以开发了。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/tBB60YiLW79oMLC1.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/tBB60YiLW79oMLC1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><p>安装C/C++和C++ Intellisense这两个插件可以对项目中的c++代码进行智能感知和代码补全，推荐安装。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/idQexXGZXPrqCBby.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/idQexXGZXPrqCBby.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><p>安装Remote - SSH插件，可以让vscode通过ssh连接到目标机器，打开远程机器的目录和文件，并且在该模式下，部分插件可以自动切换成本地/远程模式，这样就可以在本机直接开发，但是操作的内容都是远程环境的。</p><p>安装完Remote - SSH插件以后，vscode的左下角就会有一个绿色的按钮，可以用来切换模式。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/MWorTAHEAsJRt47E.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/MWorTAHEAsJRt47E.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><h2 id="配置远程环境"><a href="#配置远程环境" class="headerlink" title="配置远程环境"></a>配置远程环境</h2><p>因为是要在Windows上进行远程开发，如果是直接在UOS或者Deepin上开发DDE，这一部分是可以不用看的，上面的插件安装完成以后就可以开发项目了。</p><p>点击左下角的绿色按钮，在弹出的面板选择Remote-SSH: Connect to Host。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/WFN9jpqyRRXORtuP.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/WFN9jpqyRRXORtuP.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><p>会继续弹出一个面板，用来选择配置ssh的连接。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/Cw7Z7sF3rb8RiBzZ.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/Cw7Z7sF3rb8RiBzZ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><p>选择Add New SSH Host添加一个服务器。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/qcXsO8ayHXyTMr62.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/qcXsO8ayHXyTMr62.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><p>输入ssh的命令，例如 ssh <a href="mailto:&#108;&#120;&#x7a;&#x40;&#49;&#x30;&#46;&#50;&#48;&#46;&#x33;&#x32;&#x2e;&#x35;&#52;">&#108;&#120;&#x7a;&#x40;&#49;&#x30;&#46;&#50;&#48;&#46;&#x33;&#x32;&#x2e;&#x35;&#52;</a>。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/9Cla2rDtfzfsHVSh.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/9Cla2rDtfzfsHVSh.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><p>然后选择一个保存配置的位置，一般默认选择用户家目录的.ssh目录即可。然后就提示添加成功，此时可以点击Connect按钮进行连接。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/Do8KoBS0lwM1g09G.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/Do8KoBS0lwM1g09G.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><p>输入密码</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/J7dPRyLYI4QBcma5.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/J7dPRyLYI4QBcma5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><p>登录以后会打开一个新的窗口，并提示正在连接。连接成功以后可以在左下角看到机器的信息。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/LjLHBXGQeuvXMk8k.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/LjLHBXGQeuvXMk8k.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/VJQhRC7LXbhWyWdN.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/VJQhRC7LXbhWyWdN.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><p>然后打开命令面板，选择在SSH中安装本地扩展。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/XJEqsfmwIO5FpUKS.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/XJEqsfmwIO5FpUKS.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><p>在打开的列表选择全选，然后安装。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/zmVjGPVL7gphBZ7h.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/zmVjGPVL7gphBZ7h.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><p>等待全部安装成功。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/P1yXbz7pkrwXOEAS.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/P1yXbz7pkrwXOEAS.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/WbxesoOf0RF1QqtZ.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/WbxesoOf0RF1QqtZ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><h2 id="开发和调试"><a href="#开发和调试" class="headerlink" title="开发和调试"></a>开发和调试</h2><h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>CMake插件提供了编译、运行和调试的功能和命令，可以点击下方面板中的select target，选择要运行的目标程序，选择切换编译模式，可以选择Debug或者Release。还可以选择使用哪个编译器进行构建。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/je8iADCEbmCT7sMZ.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/je8iADCEbmCT7sMZ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/uUIxae7PVFDwSyUB.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/uUIxae7PVFDwSyUB.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/Ah6NUPpjjoDIL93K.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/Ah6NUPpjjoDIL93K.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/UbibgDc1gL0tXNPy.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/UbibgDc1gL0tXNPy.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><h3 id="设置启动参数"><a href="#设置启动参数" class="headerlink" title="设置启动参数"></a>设置启动参数</h3><p>如果程序启动不需要提供参数，则可以直接点击下方面板的Debug按钮，或者打开命令面板选择CMake Debug Target，如果没有选择过Target，则会询问一次设置Target。</p><p>点击左侧的调试按钮，选择添加配置。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/kTjwUYxwt19QlwPt.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/kTjwUYxwt19QlwPt.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><p>在弹出的面板选择GDB</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/5Q4JOQWUZnDMtBNx.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/5Q4JOQWUZnDMtBNx.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><p>此时vscode会创建出一个json文件，并生成了默认的配置文件。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/l1IZdMrxfd0dH45a.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/l1IZdMrxfd0dH45a.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><p>我们需要进行一些调整，以便使用该配置文件进行调试。</p><p>program字段是程序二进制文件的位置，一般情况下我们是要手动写好路径，但是如果项目的二进制特别多，更换配置文件就会非常麻烦，而且配置文件里写死路径也不是很方便，我查阅了CMake插件的文档，发现CMake插件提供了两个很重要的变量，可以让我们方便的查找到路径。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;program&quot;: &quot;$&#123;command:cmake.launchTargetPath&#125;&quot;</span><br></pre></td></tr></table></figure><p>CMake插件提供了launchTargetPath的变量，它对应的是CMake插件选择的默认target，启动调试之前需要我们先选择好Target。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;value&quot;: &quot;$PATH:$&#123;command:cmake.launchTargetDirectory&#125;&quot;</span><br></pre></td></tr></table></figure><p>CMake插件还提供了launchTargetDirectory变量，用于获取程序启动所在的目录，一般需要我们指定到本次调试所需的环境变量中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;environment&quot;: [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;PATH&quot;,</span><br><span class="line">    &quot;value&quot;: &quot;$PATH:$&#123;command:cmake.launchTargetDirectory&#125;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后我们就可以添加启动参数了。<br>args字段保存了程序启动会传递的参数列表，例如这里会给fuse传递-d和/tmp/x。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;args&quot;: [</span><br><span class="line">  &quot;-d&quot;,</span><br><span class="line">  &quot;&#x2F;tmp&#x2F;x&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>完整的配置如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;(gdb) fuse&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;command:cmake.launchTargetPath&#125;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;-d&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/tmp/x&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;environment&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;PATH&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;$PATH:$&#123;command:cmake.launchTargetDirectory&#125;&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;为 gdb 启用整齐打印&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h3><p>此时我们就可以先通过CMake插件构建整个项目，再切换到运行面板，启动调试。</p><p>点击下方面板的Build按钮，构建项目。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/FAkfeLuV4JBsc4Mx.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/FAkfeLuV4JBsc4Mx.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><p>再点击左侧的gdb fuse(deepin-turbo)按钮，因为配置文件里面我们起的名字是gdb fuse。我们在main函数添加一个断点，用来测试gdb是否工作正常。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/mKDIuN2GI1pSfVpQ.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/mKDIuN2GI1pSfVpQ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><p>一切都工作正常，在调试控制台可以使用-exec作为前缀来执行gdb的命令。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/sxNL1dJG5uFm22O1.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/sxNL1dJG5uFm22O1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><h3 id="调试图形程序"><a href="#调试图形程序" class="headerlink" title="调试图形程序"></a>调试图形程序</h3><p>调试图形程序稍微有一些麻烦，因为是远程开发，图形程序又只能工作在目标机器，这里提供两个可行的方案。</p><ol><li>synergy之类的键盘鼠标共享软件</li><li>在windows安装xserver</li></ol><p>第一种方案是通过共享本机的键盘鼠标到远程机器，这样就可以在远程环境上面进行直接操作，好处是除了调试，也可以同时操作远程机器进行使用。</p><p>第二种方案是利用X11协议的网络透明，既图形程序和显示服务不一定在同一台机器上运行，我们只需要在Windows安装XServer程序，就可以让远程机器上的程序的画面显示到当前机器，并且可以操作。但是此方案有缺点，虽然设计上这种分离结构设计的很巧妙，但是因为远程OpenGL调用并不支持，所以图形无法调用3D程序渲染，并且和远程机器沟通需要大量的带宽，所以用起来体验并不好。</p><p>为了使用这两种方案，我们都需要在调试的launch.json中添加一个环境变量。</p><p>在运行面板点击齿轮按钮，可以编辑当前方案。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/X32Q5bhGX2B7CLGg.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/X32Q5bhGX2B7CLGg.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><p>在打开的json文件中，找到environment字段，添加DISPLAY环境变量。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;environment&quot;: [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;DISPLAY&quot;,</span><br><span class="line">    &quot;value&quot;: &quot;:0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样程序启动就有DISPLAY环境变量，我们就可以让程序在目标机器的屏幕上运行了。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/7JuWfnnURIt1NrdR.png" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/7JuWfnnURIt1NrdR.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/20200903_023112910_iOS.jpg" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/20200903_023112910_iOS.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/20200903_023116260_iOS.jpg" class="lazy" data-srcset="/2020/09/03/use-vscode-to-remotely-develop-dde/20200903_023116260_iOS.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="图片"><p>还有一种自动化测试的方案，该方案是我个人认为所有开发都应该掌握的，通过自动化测试，我们就可以完全使用远程开发来完成开发任务，调试的时候只需要等待自动测试结果返回即可，设想一下，某个模块需要点击很多地方才可以重现一个问题，我们只需要设置好断点，让程序自动开始执行所有函数，并在最终出现问题的地方停下，我们就可以开始手动单步跟踪问题，完全不需要使用鼠标人工点击。（然而理想很美好，现实很残酷，我个人目前都没有掌握自动化测试的方式，现在也是只能通过鼠标点点点来重现问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍如何使用VSCode的远程开发套件连接到Deepin主机，进行DDE和其他软件的开发与调试.&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://blog.justforlxz.com/categories/Linux/"/>
    
    <category term="技术" scheme="https://blog.justforlxz.com/categories/Linux/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Linux" scheme="https://blog.justforlxz.com/tags/Linux/"/>
    
    <category term="VS Code" scheme="https://blog.justforlxz.com/tags/VS-Code/"/>
    
    <category term="Windows" scheme="https://blog.justforlxz.com/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>在ArchLinux上开发startdde</title>
    <link href="https://blog.justforlxz.com/2020/08/06/develop-startdde-on-archlinux/"/>
    <id>https://blog.justforlxz.com/2020/08/06/develop-startdde-on-archlinux/</id>
    <published>2020-08-06T16:14:26.000Z</published>
    <updated>2021-03-04T07:40:49.297Z</updated>
    
    <content type="html"><![CDATA[<p>dde 后端使用 go 作为主要的开发语言，使用 dbus 提供接口，主要使用 gsettings 来保存配置。 所以在进行后端开发前需要对以上内容有基本的了解，这里假定本文档的阅读者熟悉 dbus 和 gsettings，并有一定的开发经验。</p><a id="more"></a><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>虽然本项目是go语言开发的，但是我们并没有直接使用go的mod作为依赖管理方案，而是走系统包管理器的方式，所以要先安装startdde的编译依赖。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -Sy golang-github-linuxdeepin-go-dbus-factory golang-deepin-gir golang-deepin-lib golang-deepin-dde-api go git jq golang-golang-x-net golang-github-linuxdeepin-go-x11-client</span><br></pre></td></tr></table></figure><p>这些包会被安装到系统的/usr/share/gocode目录下。还需要手动go get一个依赖到本地的GOPATH中。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get -v github.com/cryptix/wav</span><br></pre></td></tr></table></figure><h2 id="设置GOPATH"><a href="#设置GOPATH" class="headerlink" title="设置GOPATH"></a>设置GOPATH</h2><p>为了方便以后的开发，可以将GOPATH环境变量定义到~/.xprofile等文件中，或者shell的配置文件。例如我使用的zsh：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export GOPATH=$HOME/Develop/Go:/usr/share/gocode</span><br><span class="line">export PATH=$HOME/Develop/Go/bin:$PATH</span><br></pre></td></tr></table></figure><h2 id="设置项目目录"><a href="#设置项目目录" class="headerlink" title="设置项目目录"></a>设置项目目录</h2><p>go要求项目目录必须在GOPATH中，所以要将startdde放到GOPATH的pkg.deepin.io/dde/目录下，但是GOPATH每次进入不方便，可以采用软链的形式将startdde的目录链接到GOPATH下。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/Develop/Deepin</span><br><span class="line">git clone https://github.com/linuxdeepin/startdde</span><br><span class="line">mkdir -p ~/Develop/Go/src/pkg.deepin.io/dde/</span><br><span class="line">ln -sf ~/Develop/Deepin/startdde ~/Develop/Go/src/pkg.deepin.io/dde/startdde</span><br></pre></td></tr></table></figure><p>这样就可以在一个方便的目录进行开发了。</p><h2 id="vscode开发工具"><a href="#vscode开发工具" class="headerlink" title="vscode开发工具"></a>vscode开发工具</h2><p>我个人推荐使用vscode当作开发工具，打开vscode安装go的插件，打开startdde目录，vscode会提示安装一些go的工具，选择全部安装即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;dde 后端使用 go 作为主要的开发语言，使用 dbus 提供接口，主要使用 gsettings 来保存配置。 所以在进行后端开发前需要对以上内容有基本的了解，这里假定本文档的阅读者熟悉 dbus 和 gsettings，并有一定的开发经验。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://blog.justforlxz.com/categories/Linux/"/>
    
    
    <category term="dde" scheme="https://blog.justforlxz.com/tags/dde/"/>
    
    <category term="go" scheme="https://blog.justforlxz.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>use github action to check dde-launcher</title>
    <link href="https://blog.justforlxz.com/2020/07/27/use-github-action-to-check-dde-launcher/"/>
    <id>https://blog.justforlxz.com/2020/07/27/use-github-action-to-check-dde-launcher/</id>
    <published>2020-07-27T18:14:21.000Z</published>
    <updated>2021-03-04T07:40:49.333Z</updated>
    
    <content type="html"><![CDATA[<p>本来打算7月份给dde添加github action验证，但是被各种事情耽误了，然后发现麒麟居然抢在我前面部署了全套的github action，这不能忍，赶紧把dde的github action也提上日程。并且打算听<a href="https://github.com/felixonmars">肥肥猫</a>大佬的话，在aur给dde弄一套commit构建包，这样就可以在arch上使用比testing仓库更testing的dde了！</p><a id="more"></a><p>github actions是github官方出的持续集成功能，以前大家在github上的项目都使用的第三方的Travis CI或者自建jenkins构建，但是github被微软收购以后，微软为了表现出给社区和用户的诚意，将大量github的付费功能免费公开给开发者使用，希望能将github打造成开发者中心，于是在2019年微软推出了免费的github actions，每个项目都可以免费使用官方提供的持续集成和持续部署功能，这对第三方业务无疑是个巨大的打击，虽然Travis CI和jenkins等方式仍然有一定的市场，但是对于中小项目的开源项目，使用官方提供的功能无疑是方便的。</p><p>github actions的配置十分简单，只需要几个简单的步骤就可以实现构建、执行和测试代码。并且可以使用Linux、Windows和MacOS环境，机器性能也十分强劲，编译速度非常的快。</p><p>这是给dde-launcher的一份基础配置，需要将配置文件放在.github/workflows/目录下，以build.yaml文件名保存。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">CI</span> <span class="string">Build</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">uos</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">uos</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">archlinux:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Archlinux</span> <span class="string">Build</span> <span class="string">Check</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">container:</span> <span class="string">docker.io/library/archlinux:latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">branch</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Refresh</span> <span class="string">pacman</span> <span class="string">repository</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">pacman</span> <span class="string">-Syy</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">build</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">pacman</span> <span class="string">-S</span> <span class="string">--noconfirm</span> <span class="string">base-devel</span> <span class="string">cmake</span> <span class="string">ninja</span> <span class="string">qt5-tools</span> <span class="string">deepin-qt-dbus-factory</span> <span class="string">dtkwidget</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CMake</span> <span class="string">&amp;</span> <span class="string">Make</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">mkdir</span> <span class="string">build</span></span><br><span class="line">          <span class="string">cd</span> <span class="string">build</span></span><br><span class="line">          <span class="string">cmake</span> <span class="string">../</span> <span class="string">-G</span> <span class="string">Ninja</span></span><br><span class="line">          <span class="string">ninja</span></span><br></pre></td></tr></table></figure><p>介绍一下配置文件吧，name是设置ci的名字，github允许有多个ci存在，可以做不同的事情，例如部署三个ci，一个做语法检查，一个做静态检查，一个做编译检查。name就是用来在界面上显示的。on是设置ci对哪些事件感兴趣，在这里我设置了push和pull_request，当发生push和pull request时，这个ci就会被启动，执行接下来的jobs的内容。jobs里是可以设置多个任务的，同样name字段也是用来展示本次动作的名称。runs-on是设置该job工作的环境，ubuntu-latest是linux环境，container是指使用哪个docker容器，github actions是可以使用docker的，也可以将自己的ci配置共享给其他人使用。run就是执行命令了，在配置文件中我手动运行了刷新仓库和编译项目所需的命令。job的steps可以理解成shell中一次动作的执行，uses是使用其他人封装好的命令，run则是执行本地命令。</p><p>可以看出github actions的配置是十分简单的，并且构建速度也非常的快，并且构建环境是使用的arch linux环境，为什么要选择arch作为ci的基础构建环境呢，原因当然不是因为和肥肥猫有py交易，arch上的dde更新速度很快，并且很多用户都使用arch+dde的方式使用linux，deepin自己维护的发行版因为基础仓库更新较慢，不适合一些用户，所以为了能让dde被更多的人接受和使用，在arch上及时更新dde是十分有必要的。所以才选择actions的环境为arch linux。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本来打算7月份给dde添加github action验证，但是被各种事情耽误了，然后发现麒麟居然抢在我前面部署了全套的github action，这不能忍，赶紧把dde的github action也提上日程。并且打算听&lt;a href=&quot;https://github.com/felixonmars&quot;&gt;肥肥猫&lt;/a&gt;大佬的话，在aur给dde弄一套commit构建包，这样就可以在arch上使用比testing仓库更testing的dde了！&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://blog.justforlxz.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Linux" scheme="https://blog.justforlxz.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用perf工具分析程序性能</title>
    <link href="https://blog.justforlxz.com/2020/07/21/use-perf-to-analytics-program/"/>
    <id>https://blog.justforlxz.com/2020/07/21/use-perf-to-analytics-program/</id>
    <published>2020-07-21T09:15:11.000Z</published>
    <updated>2021-03-04T07:40:49.337Z</updated>
    
    <content type="html"><![CDATA[<p>最近在对DDE进行性能优化，所以补习了一下linux下的各种分析工具的使用方法。</p><img src="/2020/07/21/use-perf-to-analytics-program/bpf_performance_tools_book.png" class="lazy" data-srcset="/2020/07/21/use-perf-to-analytics-program/bpf_performance_tools_book.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="bpf_performance_tools_book.png"><p>这张图是来自Brendan Gregg大佬提供的linux分析工具的应用场景，可以看出几乎包含了系统每个地方应该用什么工具去分析。</p><a id="more"></a><h2 id="Linux-Perf-Tool"><a href="#Linux-Perf-Tool" class="headerlink" title="Linux Perf Tool"></a>Linux Perf Tool</h2><h3 id="允许系统进行分析"><a href="#允许系统进行分析" class="headerlink" title="允许系统进行分析"></a>允许系统进行分析</h3><p>为了能够正常分析，首先需要打开系统的调试功能，允许我们去对其他进程进行访问。</p><h3 id="SysCtl"><a href="#SysCtl" class="headerlink" title="SysCtl"></a>SysCtl</h3><p>较新的Linux内核具有sysfs可调参数<code>/proc/sys/kernel/perf_event_paranoid</code>，该参数允许用户调整perf_events非root用户的可用功能，数量越大则越安全（相应地提供较少的功能）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Consider tweaking &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;perf_event_paranoid:</span><br><span class="line"> -1 - Not paranoid at all</span><br><span class="line">  0 - Disallow raw tracepoint access for unpriv</span><br><span class="line">  1 - Disallow cpu events for unpriv</span><br><span class="line">  2 - Disallow kernel profiling for unpriv</span><br></pre></td></tr></table></figure><p>默认值是不允许获取任何信息，所以我们需要修改为1或者0，允许我们访问CPU的事件信息。</p><ul><li>临时修改</li></ul><p>执行命令向内核接口直接写入值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tee &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;perf_event_paranoid &lt;&lt;&lt; 1</span><br></pre></td></tr></table></figure><ul><li>永久修改</li></ul><p>使用sysctl来配置其值，创建<code>/etc/sysctl.d/50_perf_event_paranoid.conf</code>文件，并写入<code>kernel.perf_event_paranoid=1</code>，执行<code>sysctl -p</code>来刷新系统配置。</p><h3 id="perf-采样"><a href="#perf-采样" class="headerlink" title="perf 采样"></a>perf 采样</h3><blockquote><p>性能优化相关的三种类型的工具，一种是sampling类型的，即采样，这种工具就是不停“询问”程序在做什么，perf在我们使用的这种模式下就是 sampling模式，如果是追踪某些event，就工作在trace模式，实际上就是第二种类型的工具，这种工具主要依靠事件或者hook，程序在运行的过程中不停主动告诉工具它自己在做什么，比如 strace；第三种是 instrument 类型的，这种主要就是依赖编译器进行插桩，精确知道代码行级别的执行情况（参考gcc instrumentation ）。</p><p>by hualet on <a href="https://docsin.uniontech.com/?p=735">deepin 15.7</a></p></blockquote><p>我们通过perf record命令才对程序进行采样记录。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perf record -g --call-graph&#x3D;dwarf -F 99 &#x2F;usr&#x2F;bin&#x2F;dde-shutdown</span><br></pre></td></tr></table></figure><p>命令介绍：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-g: 即采样全部信息</span><br><span class="line">--call-graph: 设置并启用调用图（堆栈链&#x2F;回溯）记录，参数有fp(frame pointers)、dwarf(debug information)和lbr(Last Branch Record)。</span><br><span class="line">-F: 采样率</span><br></pre></td></tr></table></figure><p>perf可以直接启动一个程序进行分析，也可以使用-p参数指定一个pid进行采样。</p><h3 id="查看-perf-的采样结果"><a href="#查看-perf-的采样结果" class="headerlink" title="查看 perf 的采样结果"></a>查看 perf 的采样结果</h3><p>当我们通过perf record完成采样以后，会在执行目录生成perf.data文件，此时我们就可以使用perf report命令对data文件进行数据分析了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perf report --stdio</span><br></pre></td></tr></table></figure><p>perf report会自动打开当前目录下的perf.data文件，当然也可以在最后指定perf.data文件的路径。</p><p>perf report会根据–call-graph参数来生成不同的图，使用dwarf参数时会以函数调用栈的顺序来显示，使用这种方式可以方便的看出哪个函数执行的时间比较长，因为每次采样都能落到该函数上，也就意味着函数执行的时间非常长，再通过调用栈的深度来分析函数执行期间都在做什么事情。</p><h3 id="hotspot火焰图"><a href="#hotspot火焰图" class="headerlink" title="hotspot火焰图"></a>hotspot火焰图</h3><p>在命令行下查看函数调用不是特别方便，所以就有图形化的工具用来方便的查看perf工具的生成结果，其中使用比较友好的是kde开发的hotspot工具，该工具可以直接打开perf.data文件，并生成对应的火焰图，火焰图是函数调用的另一种表现形式，火焰越高，也就意味着调用栈越深，火焰越广，也就意味着函数执行的时间很长。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在对DDE进行性能优化，所以补习了一下linux下的各种分析工具的使用方法。&lt;/p&gt;
&lt;img src=&quot;/2020/07/21/use-perf-to-analytics-program/bpf_performance_tools_book.png&quot; class=&quot;&quot; title=&quot;bpf_performance_tools_book.png&quot;&gt;

&lt;p&gt;这张图是来自Brendan Gregg大佬提供的linux分析工具的应用场景，可以看出几乎包含了系统每个地方应该用什么工具去分析。&lt;/p&gt;</summary>
    
    
    
    <category term="优化" scheme="https://blog.justforlxz.com/categories/%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Linux" scheme="https://blog.justforlxz.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CTest &amp; QTest/GTest</title>
    <link href="https://blog.justforlxz.com/2020/06/16/CTest%20&amp;%20QTEST/"/>
    <id>https://blog.justforlxz.com/2020/06/16/CTest%20&amp;%20QTEST/</id>
    <published>2020-06-16T15:11:40.000Z</published>
    <updated>2021-03-04T07:40:49.293Z</updated>
    
    <content type="html"><![CDATA[<p>本文会介绍一下QTest和GTest的一些功能和区别。</p><a id="more"></a><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><h2 id="ctest"><a href="#ctest" class="headerlink" title="ctest"></a>ctest</h2><p>ctest是CMake提供的运行单元测试的工具，在使用CMakeLists.txt文件编译工程的时候，CTest会自动configure、build、test和展现测试结果。</p><p>ctest有两个模式：</p><ul><li>模式一：使用CMake configure和build工程，在CMakeLists.txt，使用特殊的命令创建tests。使用CTest来执行那些测试。</li><li>模式二：使用CTest来执行一个script，这个script的语法必须和CMakeLists.txt相同。</li></ul><p>使用方法：</p><p>在CMakeLists.txt使用include(CTest)和include(Dart)来导入CTest模块和开启ctest。使用add_test()来添加一个测试程序，测试程序是一个普通的二进制，只不过内部运行的是qtest或者gtest编写的测试用例。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include(CTest)</span><br><span class="line">include(Dart)</span><br><span class="line">add_executable(tests tests&#x2F;test.cpp)</span><br><span class="line">add(NAME tests COMMAND $&lt;TARGET_FILE:tests&gt;)</span><br></pre></td></tr></table></figure><h2 id="qt-qtest"><a href="#qt-qtest" class="headerlink" title="qt qtest"></a>qt qtest</h2><p>qtest是Qt提供的单元测试框架，Qt Test是用于对基于Qt的应用程序和库进行单元测试的框架。Qt Test提供了单元测试框架中常见的所有功能以及用于测试图形用户界面的扩展。</p><p>Qt测试旨在简化基于Qt的应用程序和库的单元测试的编写：</p><table><thead><tr><th align="left">特征</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">轻量</td><td align="left">Qt Test大约有6000行代码和60个导出符号组成</td></tr><tr><td align="left">自成体系</td><td align="left">Qt Test仅需要Qt Core模块中的几个符号即可进行非GUI测试</td></tr><tr><td align="left">快速测试</td><td align="left">Qt Test不需要特殊的测试运行程序，没有特殊的测试注册</td></tr><tr><td align="left">数据驱动测试</td><td align="left">可以使用不同的数据进行多次的测试</td></tr><tr><td align="left">基本的GUI测试</td><td align="left">Qt Test提供了用于鼠标和键盘的模拟功能</td></tr><tr><td align="left">标杆管理</td><td align="left">Qt Test支持基准测试，并提供多个测量后端</td></tr><tr><td align="left">IDE友好</td><td align="left">Qt Test输出可以由Qt Creator、Visual Studio等IDE解释的消息</td></tr><tr><td align="left">线程安全</td><td align="left">错误报告是线程安全和原子的</td></tr><tr><td align="left">类型安全</td><td align="left">模板的广泛使用可以防止隐式类型转换引起的错误</td></tr><tr><td align="left">易于扩展</td><td align="left">可以将自定义类型轻松添加到测试数据和测试输出中</td></tr></tbody></table><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>QVERIFY() 用于验证数据是否正确。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QVERIFY(<span class="number">1</span> == <span class="number">1</span>);</span><br><span class="line">QVERIFY2(<span class="number">1</span> != <span class="number">1</span>, <span class="string">&quot;1不等于1&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>QFETCH_GLOBAL() 该宏从全局数据表中的一行中获取类型类型为name的变量。 名称和类型必须与全局数据表中的列匹配。 这是断言，如果断言失败，则测试将中止。</p><p>QFETCH() 宏会在堆栈上创建一个类型为name的本地变量。 名称和类型必须与测试数据表中的列匹配。 这是断言，如果断言失败，则测试将中止。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QFETCH(QString, aString);</span><br><span class="line">QFETCH_GLOBAL(QLocale, locale);</span><br></pre></td></tr></table></figure><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>QCOMPARE宏用于判断两个值是否相等，如果实际值和预期值匹配，将会继续运行，否则将失败记录在测试日至中，并且测试将被终止，不会尝试任何后续操作。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QCOMPARE(QString(<span class="string">&quot;hello&quot;</span>).toUpper(), QString(<span class="string">&quot;HELLO&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p>通过在包含_data()的函数中调用QTest::addColumn和QTest::newRow向测试用例增加数据，并通过QFETCH宏在测试用例中访问数据。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestQString::toInt_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QTest::addColumn&lt;QString&gt;(<span class="string">&quot;aString&quot;</span>);</span><br><span class="line">    QTest::addColumn&lt;<span class="keyword">int</span>&gt;(<span class="string">&quot;expected&quot;</span>);</span><br><span class="line">    QTest::newRow(<span class="string">&quot;positive value&quot;</span>) &lt;&lt; <span class="string">&quot;42&quot;</span> &lt;&lt; <span class="number">42</span>;</span><br><span class="line">    QTest::newRow(<span class="string">&quot;negative value&quot;</span>) &lt;&lt; <span class="string">&quot;-42&quot;</span> &lt;&lt; <span class="number">-42</span>;</span><br><span class="line">    QTest::newRow(<span class="string">&quot;zero&quot;</span>) &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestQString::toInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     QFETCH(QString, aString);</span><br><span class="line">     QFETCH(<span class="keyword">int</span>, expected);</span><br><span class="line">     QCOMPARE(aString.toInt(), expected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建测试"><a href="#创建测试" class="headerlink" title="创建测试"></a>创建测试</h3><p>要创建测试，需要派生自QObject，并添加一个或多个专用槽函数。每个专用槽函数都是测试中的一个测试功能且必须为private。函数命名方法以casen_函数名或者以test结尾的方式。</p><p>使用QTest::qExec()可用于执行测试对象中的所有测试功能。</p><p>此外，还可以定义不用于测试功能的专用槽函数。如果存在，它们将由测试框架执行，并用于初始化和清除整个测试或当前的测试功能。</p><ul><li><strong>initTestCase()</strong> 将在第一个测试功能执行之前被调用</li><li><strong>initTestCase_data()</strong> 将被调用以创建全局测试数据表</li><li><strong>cleanupTestCase()</strong> 在最后一个测试函数执行后被调用</li><li><strong>init()</strong> 将在每个测试功能执行之前被调用</li><li><strong>cleanup()</strong> 将在每个测试函数之后调用</li></ul><p>使用initTestCase()准备测试。每次测试都应使系统处于可用状态，因此可以重复运行。清理操作应在cleanupTestCase()中处理，因此即使测试失败也可以运行清理操作。</p><p>使用init()创建测试功能。每个测试功能都应使系统保持可用状态，以便可以重复运行。清理操作应在cleanup()中，即使测试功能失败并提前退出，清理动作也可以运行。</p><p>另外，可以使用RAII,并在析构函数中调用清除操作，以确保他们在测试函数返回且对象移出作用域时发生。</p><p>如果initTestCase()失败，将不执行任何测试功能。如果init()失败，则不执行以下测试功能，测试将继续进行下一个测试功能。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">  Q_OBJECT</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">verify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">initTestCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">&quot;init test case&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">firstTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QVERIFY(<span class="literal">true</span>);</span><br><span class="line">    QCOMPARE(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">secondTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QVERIFY(verify());</span><br><span class="line">    QVERIFY(<span class="number">1</span> != <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cleanupTestCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">&quot;clean test case&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后，如果测试类具有静态且公共的void initMain()方法，则在实例化QApplication对象之前，由QTEST_MAIN宏调用该方法。例如，这允许设置应用程序的属性，例如Qt::AA_DisableHighDpiScaling。这是在Qt5.14添加的。</p><h3 id="使用CMake和CTest构建测试项目"><a href="#使用CMake和CTest构建测试项目" class="headerlink" title="使用CMake和CTest构建测试项目"></a>使用CMake和CTest构建测试项目</h3><p>CMake还有其他优点。例如，几乎可以毫不费力地使用CDash将测试运行的结果发布到Web服务器上。</p><p>CTest可以扩展到非常不同的单元测试框架，并且可以与QTest一起使用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">project(mytest LANGUAGES CXX)</span><br><span class="line">include(CTest)</span><br><span class="line">include(Dart)</span><br><span class="line">find_package(Qt5 COMPONENTS Test REQUIRED)</span><br><span class="line">set(CMAKE_INCLUDE_CURRENT_DIR ON)</span><br><span class="line">set(CMAKE_AUTOMOC ON)</span><br><span class="line">add_executable(mytest tst_mytest.cpp)</span><br><span class="line">add_test(NAME mytest COMMAND mytest)</span><br><span class="line">target_link_libraries(mytest PRIVATE Qt5::Test)</span><br></pre></td></tr></table></figure><h2 id="google-test"><a href="#google-test" class="headerlink" title="google test"></a>google test</h2><p>google test(gtest)是google公司推出的c++单元测试框架，基于xUnit架构，并且支持Linux、Windows和mac，并且支持任何类型的测试和模拟，而不仅仅是单元测试。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>当使用gtest时，通过编写断言来检查条件是否为真。断言的结果可能是成功、非致命失败或者致命失败。如果发生致命故障，将终止当前功能，否则将继续运行。</p><p>一个测试套件包含一个或者多个测试。当测试套件中的多个测试需要共享通用对象和子例程时，可以将他们放入一个测试桶中。</p><p>一个测试程序可以包含多个测试套件。</p><h3 id="断言-1"><a href="#断言-1" class="headerlink" title="断言"></a>断言</h3><p>gtest断言类似于函数调用的宏，可以通过断言其行为来测试类或者函数。断言失败时，gtest会输出断言的源文件和行号位置以及失败消息。还可以提供自定义失败消息，该消息将会附加到gtest的消息之后。</p><p>断言成对出现，测试相同的事物，但是对当前函数有不同的影响。ASSERT_<em>版本失败时会产生致命错误，并终止当前功能。EXPECT_</em>会产生非致命错误，不会导致当前测试失败。通常EXPECT_<em>是首选，因为他们允许在测试中报告多个鼓掌，但是如果在断言失败时继续运行将没有意义时应当使用ASSERT_</em>。</p><p>由于ASSERT_*失败会从当前函数立即返回，可能会跳过其后的清理代码，导致内存泄漏。</p><h3 id="基本断言"><a href="#基本断言" class="headerlink" title="基本断言"></a>基本断言</h3><p>基本断言可以进行基本的真/假条件测试</p><table><thead><tr><th align="left">致命断言</th><th align="left">非致命断言</th><th align="left">验证</th></tr></thead><tbody><tr><td align="left">ASSERT_TRUE(condition);</td><td align="left">EXPECT_TRUE(condition);</td><td align="left">condition是真的</td></tr><tr><td align="left">ASSERT_FALSE(condition);</td><td align="left">EXPECT_FLASE(condition);</td><td align="left">condition是假的</td></tr></tbody></table><p>请记住，当它们失败时，将导致ASSERT_<em>致命故障并从当前函数返回，而当它们发生EXPECT_</em>非致命故障时，将允许该函数继续运行。无论哪种情况，断言失败都意味着其包含测试失败。</p><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>该组中的断言比较两个C字符串。如果要比较两个string对象，请改用EXPECT_EQ，EXPECT_NE等。</p><table><thead><tr><th align="center">致命断言</th><th align="center">非致命断言</th><th align="center">验证</th></tr></thead><tbody><tr><td align="center">ASSERT_STREQ(str1,str2);</td><td align="center">EXPECT_STREQ(str1,str2);</td><td align="center">这两个C字符串的内容相同</td></tr><tr><td align="center">ASSERT_STRNE(str1,str2);</td><td align="center">EXPECT_STRNE(str1,str2);</td><td align="center">两个C字符串的内容不同</td></tr><tr><td align="center">ASSERT_STRCASEEQ(str1,str2);</td><td align="center">EXPECT_STRCASEEQ(str1,str2);</td><td align="center">两个C字符串的内容相同，忽略大小写</td></tr><tr><td align="center">ASSERT_STRCASENE(str1,str2);</td><td align="center">EXPECT_STRCASENE(str1,str2);</td><td align="center">两个C字符串的内容不同，忽略大小写</td></tr></tbody></table><p>注意，断言名称中的“ CASE”表示忽略大小写。一个NULL 指针和一个空字符串被认为是不同的。</p><p><em>STREQ</em>并<em>STRNE</em>接受宽C字符串（wchar_t*）。如果两个宽字符串的比较失败，则它们的值将打印为UTF-8窄字符串。</p><h3 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h3><p>创建测试：</p><ol><li>使用TEST()宏定义和命名测试功能。这些是没有返回值的普通C++函数。</li><li>在此函数，要与包含的所有有效C++语句一起使用各种gtest断言来检查。</li><li>测试结果由断言确定，如果测试中的任何声明失败（致命或非致命），或者测试崩溃，整个测试都会失败，否则测试应当成功。</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TEST(TestSuiteName, TestName) &#123;</span><br><span class="line">  ...测试代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TEST()函数第一个参数是测试套件的名称，第二个参数是测试套件内的测试名称。这两个名称都必须是有效的C++标识符，并且不应包含任何下划线。来自不同测试套件的测试可以具有相同的名称。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><h2 id="qtest"><a href="#qtest" class="headerlink" title="qtest"></a>qtest</h2><p><a href="https://doc.qt.io/qt-5/qtest.html">https://doc.qt.io/qt-5/qtest.html</a></p><h2 id="gtest"><a href="#gtest" class="headerlink" title="gtest"></a>gtest</h2><p><a href="https://github.com/google/googletest/blob/master/googletest/docs/primer.md">https://github.com/google/googletest/blob/master/googletest/docs/primer.md</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文会介绍一下QTest和GTest的一些功能和区别。&lt;/p&gt;</summary>
    
    
    
    <category term="unit test" scheme="https://blog.justforlxz.com/categories/unit-test/"/>
    
    
    <category term="Qt" scheme="https://blog.justforlxz.com/tags/Qt/"/>
    
    <category term="C++" scheme="https://blog.justforlxz.com/tags/C/"/>
    
    <category term="CMake" scheme="https://blog.justforlxz.com/tags/CMake/"/>
    
    <category term="GTest" scheme="https://blog.justforlxz.com/tags/GTest/"/>
    
    <category term="CTest" scheme="https://blog.justforlxz.com/tags/CTest/"/>
    
  </entry>
  
  <entry>
    <title>CPP项目的一些坑</title>
    <link href="https://blog.justforlxz.com/2020/06/15/CPP%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
    <id>https://blog.justforlxz.com/2020/06/15/CPP%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</id>
    <published>2020-06-15T11:11:40.000Z</published>
    <updated>2021-03-04T07:40:49.293Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章记录这几年项目中C++的一些问题和优化方法。需要注意的是，代码优化没有一本万利的方法，只能见招拆招，而且还要避免过早优化等问题，代码优化一定是要中后期才可以，而且不要为了优化而优化。</p><a id="more"></a><h2 id="const和const-amp"><a href="#const和const-amp" class="headerlink" title="const和const &amp;"></a>const和const &amp;</h2><p>在接收一个返回值或者声明局部只读变量时没有使用const修饰。const的目的不仅仅是为了只读，更多的是编译器可以在此处提供优化。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QRect rect = m_displayInter-&gt;primaryRawRect();</span><br><span class="line">qreal scale = qApp-&gt;primaryScreen()-&gt;devicePixelRatio();</span><br></pre></td></tr></table></figure><p>在这两行例子中，react和scale都在当前函数内没有任何修改，而且不应该修改，需要添加const来修饰只读，并且QRect应该使用&amp;来减少内存复制带来的额外影响。</p><h2 id="类型强转"><a href="#类型强转" class="headerlink" title="类型强转"></a>类型强转</h2><p>在部分代码中，经常能看到C风格的代码强转，应当根据具体情况使用static_cast、dynamic_cast和reinterpret_cast。</p><p>static_cast是使用的比较多的cast，经常用于派生类和基类之间转换。dynamic_cast也用于派生类和基类的转换，如果类型T是指针类型，若转换失败，则返回T类型的空指针，如果时T是引用类型，则会抛出异常，返回std::bad_cast。reinterpret_cast并不会做实际的转换，只会在编译时进行检查，如果不能进行cast转换，则编译报错。</p><h2 id="过多的嵌套"><a href="#过多的嵌套" class="headerlink" title="过多的嵌套"></a>过多的嵌套</h2><p>过多的嵌套会严重影响代码阅读，经常出现只有if通过才会进入执行的情况，这种情况应该修改为不通过就不要继续执行，或者安排合理的if将条件限制在之前。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BluetoothWorker::setAdapterPowered</span><span class="params">(<span class="keyword">const</span> Adapter *adapter, <span class="keyword">const</span> <span class="keyword">bool</span> &amp;powered)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QDBusObjectPath <span class="title">path</span><span class="params">(adapter-&gt;id())</span></span>;</span><br><span class="line">    <span class="comment">//关闭蓝牙之前删除历史蓝牙设备列表，确保完全是删除后再设置开关</span></span><br><span class="line">    <span class="keyword">if</span> (!powered) &#123;</span><br><span class="line">        QDBusPendingCall call = m_bluetoothInter-&gt;ClearUnpairedDevice();</span><br><span class="line">        QDBusPendingCallWatcher *watcher = <span class="keyword">new</span> QDBusPendingCallWatcher(call, <span class="keyword">this</span>);</span><br><span class="line">        connect(watcher, &amp;QDBusPendingCallWatcher::finished, [ = ] &#123;</span><br><span class="line">            <span class="keyword">if</span> (!call.isError()) &#123;</span><br><span class="line">                QDBusPendingCall adapterPoweredOffCall  = m_bluetoothInter-&gt;SetAdapterPowered(path, <span class="literal">false</span>);</span><br><span class="line">                QDBusPendingCallWatcher *watcher = <span class="keyword">new</span> QDBusPendingCallWatcher(adapterPoweredOffCall, <span class="keyword">this</span>);</span><br><span class="line">                connect(watcher, &amp;QDBusPendingCallWatcher::finished, [<span class="keyword">this</span>, adapterPoweredOffCall, adapter] &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!adapterPoweredOffCall.isError()) &#123;</span><br><span class="line">                        setAdapterDiscoverable(adapter-&gt;id());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        qWarning() &lt;&lt; adapterPoweredOffCall.error().message();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                qWarning() &lt;&lt; call.error().message();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        QDBusPendingCall adapterPoweredOnCall  = m_bluetoothInter-&gt;SetAdapterPowered(path, <span class="literal">true</span>);</span><br><span class="line">        QDBusPendingCallWatcher *watcher = <span class="keyword">new</span> QDBusPendingCallWatcher(adapterPoweredOnCall, <span class="keyword">this</span>);</span><br><span class="line">        connect(watcher, &amp;QDBusPendingCallWatcher::finished, [<span class="keyword">this</span>, adapterPoweredOnCall, adapter] &#123;</span><br><span class="line">            <span class="keyword">if</span> (!adapterPoweredOnCall.isError()) &#123;</span><br><span class="line">                setAdapterDiscoverable(adapter-&gt;id());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                qWarning() &lt;&lt; adapterPoweredOnCall.error().message();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码其实是可以优化的，我们可以通过三元表达式获取某个QDBusPendingCall，这样就可以使用一个QDBusPendingCallWatcher对象，然后将原本的lambda内容提取到其他函数内，在新的lambda中同样使用三元表达式运行对应的函数，这样拆分代码的好处是，阅读代码时的顺序会和执行顺序一致，分支判断对机器和人类都不是太友好，特别是判断体内有很长的代码段，找到else段是一件不容易的事情，通过降低if else块来提高代码可读性。同时应提取相同动作的代码到公共区域，以免将来修改时发现没有将所有的地方都做修改。</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>避免使用数组的方式来访问元素，使用迭代器的方式统一循环方式。</p><p>我注意到有些情况下，有人在for循环内直接定义静态变量，这种方式使用的时候需要注意，静态变量将会永远存在，但是大部分for循环内需要保存的数据都是成员变量，否则内存空间将永远不会释放，对内存有浪费。</p><p>而且经常遇到的问题就是foreach宏和for混用，在语法上就没有统一使用。</p><p>我推荐的方式是for+迭代器的方式，如果是简单遍历，使用原生的foreach语法即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原生foreach语法，推荐只读遍历使用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> item: <span class="built_in">list</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for+迭代器，只读遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">list</span>.cbegin(); it != <span class="built_in">list</span>.cend(); ++it) &#123;</span><br><span class="line">    <span class="comment">// it是迭代器对象，需要解引用使用。</span></span><br><span class="line">    *it</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for+迭代器方式，推荐需要修改容器的长度使用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">list</span>.begin(); it != <span class="built_in">list</span>.end();) &#123;</span><br><span class="line">    <span class="comment">// 注意，如果要移除某个元素，需要手动下一步</span></span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">2</span>) &#123;</span><br><span class="line">        it = <span class="built_in">list</span>.erase(it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>经常遇到使用容器将指针保存下来的场景，但是当对象被析构或者容器被清空的时候，有时候会忘记删除内部的对象，或者删除了不该删除的对象。对数据的处理应该保持RAII原则，避免直接使用裸指针，而是通过智能指针将指针保存起来，当最后一个对象不再持有智能指针对象时，智能指针会删除持有的对象，完成内存释放。</p><p>智能指针的类型</p><p>智能指针包含有三种：独占指针<code>unique_ptr</code>、共享指针<code>shared_ptr</code>和弱引用指针<code>week_ptr</code>。</p><h3 id="独占指针"><a href="#独占指针" class="headerlink" title="独占指针"></a>独占指针</h3><p>独占指针<code>std::unique_ptr</code>可以避免对象被转移到其他对象中，如果某个对象持有<code>unique_ptr</code>，则该ptr不允许转移给其他对象，但是可以使用<code>std::move</code>来转移控制权，注意这和普通的转移不一样，<code>unique_ptr</code>禁止的是拷贝，但是没有禁止移动，我们可以转移控制转，<code>unique_ptr</code>保证的是只有一个智能指针持有对象。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; p1 = <span class="built_in">std</span>::move(ptr);</span><br></pre></td></tr></table></figure><h3 id="共享指针"><a href="#共享指针" class="headerlink" title="共享指针"></a>共享指针</h3><p>共享指针<code>std::shared_ptr</code>顾名思义是用作共享的，和独占指针不同的是，它支持复制，内部通过引用计数来维持对象的生命周期，当没有任何一个对象持有共享指针时，也就意味着没有任何一个对象可以访问到内部对象了，就可以安全的删除对象，释放内存。</p><h4 id="弱引用指针"><a href="#弱引用指针" class="headerlink" title="弱引用指针"></a>弱引用指针</h4><p>弱引用指针<code>std::week_ptr</code>是为了避免两个共享指针相互持有导致引用计数永远不会归零，导致内存永远不释放而提出的解决方案，具体就是弱引用指针不会导致引用计数增加，但是week_ptr同样不支持复制，必须转换为共享指针<code>std::shared_ptr</code>。</p><h2 id="优化判断条件"><a href="#优化判断条件" class="headerlink" title="优化判断条件"></a>优化判断条件</h2><p>对于常数的判断，尽量使用宏或者定义静态常量来避免直接使用数字或者字符判断。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>发现很多人在需要排序的时候总是使用冒泡算法，我介绍几个比较方便的排序方法。</p><h3 id="使用std-sort"><a href="#使用std-sort" class="headerlink" title="使用std::sort"></a>使用std::sort</h3><p>C++标准库提供了<code>std::sort</code>方法来方便的排序，它有三个参数，第一个参数是容器的begin迭代器，第二个参数是end迭代器，第三个参数接收一个返回值为bool类型的函数，该函数用于实现手动控制排序的判断。</p><p>我们可以提供一个lambda表达式来方便的控制排序，或者提供一个函数指针。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>&#123; <span class="number">10</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::sort(<span class="built_in">list</span>.begin(), <span class="built_in">list</span>.end(), [](<span class="keyword">int</span> num1, <span class="keyword">int</span> num2) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 &lt; num2;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种排序方式是直接对原始容器进行操作的，如果不希望数据成为脏数据，应该先复制一份。</p><h3 id="使用容器"><a href="#使用容器" class="headerlink" title="使用容器"></a>使用容器</h3><p>使用容器的方式比较麻烦一些，我们需要对象自己支持大小比较，或者顺序是外部某个列表列表控制的。</p><p>我们可以使用map将内部数据和标记数据建立映射关系，再通过外部的list或者其他方式，从map中将数据读出来，添加到新的列表容器中，从而完成排序。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="string">&quot;page1&quot;</span>, <span class="string">&quot;page2&quot;</span>, <span class="string">&quot;page3&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;String, QWidget*&gt; <span class="built_in">map</span>;</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> StringList &amp; <span class="built_in">list</span> = QJsonDocument::fromJson(readAll(“order.json”)).toStdList();</span><br><span class="line"></span><br><span class="line">QList&lt;QWidget*&gt; pages;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> QString&amp; key : <span class="built_in">list</span>) &#123;</span><br><span class="line">    pages &lt;&lt; <span class="built_in">map</span>[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇文章记录这几年项目中C++的一些问题和优化方法。需要注意的是，代码优化没有一本万利的方法，只能见招拆招，而且还要避免过早优化等问题，代码优化一定是要中后期才可以，而且不要为了优化而优化。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://blog.justforlxz.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>使用inquirer提供交互式git commit</title>
    <link href="https://blog.justforlxz.com/2020/06/15/%E4%BD%BF%E7%94%A8inquirer%E6%8F%90%E4%BE%9B%E4%BA%A4%E4%BA%92%E5%BC%8Fgit-commit/"/>
    <id>https://blog.justforlxz.com/2020/06/15/%E4%BD%BF%E7%94%A8inquirer%E6%8F%90%E4%BE%9B%E4%BA%A4%E4%BA%92%E5%BC%8Fgit-commit/</id>
    <published>2020-06-15T10:36:19.000Z</published>
    <updated>2021-03-04T07:40:49.413Z</updated>
    
    <content type="html"><![CDATA[<p>公司计划规范所有commit提交，开发部门综合出来了一份模板。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">title（应当使用陈述句，简短的描述这个提交所做的事情）</span><br><span class="line"></span><br><span class="line">Description（详细说明代码的改动，包含代码的实现思路，以及为什么这么做，可能会影响哪些功能。对于代码的审核者，需要从这段描述中能完全理解代码中所有改动的内容）</span><br><span class="line"></span><br><span class="line">Log: 写一段面向于产品的总结性内容，用于自动生成crp上的changlog，需要注意的事，这段描述必须从产品的角度考虑。</span><br><span class="line">Bug: https://xxxxxxxxxxx 对应pms bug的链接</span><br><span class="line">Issue: fix #xx 所修复的bug对于的github issue，其中 &quot;fix #xx&quot;是github关闭issue的规则，此处内容只需要满足github的要求即可，详情请参考 https://help.github.com/en/enterprise/2.16/user/github/managing-your-work-on-github/closing-issues-using-keywords</span><br><span class="line">Task: http://xxxxxxxxxxxx 对应pms任务的链接</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="python-inquirer"><a href="#python-inquirer" class="headerlink" title="python inquirer"></a>python inquirer</h2><p>之前在掘金上看到有人在使用交互式的commit来规范commit信息，觉得用起来挺不错的，刚好符合本次公司的要求，不过原项目是nodejs的，项目里肯定不能让每个开发都安装一个node,所以就找一下代替品，然后就发现了<a href="https://github.com/magmax/python-inquirer">python-inquirer</a>。</p><p>使用起来也非常的方便，通过inquirer.Text、inquirer.List、inquirer.Checkbox就可以创建相应的交互，并把组合好的列表交给inquirer.prompt处理，返回一个对象，内部包含了所有做出的选择。</p><h3 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> inquirer</span><br><span class="line">questions = [</span><br><span class="line">  inquirer.Text(<span class="string">&#x27;name&#x27;</span>, message=<span class="string">&quot;What&#x27;s your name&quot;</span>),</span><br><span class="line">  inquirer.Text(<span class="string">&#x27;surname&#x27;</span>, message=<span class="string">&quot;What&#x27;s your surname&quot;</span>),</span><br><span class="line">  inquirer.Text(<span class="string">&#x27;phone&#x27;</span>, message=<span class="string">&quot;What&#x27;s your phone number&quot;</span>,</span><br><span class="line">                validate=<span class="keyword">lambda</span> _, x: re.match(<span class="string">&#x27;\+?\d[\d ]+\d&#x27;</span>, x),</span><br><span class="line">                )</span><br><span class="line">]</span><br><span class="line">answers = inquirer.prompt(questions)</span><br></pre></td></tr></table></figure><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> inquirer</span><br><span class="line">questions = [</span><br><span class="line">  inquirer.List(<span class="string">&#x27;size&#x27;</span>,</span><br><span class="line">                message=<span class="string">&quot;What size do you need?&quot;</span>,</span><br><span class="line">                choices=[<span class="string">&#x27;Jumbo&#x27;</span>, <span class="string">&#x27;Large&#x27;</span>, <span class="string">&#x27;Standard&#x27;</span>, <span class="string">&#x27;Medium&#x27;</span>, <span class="string">&#x27;Small&#x27;</span>, <span class="string">&#x27;Micro&#x27;</span>],</span><br><span class="line">            ),</span><br><span class="line">]</span><br><span class="line">answers = inquirer.prompt(questions)</span><br></pre></td></tr></table></figure><h3 id="CheckBox"><a href="#CheckBox" class="headerlink" title="CheckBox"></a>CheckBox</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> inquirer</span><br><span class="line">questions = [</span><br><span class="line">  inquirer.Checkbox(<span class="string">&#x27;interests&#x27;</span>,</span><br><span class="line">                    message=<span class="string">&quot;What are you interested in?&quot;</span>,</span><br><span class="line">                    choices=[<span class="string">&#x27;Computers&#x27;</span>, <span class="string">&#x27;Books&#x27;</span>, <span class="string">&#x27;Science&#x27;</span>, <span class="string">&#x27;Nature&#x27;</span>, <span class="string">&#x27;Fantasy&#x27;</span>, <span class="string">&#x27;History&#x27;</span>],</span><br><span class="line">                    ),</span><br><span class="line">]</span><br><span class="line">answers = inquirer.prompt(questions)</span><br></pre></td></tr></table></figure><h2 id="公司的模板"><a href="#公司的模板" class="headerlink" title="公司的模板"></a>公司的模板</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> inquirer</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> Template</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">number_validation</span>(<span class="params">answers, current</span>):</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">int</span>(current)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">empty_validation</span>(<span class="params">answers, current</span>):</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">bool</span>(current)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">no_validation</span>(<span class="params">answers, current</span>):</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addList</span>(<span class="params">name, message, <span class="built_in">list</span></span>):</span></span><br><span class="line">  <span class="keyword">return</span> inquirer.List(name, message, <span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addText</span>(<span class="params">name, message, valid</span>):</span></span><br><span class="line">  <span class="keyword">return</span> inquirer.Text(name, message, validate=valid)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addCheck</span>(<span class="params">_name, _message, _choices</span>):</span></span><br><span class="line">  <span class="keyword">return</span> inquirer.Checkbox(_name, message=_message, choices=_choices)</span><br><span class="line"></span><br><span class="line">questions = [</span><br><span class="line">  addCheck(<span class="string">&quot;action&quot;</span>, <span class="string">&quot;选择非选项&quot;</span>, [<span class="string">&#x27;Bug&#x27;</span>, <span class="string">&#x27;Issue&#x27;</span>, <span class="string">&#x27;Task&#x27;</span>])</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">optinalAnswers = inquirer.prompt(questions)</span><br><span class="line"></span><br><span class="line">questions = [</span><br><span class="line">  addList(<span class="string">&#x27;action&#x27;</span>, <span class="string">&quot;select you action&quot;</span>, [<span class="string">&#x27;fix&#x27;</span>, <span class="string">&#x27;feat&#x27;</span>, <span class="string">&#x27;refactor&#x27;</span>, <span class="string">&#x27;docs&#x27;</span>, <span class="string">&#x27;chore&#x27;</span>, <span class="string">&#x27;style&#x27;</span>, <span class="string">&#x27;pref&#x27;</span>, <span class="string">&#x27;test&#x27;</span>]),</span><br><span class="line">  addText(<span class="string">&quot;module&quot;</span>, <span class="string">&quot;input module name&quot;</span>, no_validation),</span><br><span class="line">  addText(<span class="string">&#x27;title&#x27;</span>, <span class="string">&quot;input title&quot;</span>, empty_validation),</span><br><span class="line">  addText(<span class="string">&#x27;description&#x27;</span>, <span class="string">&quot;input description&quot;</span>, empty_validation),</span><br><span class="line">  addText(<span class="string">&quot;log&quot;</span>, <span class="string">&quot;input log&quot;</span>, empty_validation),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">optinal = &#123;</span><br><span class="line">  <span class="string">&quot;Bug&quot;</span>: addText(<span class="string">&quot;bug&quot;</span>, <span class="string">&quot;input bug id&quot;</span>, number_validation),</span><br><span class="line">  <span class="string">&quot;Issue&quot;</span>: addText(<span class="string">&quot;issue&quot;</span>, <span class="string">&quot;input issue id&quot;</span>, empty_validation),</span><br><span class="line">  <span class="string">&quot;Task&quot;</span>: addText(<span class="string">&quot;task&quot;</span>, <span class="string">&quot;input task id&quot;</span>, number_validation),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">optinalMap = &#123;</span><br><span class="line">  <span class="string">&quot;Bug&quot;</span>: <span class="string">&quot;bug&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Issue&quot;</span>: <span class="string">&quot;issue&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Task&quot;</span>: <span class="string">&quot;task&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> action <span class="keyword">in</span> optinalAnswers[<span class="string">&quot;action&quot;</span>]:</span><br><span class="line">  questions.append(optinal[action])</span><br><span class="line"></span><br><span class="line">answers = inquirer.prompt(questions)</span><br><span class="line"></span><br><span class="line">template = <span class="string">&#x27;$&#123;action&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> answers[<span class="string">&quot;module&quot;</span>]:</span><br><span class="line">  template += <span class="string">&#x27;($&#123;module&#125;)&#x27;</span></span><br><span class="line"></span><br><span class="line">template += <span class="string">&#x27;: $&#123;title&#125;\n\nDescription: $&#123;description&#125;\n\nLog: $&#123;log&#125;\n&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> action <span class="keyword">in</span> optinalAnswers[<span class="string">&quot;action&quot;</span>]:</span><br><span class="line">  template += action + <span class="string">&quot;: $&#123;&quot;</span> + optinalMap[action] + <span class="string">&quot;&#125;\n&quot;</span></span><br><span class="line"></span><br><span class="line">subprocess.run([<span class="string">&quot;git&quot;</span>, <span class="string">&quot;commit&quot;</span>, <span class="string">&quot;-m&quot;</span>, Template(template).substitute(answers)])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="修改git-editor"><a href="#修改git-editor" class="headerlink" title="修改git editor"></a>修改git editor</h3><p>将上面的内容保存到/usr/bin/git-inquirer。</p><p>当我们执行git inquirer的时候就能看到交互，当操作完成后可以看到git log中message已经是按模板填充了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;公司计划规范所有commit提交，开发部门综合出来了一份模板。&lt;/p&gt;
&lt;figure class=&quot;highlight text&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;title（应当使用陈述句，简短的描述这个提交所做的事情）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Description（详细说明代码的改动，包含代码的实现思路，以及为什么这么做，可能会影响哪些功能。对于代码的审核者，需要从这段描述中能完全理解代码中所有改动的内容）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Log: 写一段面向于产品的总结性内容，用于自动生成crp上的changlog，需要注意的事，这段描述必须从产品的角度考虑。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Bug: https://xxxxxxxxxxx 对应pms bug的链接&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Issue: fix #xx 所修复的bug对于的github issue，其中 &amp;quot;fix #xx&amp;quot;是github关闭issue的规则，此处内容只需要满足github的要求即可，详情请参考 https://help.github.com/en/enterprise/2.16/user/github/managing-your-work-on-github/closing-issues-using-keywords&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Task: http://xxxxxxxxxxxx 对应pms任务的链接&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://blog.justforlxz.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>vue-router路由复用后页面没有刷新</title>
    <link href="https://blog.justforlxz.com/2020/06/01/vue-router%E8%B7%AF%E7%94%B1%E5%A4%8D%E7%94%A8%E5%90%8E%E9%A1%B5%E9%9D%A2%E6%B2%A1%E6%9C%89%E5%88%B7%E6%96%B0/"/>
    <id>https://blog.justforlxz.com/2020/06/01/vue-router%E8%B7%AF%E7%94%B1%E5%A4%8D%E7%94%A8%E5%90%8E%E9%A1%B5%E9%9D%A2%E6%B2%A1%E6%9C%89%E5%88%B7%E6%96%B0/</id>
    <published>2020-06-01T10:35:41.000Z</published>
    <updated>2021-03-04T07:40:49.413Z</updated>
    
    <content type="html"><![CDATA[<p>vue-router提供了页面路由功能，可以用来构建单页面应用，在使用vue-router的动态路由匹配的时候，遇到了url变化了，但是页面却没有任何动静的问题，记录一下。</p><a id="more"></a><p>动态路由匹配url变化了，但是组件没有变化是因为vue进行了组件复用，因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会再被调用。所以我们需要手动进行数据刷新。</p><p>我们可以简单的使用watch来监听当前的路由变化，从而实现数据刷新。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; watch &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&quot;./router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// vue2</span></span><br><span class="line">        <span class="comment">// watch: &#123;</span></span><br><span class="line">        <span class="comment">//     $route(to, from) &#123;</span></span><br><span class="line">        <span class="comment">//         // 对路由变化作出响应...</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// vue3</span></span><br><span class="line">        watch(router.currentRoute, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;路由发生了变化&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可以使用2.2中新加的beforeRouteUpdate路由守卫：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    beforeRouteUpdate(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 不要在这里调用next</span></span><br><span class="line">        <span class="comment">// 通过to来判断是否重载数据</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;路由发生了变化&quot;</span>);</span><br><span class="line">    &#125;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是vue3中使用vue-router-next来处理动态路由变化导致页面不刷新的方法。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;vue-router提供了页面路由功能，可以用来构建单页面应用，在使用vue-router的动态路由匹配的时候，遇到了url变化了，但是页面却没有任何动静的问题，记录一下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Web" scheme="https://blog.justforlxz.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>vue3升级遇到的坑</title>
    <link href="https://blog.justforlxz.com/2020/05/31/vue3-upgrade/"/>
    <id>https://blog.justforlxz.com/2020/05/31/vue3-upgrade/</id>
    <published>2020-05-31T21:11:43.000Z</published>
    <updated>2021-03-04T07:40:49.413Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直忙工作上的事，对提高自身能力的事有点落下了，趁着今天把之前思考的一些问题都给解决了，也顺手给自己的VueBlog把vue和webpack都升级到最新的beta版本，然后遇到了很多坑，今天就把坑都记录一下，免的以后忘了。</p><p>VueBlog目前使用的是webpack5 + vue3 + vue-router-next + typescript构建，目的在于替换当前的hexo站点，同样也是一个静态博客生成器，不过和hexo的定位不同，我使用的是单页面设计，而不是给每个页面生成对应的html文件，所以对SEO不友好，以后再想办法吧。</p><a id="more"></a><h2 id="升级Vue3"><a href="#升级Vue3" class="headerlink" title="升级Vue3"></a>升级Vue3</h2><p>首先使用<code>vue add vue-next</code>来升级vue到beta版本，执行以后vue会对代码进行一次转换，将旧版本的一些api转换为新版本。</p><h3 id="App"><a href="#App" class="headerlink" title="App"></a>App</h3><p>例如将main.ts中创建App对象的代码转换为新的，在vue2中，我们通过new Vue()来创建app对象，并调用$mount函数挂在元素。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import App from &quot;.&#x2F;App.vue&quot;;</span><br><span class="line">const app &#x3D; new Vue(App);</span><br><span class="line">app.$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure><p>在vue3中，主体思想都尽量通过函数来进行了，因为可以通过函数的参数和返回值进行类型推导。在vue3中，创建app对象通过createApp函数来进行，再通过mount函数挂载dom元素。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import App from &quot;.&#x2F;App.vue&quot;;</span><br><span class="line">const app &#x3D; createApp(APp);</span><br><span class="line">app.mount(&quot;#app&quot;);</span><br></pre></td></tr></table></figure><h3 id="Vur-Router"><a href="#Vur-Router" class="headerlink" title="Vur Router"></a>Vur Router</h3><p>如果使用的有vue-router之类的插件，使用方法也有一些变化，router也需要通过对应的create函数创建。首先需要先升级vue-router，vue-router的下一个版本叫<a href="https://github.com/vuejs/vue-router-next">vue-router-next</a>。在vue-router中，创建router对象的函数从VueRouter函数改为createRouter。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default router;</span><br></pre></td></tr></table></figure><p>在vue3中则需要使用新的函数返回：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const router &#x3D; createRouter(&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default router;</span><br></pre></td></tr></table></figure><p>内容也改了一部分，可以访问<a href="https://github.com/vuejs/vue-router-next">github</a>仓库来看文档。</p><h3 id="composition-API"><a href="#composition-API" class="headerlink" title="composition API"></a>composition API</h3><p>composition api是vue3提出的核心功能，其核心目的是通过将分散在各处的数据都整合到一个setup函数中进行初始化，并依赖vue的响应式数据改变来完成功能实现。</p><p>在RFC中就有composition api的动机。</p><blockquote><h4 id="更好的逻辑复用与代码组织"><a href="#更好的逻辑复用与代码组织" class="headerlink" title="更好的逻辑复用与代码组织"></a>更好的逻辑复用与代码组织</h4><ol><li>随着功能的增长，复杂组件的代码变得越来越难以阅读和理解。这种情况在开发人员阅读他人编写的代码时尤为常见。根本原因是 Vue 现有的 API 迫使我们通过选项组织代码，但是有的时候通过逻辑关系组织代码更有意义。</li><li>目前缺少一种简洁且低成本的机制来提取和重用多个组件之间的逻辑。<h4 id="更好的类型推导"><a href="#更好的类型推导" class="headerlink" title="更好的类型推导"></a>更好的类型推导</h4>另一个来自大型项目开发者的常见需求是更好的 TypeScript 支持。Vue 当前的 API 在集成 TypeScript 时遇到了不小的麻烦，其主要原因是 Vue 依靠一个简单的 this 上下文来暴露 property，我们现在使用 this 的方式是比较微妙的。（比如 methods 选项下的函数的 this 是指向组件实例的，而不是这个 methods 对象）。</li></ol><p>换句话说，Vue 现有的 API 在设计之初没有照顾到类型推导，这使适配 TypeScript 变得复杂。<br>相比较过后，本 RFC 中提出的方案更多地利用了天然对类型友好的普通变量与函数。用该提案中的 API 撰写的代码会完美享用类型推导，并且也不用做太多额外的类型标注。</p><p>这也同样意味着你写出的 JavaScript 代码几乎就是 TypeScript 的代码。即使是非 TypeScript 开发者也会因此得到更好的 IDE 类型支持而获益。</p><p><a href="https://composition-api.vuejs.org/zh/api.html">composition api</a> 文档官方</p><p><a href="https://composition-api.vuejs.org/zh">vue3 rfc</a> rfc网站</p></blockquote><p>setup函数用起来确实舒服，所有有用的东西都可以放在一块，代码整理也方便，不像以前一样需要分散到各种hook和计算属性、data函数中。但是也有我用起来不舒服的地方，基本类型和对象都需要使用ref函数和reactive函数进行包装，有的时候用起来就各种麻烦，需要多注意一些。不过这个问题倒不是什么大问题，和写c++的时候所有的对象用智能指针包裹一层一样，用多了就习惯了。</p><p>这是一个vue2的经典例子，通过data函数和计算属性来返回不同的数据。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default new Vue(&#123;</span><br><span class="line">    data: function() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            message: &quot;hello&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        reversedMessage: function () &#123;</span><br><span class="line">            return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在vue3中就可以全部集中到setup函数，并且一并返回，模板可以直接使用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; ref, computed &#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">        const message &#x3D; ref(&quot;hello&quot;);</span><br><span class="line">        const reversedMessage &#x3D; computed(() &#x3D;&gt; &#123;</span><br><span class="line">            return message.value.split(&#39;&#39;).reverse().join(&#39;&#39;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return &#123; message, reversedMessage &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出使用setup函数可以将模板所需的内容一块返回，结构更为清晰，vue2的模式也是可以的，只不过侧重点不一样，vue2的目的是一种动作的数据应该被放在一块，而vue3的setup函数则是将数据处理都放在一块，这样对数据的的整理比较方便和集中。</p><h3 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h3><p>props是在组件上注册的自定义属性，当一个值传递给props的时候，它就会成为那个组件的一个property。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;hello v-bind:message&#x3D;&quot;message&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>hello组件可以通过定义props函数来接收自定义属性。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default new Vue(&#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">        message: String</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样就可以在helle.vue中使用message这个属性，不过需要注意的是，hello组件不要修改传递进来的message,否则会破坏数据的流向。</p><p>在vue3中使用会更加方便，因为类型推导更加方便。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Props &#123;</span><br><span class="line">    message?: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">        message: &#123;</span><br><span class="line">            type: String,</span><br><span class="line">            require: false,</span><br><span class="line">            default: &quot;&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    setup(props: Props) &#123;</span><br><span class="line">        const reversedMessage &#x3D; computed(() &#x3D;&gt; &#123;</span><br><span class="line">            if (props.message &#x3D;&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">                return String;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            const innerMessage &#x3D; props.message;</span><br><span class="line">            return innerMessage.split(&#39;&#39;).reverse().join(&#39;&#39;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return &#123; reversedMessage &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在vue3和typescript中使用props需要有一些注意的地方，首先Props里需要设置值可能为空，否则setup函数的签名将无法匹配。其次访问props数据需要开启setup函数的props参数，还有一个context参数，可以访问上下文的内容。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近一直忙工作上的事，对提高自身能力的事有点落下了，趁着今天把之前思考的一些问题都给解决了，也顺手给自己的VueBlog把vue和webpack都升级到最新的beta版本，然后遇到了很多坑，今天就把坑都记录一下，免的以后忘了。&lt;/p&gt;
&lt;p&gt;VueBlog目前使用的是webpack5 + vue3 + vue-router-next + typescript构建，目的在于替换当前的hexo站点，同样也是一个静态博客生成器，不过和hexo的定位不同，我使用的是单页面设计，而不是给每个页面生成对应的html文件，所以对SEO不友好，以后再想办法吧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="web" scheme="https://blog.justforlxz.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript建造者模式</title>
    <link href="https://blog.justforlxz.com/2020/02/01/JavaScript%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://blog.justforlxz.com/2020/02/01/JavaScript%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-02-01T20:52:58.000Z</published>
    <updated>2021-03-04T07:40:49.293Z</updated>
    
    <content type="html"><![CDATA[<p>建造者模式就是指将类的构造和其表示分离开来，调用者可以通过不同的构建过程创造出不同表示的对象。主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，由于需求的变化，这个复杂对象的某些部分经常面临着剧烈的变化，一些基本部件不会变。所以需要将变与不变分离。与抽象工厂的区别：在建造者模式里，有个指导者(Director)，由指导者来管理建造者，用户是与指导者联系的，指导者联系建造者最后得到产品。即建造者模式可以强制实行一种分步骤进行的建造过程。</p><a id="more"></a><h2 id="建造者模式四要素"><a href="#建造者模式四要素" class="headerlink" title="建造者模式四要素"></a>建造者模式四要素</h2><ol><li>产品类Product: 一般是一个较为复杂的对象，也就是说创建对象的过程比较复杂，一般会有较多的代码。</li><li>抽象建造者类Builder: 将建造的具体过程交予它的子类来实现。</li><li>建造者类ConcreateBuilder: 组件产品，返回组件好的产品</li><li>指导类Director: 负责调用适当的建造者来组件产品，指导类一般不与产品类发生依赖关系，与指导类直接交互的是建造者类。</li></ol><h2 id="建造者模式的优点"><a href="#建造者模式的优点" class="headerlink" title="建造者模式的优点"></a>建造者模式的优点</h2><p>建造者模式的封装很好，使用建造者模式可以进行有效的封装变化，在使用建造者模式的场景中，产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指导者类中对整体可以取得比较好的稳定性。</p><p>建造者类也很方便扩展，如果有新的需求，只需要实现一个新的建造者类即可。</p><p>产品类 product.ts</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Product &#123;</span><br><span class="line">    private _name: String;</span><br><span class="line">    public name(): String &#123;</span><br><span class="line">        return this._name;</span><br><span class="line">    &#125;</span><br><span class="line">    public setName(name: String) &#123;</span><br><span class="line">        this._name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象建造类 builder.ts</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Builder &#123;</span><br><span class="line">    _product: Product;</span><br><span class="line">    setName(name: String): Product;</span><br><span class="line">    build(): Product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建造类 concreatebuilder.ts</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ConcreateBuilder implements Builder &#123;</span><br><span class="line">    _product: Product &#x3D; new Product;</span><br><span class="line">    public setName(name: String): Product &#123;</span><br><span class="line">        this._product.setName(name);</span><br><span class="line">        return this._product;</span><br><span class="line">    &#125;</span><br><span class="line">    public build(): Product &#123;</span><br><span class="line">        return this._product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HelloworldBuilder extends ConcreateBuilder &#123;</span><br><span class="line">    public build(): Product &#123;</span><br><span class="line">        this._product.setName(&quot;hello world!&quot;);</span><br><span class="line">        return this._product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指导类 director.ts</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Director &#123;</span><br><span class="line">    private _defaultBuilder: ConcreateBuilder &#x3D; new ConcreateBuilder;</span><br><span class="line">    private _helloworldBuilder: HelloworldBuilder &#x3D; new HelloworldBuilder;</span><br><span class="line">    public buildForDefault(): Product  &#123;</span><br><span class="line">        return this._defaultBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line">    public buildForHelloworld(): Product &#123;</span><br><span class="line">        return this._helloworldBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试运行:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let director &#x3D; new Director();</span><br><span class="line">console.log(director.buildForDefault().name());</span><br><span class="line">console.log(director.buildForHelloworld().name());</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">undefined</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p>通过不同的builder就可以构建不同的对象出来，当需求变动的时候，我们只需要扩展出不同的Builder和Director就可以满足。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;建造者模式就是指将类的构造和其表示分离开来，调用者可以通过不同的构建过程创造出不同表示的对象。主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，由于需求的变化，这个复杂对象的某些部分经常面临着剧烈的变化，一些基本部件不会变。所以需要将变与不变分离。与抽象工厂的区别：在建造者模式里，有个指导者(Director)，由指导者来管理建造者，用户是与指导者联系的，指导者联系建造者最后得到产品。即建造者模式可以强制实行一种分步骤进行的建造过程。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://blog.justforlxz.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Javascript" scheme="https://blog.justforlxz.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Javascript构造器模式</title>
    <link href="https://blog.justforlxz.com/2020/01/31/%E6%B5%85%E8%B0%88Javascript%E6%9E%84%E9%80%A0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://blog.justforlxz.com/2020/01/31/%E6%B5%85%E8%B0%88Javascript%E6%9E%84%E9%80%A0%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-01-31T23:15:23.000Z</published>
    <updated>2021-03-04T07:40:49.421Z</updated>
    
    <content type="html"><![CDATA[<p>为了简化操作，JavaScript提供了new关键字。new关键字用于创建一个用户定义类型的实例，或者具有构造函数的内置对象的实例。</p><a id="more"></a><p>每当我们在一个函数调用前使用new关键字，该函数便会以一种特殊模式——构造模式来运行，在此模式中，JavaScript可以自动完成一些操作。基本上它是指解释器在你的代码中嵌入几行操作代码。</p><p>在JavaScript中，构造函数通常是认为用来实现实例的，但是JavaScript中没有类的概念，但是有特殊的构造函数，通过new关键字来调用定义的构造函数，你可以告诉JavaScript你需要创建一个新对象，并且新对象的成员声明都是构造函数里定义的。在构造函数内部，this引用的是新创建的对象。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function People(name: String, age: Number) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    this.output &#x3D; function() &#123;</span><br><span class="line">        return this.name + &quot;已经&quot; + this.age + &quot;岁了&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let people &#x3D; new People(&quot;justforlxz&quot;, 24);</span><br><span class="line"></span><br><span class="line">console.log(people.output());</span><br></pre></td></tr></table></figure><p>上面是个很简单的构造函数模式，我们从字面上this是people对象，但是其实并不是这样的，new运算符帮助我们生成了this的初始化代码。</p><p>new运算符一共做了三件事：</p><ol><li>创建一个空对象</li><li>将空对象的原型赋值为构造器函数的原型</li><li>更改构造器函数内部的this，将其指向新创建的对象</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let tmp &#x3D; new Object();</span><br><span class="line">tmp.__proto__ &#x3D; People.prototype;</span><br><span class="line">People.call(tmp);</span><br></pre></td></tr></table></figure><p>最后会经过一个判断，如果构造器函数设置了返回值，并且返回值是一个Object类型的话，就直接返回该Object，否则就会返回新创建的空对象。</p><p>总结一下： JavaScript没有类的概念，但是为了实现OOP，就通过new关键字实现对函数进行插入代码来实现对象实例的初始化。构造器模式就是通过一个方法来new出一个对象，这个操作就叫构造器模式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;为了简化操作，JavaScript提供了new关键字。new关键字用于创建一个用户定义类型的实例，或者具有构造函数的内置对象的实例。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://blog.justforlxz.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Javascript" scheme="https://blog.justforlxz.com/tags/Javascript/"/>
    
  </entry>
  
</feed>
