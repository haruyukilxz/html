<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小竹&#39;s blog</title>
  
  <subtitle>永远不要停止思考</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.justforlxz.com/"/>
  <updated>2020-02-24T10:48:36.784Z</updated>
  <id>https://blog.justforlxz.com/</id>
  
  <author>
    <name>小竹</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript建造者模式</title>
    <link href="https://blog.justforlxz.com/2020/02/01/JavaScript%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://blog.justforlxz.com/2020/02/01/JavaScript建造者模式/</id>
    <published>2020-02-01T20:52:58.000Z</published>
    <updated>2020-02-24T10:48:36.784Z</updated>
    
    <content type="html"><![CDATA[<p>建造者模式就是指将类的构造和其表示分离开来，调用者可以通过不同的构建过程创造出不同表示的对象。主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，由于需求的变化，这个复杂对象的某些部分经常面临着剧烈的变化，一些基本部件不会变。所以需要将变与不变分离。与抽象工厂的区别：在建造者模式里，有个指导者(Director)，由指导者来管理建造者，用户是与指导者联系的，指导者联系建造者最后得到产品。即建造者模式可以强制实行一种分步骤进行的建造过程。</p><a id="more"></a><h2 id="建造者模式四要素"><a href="#建造者模式四要素" class="headerlink" title="建造者模式四要素"></a>建造者模式四要素</h2><ol><li>产品类Product: 一般是一个较为复杂的对象，也就是说创建对象的过程比较复杂，一般会有较多的代码。</li><li>抽象建造者类Builder: 将建造的具体过程交予它的子类来实现。</li><li>建造者类ConcreateBuilder: 组件产品，返回组件好的产品</li><li>指导类Director: 负责调用适当的建造者来组件产品，指导类一般不与产品类发生依赖关系，与指导类直接交互的是建造者类。</li></ol><h2 id="建造者模式的优点"><a href="#建造者模式的优点" class="headerlink" title="建造者模式的优点"></a>建造者模式的优点</h2><p>建造者模式的封装很好，使用建造者模式可以进行有效的封装变化，在使用建造者模式的场景中，产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指导者类中对整体可以取得比较好的稳定性。</p><p>建造者类也很方便扩展，如果有新的需求，只需要实现一个新的建造者类即可。</p><p>产品类 product.ts</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Product &#123;</span><br><span class="line">    private _name: String;</span><br><span class="line">    public name(): String &#123;</span><br><span class="line">        return this._name;</span><br><span class="line">    &#125;</span><br><span class="line">    public setName(name: String) &#123;</span><br><span class="line">        this._name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象建造类 builder.ts</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Builder &#123;</span><br><span class="line">    _product: Product;</span><br><span class="line">    setName(name: String): Product;</span><br><span class="line">    build(): Product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建造类 concreatebuilder.ts</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ConcreateBuilder implements Builder &#123;</span><br><span class="line">    _product: Product = new Product;</span><br><span class="line">    public setName(name: String): Product &#123;</span><br><span class="line">        this._product.setName(name);</span><br><span class="line">        return this._product;</span><br><span class="line">    &#125;</span><br><span class="line">    public build(): Product &#123;</span><br><span class="line">        return this._product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HelloworldBuilder extends ConcreateBuilder &#123;</span><br><span class="line">    public build(): Product &#123;</span><br><span class="line">        this._product.setName(&quot;hello world!&quot;);</span><br><span class="line">        return this._product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指导类 director.ts</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Director &#123;</span><br><span class="line">    private _defaultBuilder: ConcreateBuilder = new ConcreateBuilder;</span><br><span class="line">    private _helloworldBuilder: HelloworldBuilder = new HelloworldBuilder;</span><br><span class="line">    public buildForDefault(): Product  &#123;</span><br><span class="line">        return this._defaultBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line">    public buildForHelloworld(): Product &#123;</span><br><span class="line">        return this._helloworldBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试运行:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let director = new Director();</span><br><span class="line">console.log(director.buildForDefault().name());</span><br><span class="line">console.log(director.buildForHelloworld().name());</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">undefined</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p>通过不同的builder就可以构建不同的对象出来，当需求变动的时候，我们只需要扩展出不同的Builder和Director就可以满足。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;建造者模式就是指将类的构造和其表示分离开来，调用者可以通过不同的构建过程创造出不同表示的对象。主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，由于需求的变化，这个复杂对象的某些部分经常面临着剧烈的变化，一些基本部件不会变。所以需要将变与不变分离。与抽象工厂的区别：在建造者模式里，有个指导者(Director)，由指导者来管理建造者，用户是与指导者联系的，指导者联系建造者最后得到产品。即建造者模式可以强制实行一种分步骤进行的建造过程。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://blog.justforlxz.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Javascript" scheme="https://blog.justforlxz.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Javascript构造器模式</title>
    <link href="https://blog.justforlxz.com/2020/01/31/%E6%B5%85%E8%B0%88Javascript%E6%9E%84%E9%80%A0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://blog.justforlxz.com/2020/01/31/浅谈Javascript构造器模式/</id>
    <published>2020-01-31T23:15:23.000Z</published>
    <updated>2020-02-24T10:48:36.836Z</updated>
    
    <content type="html"><![CDATA[<p>为了简化操作，JavaScript提供了new关键字。new关键字用于创建一个用户定义类型的实例，或者具有构造函数的内置对象的实例。</p><a id="more"></a><p>每当我们在一个函数调用前使用new关键字，该函数便会以一种特殊模式——构造模式来运行，在此模式中，JavaScript可以自动完成一些操作。基本上它是指解释器在你的代码中嵌入几行操作代码。</p><p>在JavaScript中，构造函数通常是认为用来实现实例的，但是JavaScript中没有类的概念，但是有特殊的构造函数，通过new关键字来调用定义的构造函数，你可以告诉JavaScript你需要创建一个新对象，并且新对象的成员声明都是构造函数里定义的。在构造函数内部，this引用的是新创建的对象。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function People(name: String, age: Number) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.output = function() &#123;</span><br><span class="line">        return this.name + &quot;已经&quot; + this.age + &quot;岁了&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let people = new People(&quot;justforlxz&quot;, 24);</span><br><span class="line"></span><br><span class="line">console.log(people.output());</span><br></pre></td></tr></table></figure><p>上面是个很简单的构造函数模式，我们从字面上this是people对象，但是其实并不是这样的，new运算符帮助我们生成了this的初始化代码。</p><p>new运算符一共做了三件事：</p><ol><li>创建一个空对象</li><li>将空对象的原型赋值为构造器函数的原型</li><li>更改构造器函数内部的this，将其指向新创建的对象</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let tmp = new Object();</span><br><span class="line">tmp.__proto__ = People.prototype;</span><br><span class="line">People.call(tmp);</span><br></pre></td></tr></table></figure><p>最后会经过一个判断，如果构造器函数设置了返回值，并且返回值是一个Object类型的话，就直接返回该Object，否则就会返回新创建的空对象。</p><p>总结一下： JavaScript没有类的概念，但是为了实现OOP，就通过new关键字实现对函数进行插入代码来实现对象实例的初始化。构造器模式就是通过一个方法来new出一个对象，这个操作就叫构造器模式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了简化操作，JavaScript提供了new关键字。new关键字用于创建一个用户定义类型的实例，或者具有构造函数的内置对象的实例。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://blog.justforlxz.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Javascript" scheme="https://blog.justforlxz.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>2019 Review</title>
    <link href="https://blog.justforlxz.com/2020/01/01/2019review/"/>
    <id>https://blog.justforlxz.com/2020/01/01/2019review/</id>
    <published>2020-01-01T21:25:54.000Z</published>
    <updated>2020-02-24T10:48:36.784Z</updated>
    
    <content type="html"><![CDATA[<p>上一次写年终总结还是18年回家的动车上，可惜写了一半没发表，觉得一年了没有什么能够回想起来的，就又删除了。今年不同了，今年有好多想说的。</p><a id="more"></a><h2 id="脱单"><a href="#脱单" class="headerlink" title="脱单"></a>脱单</h2><p><strong>第一件重要的事是我遇到了生命中的她。</strong></p><p>自从工作以后，我妈天天念叨我的就是找对象，和我预想的没错，上学的时候盼我毕业，毕业以后盼我工作，工作以后盼我找对象结婚，找对象以后盼我赶紧生个娃让她抱。<del>（大家的父母应该都这样）</del></p><h2 id="加薪"><a href="#加薪" class="headerlink" title="加薪"></a>加薪</h2><p>这件事确实也令我挺开心的，我的工资在2019年成功涨到了0.375乔(1乔等于**元  <a href="https://blog.nanpuyue.com" target="_blank" rel="noopener">@nanpuyue</a>)</p><p>涨工资谁不高兴，我估计也就马云不高兴了，毕竟他看不上钱。</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>今年看了很多C++的资料，对C++和编译器都有了更深的了解。想2016年半夜<a href="https://zcc.rs" target="_blank" rel="noopener">@zccrs</a>在家教我编译原理，到现在我可以理解一门语言从设计到实现，再到使用模板完成编译时计算，我走了快三年，这三年里我一直没停下学习的脚步，在学习各种知识，从各种编程语言到各种框架原理，到图形界面的实现。还学习了单元测试，并且<a href="https://hualet.org" target="_blank" rel="noopener">@hualet</a>大佬给我讲了单元测试是什么，以及单元测试的重要性，从那以后我才算真正的了解单元测试的重要性，也使我在写代码的时候注重通过单元测试来保障我的功能。</p><p>去年对深度学习进行了一波学习，今年对Web工程化和TypeScript也学习了一下，也算是对目前最热门的两个领域进行了一定的了解。</p><h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>去年买的TensorFlow看了没一半，今年倒是没买书，开始在微信读书上读书，利用一些空余时间读一点，我也推荐大家多利用空闲时间读读书，少刷抖音和bilibili。</p><ul><li>《TensorFlow》未读完</li><li>《TypeScript实战》正在读</li></ul><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><p>2019年我一共水了15篇文章。</p><ul><li><p>12-26 <a href="https://blog.justforlxz.com/2019/12/26/use-serial-port-debug-deepin-on-archlinux/">在ArchLinux通过串口调试VMware虚拟机中的deepin</a></p></li><li><p>12-26 <a href="https://blog.justforlxz.com/2019/12/26/cpp-sort/">使用标准库std::sort函数进行排序</a></p></li><li><p>12-09 <a href="https://blog.justforlxz.com/2019/12/09/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AA%E5%9D%91%E7%88%B9%E7%9A%84usb%E7%BD%91%E5%8D%A1/">记录一个坑爹的usb网卡</a></p></li><li><p>12-09 <a href="https://blog.justforlxz.com/2019/12/09/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AA%E5%9D%91%E7%88%B9%E7%9A%84usb%E7%BD%91%E5%8D%A1/">使用github actions自动部署hexo文章到html仓库</a></p></li><li><p>12-08 <a href="https://blog.justforlxz.com/2019/12/08/vue-component-props/">Vue父子组件传值 —— props &amp; $emit</a></p></li><li><p>12-08 <a href="https://blog.justforlxz.com/2019/12/08/vue-transitions/">添加Vue动画</a></p></li><li><p>11-25 <a href="https://blog.justforlxz.com/2019/11/25/%E4%BD%BF%E7%94%A8webpack-dev-server%E6%9D%A5%E7%9B%91%E5%90%AC%E9%A1%B9%E7%9B%AE%E5%8F%98%E5%8C%96/">使用webpack-dev-server来监听项目变化</a></p></li><li><p>10-24 <a href="https://blog.justforlxz.com/2019/10/24/%E7%BB%99Archlinux%E5%BC%80%E5%90%AFBFQ%E5%92%8CMuQSS/">给Archlinux开启BFQ和MuQSS</a></p></li><li><p>10-22 <a href="https://blog.justforlxz.com/2019/10/22/%E4%BD%BF%E7%94%A8webpack%E6%89%93%E5%8C%85Vue%E5%92%8CTypeScript/">使用webpack打包Vue和TypeScript</a></p></li><li><p>10-14 <a href="https://blog.justforlxz.com/2019/10/14/webpack%E5%85%A5%E9%97%A8/">webpack入门</a></p></li><li><p>06-16 <a href="https://blog.justforlxz.com/2019/06/16/wsl2%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/">wsl2的使用体验</a></p></li><li><p>06-15 <a href="https://blog.justforlxz.com/2019/06/15/%E5%85%A5%E5%9D%91typescript%E4%BA%86/">入坑typescript了</a></p></li><li><p>05-23 <a href="https://blog.justforlxz.com/2019/05/23/CMake-CTests-for-dde-control-center/">CMake CTests for dde-control-center</a></p></li><li><p>02-21 <a href="https://blog.justforlxz.com/2019/02/21/how-to-use-LNMP-on-deepin/">如何在Deepin上使用LNMP</a></p></li><li><p>02-23 <a href="https://blog.justforlxz.com/2019/01/23/fuck-taobao/">解决用了xposed后淘宝闪退</a></p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019</span><br><span class="line">├── 01</span><br><span class="line">│   └── 23</span><br><span class="line">│       └── fuck-taobao</span><br><span class="line">│           └── index.html</span><br><span class="line">├── 02</span><br><span class="line">│   └── 21</span><br><span class="line">│       └── how-to-use-LNMP-on-deepin</span><br><span class="line">│           └── index.html</span><br><span class="line">├── 05</span><br><span class="line">│   └── 23</span><br><span class="line">│       └── CMake-CTests-for-dde-control-center</span><br><span class="line">│           └── index.html</span><br><span class="line">├── 06</span><br><span class="line">│   ├── 15</span><br><span class="line">│   │   └── 入坑typescript了</span><br><span class="line">│   │       ├── 深度录屏_选择区域_20190615202044.gif</span><br><span class="line">│   │       └── index.html</span><br><span class="line">│   └── 16</span><br><span class="line">│       └── wsl2的使用体验</span><br><span class="line">│           ├── index.html</span><br><span class="line">│           ├── Snipaste_2019-06-16_21-49-15.png</span><br><span class="line">│           └── Snipaste_2019-06-16_21-52-42.png</span><br><span class="line">├── 10</span><br><span class="line">│   ├── 14</span><br><span class="line">│   │   └── webpack入门</span><br><span class="line">│   │       └── index.html</span><br><span class="line">│   ├── 22</span><br><span class="line">│   │   └── 使用webpack打包Vue和TypeScript</span><br><span class="line">│   │       └── index.html</span><br><span class="line">│   └── 24</span><br><span class="line">│       └── 给Archlinux开启BFQ和MuQSS</span><br><span class="line">│           └── index.html</span><br><span class="line">├── 11</span><br><span class="line">│   └── 25</span><br><span class="line">│       └── 使用webpack-dev-server来监听项目变化</span><br><span class="line">│           └── index.html</span><br><span class="line">└── 12</span><br><span class="line">    ├── 08</span><br><span class="line">    │   ├── vue-component-props</span><br><span class="line">    │   │   └── index.html</span><br><span class="line">    │   └── vue-transitions</span><br><span class="line">    │       └── index.html</span><br><span class="line">    ├── 09</span><br><span class="line">    │   ├── 记录一个坑爹的usb网卡</span><br><span class="line">    │   │   └── index.html</span><br><span class="line">    │   └── use-github-actions-to-depoly-hexo</span><br><span class="line">    │       └── index.html</span><br><span class="line">    └── 26</span><br><span class="line">        ├── cpp-sort</span><br><span class="line">        │   └── index.html</span><br><span class="line">        └── use-serial-port-debug-deepin-on-archlinux</span><br><span class="line">            └── index.html</span><br><span class="line"></span><br><span class="line">34 directories, 18 files</span><br></pre></td></tr></table></figure><h2 id="科普视频"><a href="#科普视频" class="headerlink" title="科普视频"></a>科普视频</h2><ol><li>妈咪叔 (一个较真的理工男)</li></ol><p>这个名字我第一眼看到的时候，还以为是个卖母婴的，没想到居然是个搞科普的，而且内容讲的也很好，有数学、物理、化学和天文学。</p><ol start="2"><li>李永乐老师</li></ol><p>以前偶尔看过老师的视频，因为一直都在热榜，所以没想到关注，后来是youtube上看到了，就点了关注，youtube上更新的和bilibili的还不是一样的，看最后结尾的时候youtube的只说youtube帐号关注，而bilibili的是bilibili，有时候还要多个平台去看。</p><ol start="3"><li>萝王二号</li></ol><p>之前在科普区随便看的时候，对生物学产生了一些兴趣，萝王讲的风格我很喜欢，特别是他注重昆虫分类学(骨包皮，皮包骨啊2333)，还有一些辟谣视频。</p><ol start="4"><li>芳斯塔夫 (鬼古)</li></ol><p>也使对生物学产生了一些兴趣，鬼古说以他很中二的风格带领我学习了一波古生物的相关知识(旧日支配者！！！)。</p><ol start="5"><li>木偶君</li></ol><p>和鬼古一样是专门讲古生物的，不过每次结束的比较仓促，突然就结束了。</p><ol start="6"><li>木鱼水心</li></ol><p>木鱼并不是今年才关注的，最开始关注是他做EVA剧场版解析，后来《木鱼说》开始做一些科普，我开始一直关注了。</p><ol start="7"><li>宇宙视觉 (永远不要停止思考)</li></ol><p>一个讲天文的科普up，不过年底的时候换了配音，疑似配音出去单干了。</p><h2 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h2><ol><li>流浪地球</li><li>阿丽塔：战斗天使</li><li>战狼2</li><li>惊奇队长</li><li>复仇者联盟4</li><li>何以为家</li><li>速度与激情： 特别行动</li><li>叶问4</li></ol><h2 id="纪录片"><a href="#纪录片" class="headerlink" title="纪录片"></a>纪录片</h2><ol><li>混沌：数学探秘</li><li>维度：数学漫步</li></ol><h2 id="动漫"><a href="#动漫" class="headerlink" title="动漫"></a>动漫</h2><ol><li>刀剑神域</li><li>紫罗兰永恒花园</li><li>darling in the franxx</li><li>心理测量者</li><li>进击的巨人第三季</li><li>五等分的新娘</li><li>citrus～柑橘味香气～</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一次写年终总结还是18年回家的动车上，可惜写了一半没发表，觉得一年了没有什么能够回想起来的，就又删除了。今年不同了，今年有好多想说的。&lt;/p&gt;
    
    </summary>
    
      <category term="年度总结" scheme="https://blog.justforlxz.com/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="2019" scheme="https://blog.justforlxz.com/tags/2019/"/>
    
  </entry>
  
  <entry>
    <title>使用伪元素创建一个圆点</title>
    <link href="https://blog.justforlxz.com/2020/01/01/%E4%BD%BF%E7%94%A8%E4%BC%AA%E5%85%83%E7%B4%A0%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9C%86%E7%82%B9/"/>
    <id>https://blog.justforlxz.com/2020/01/01/使用伪元素创建一个圆点/</id>
    <published>2020-01-01T11:11:12.000Z</published>
    <updated>2020-02-24T10:48:36.828Z</updated>
    
    <content type="html"><![CDATA[<p>我最早接触到CSS中的伪元素是在一次写背景模糊的时候，CSS中的blur会模糊下面所有的元素，但是可以通过伪元素在before中先模糊，这样下层是没有任何元素的，自然也不会有元素被模糊。</p><p>伪元素就如同它的名字一样，是假的元素，只是CSS引擎在排版的时候创建出来的，在DOM树中是不存在的，所以javascript是没办法操作伪元素的。伪元素分为before和after，可以在元素的前面或者后面创建一个假的元素，伪元素选择器的标志符号是<code>::</code>。</p><ol><li><code>div::before</code> 在div元素的前面创建一个元素，配合content属性一起使用。</li><li><code>div::after</code> 在div元素的后面创建一个元素，配合content属性一起使用。</li></ol><p><img src="/2020/01/01/使用伪元素创建一个圆点/16-57-30%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="1657"></p><p>使用伪元素选择器需要注意一点的是，必须使用content属性，否则将不起任何作用。</p><p>伪元素选择器生效以后，可以在DOM中看到::before或者::after，这里提供一个例子。</p><p>html部分：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        Text</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>css部分：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div::before &#123;</span><br><span class="line">  content: &quot;This is before Text, &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div::after &#123;</span><br><span class="line">  content: &quot;, This is after Text.&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时页面上会看到输出这么一句话，<code>This  is before Text, Text , This is after Text.</code>，并且使用鼠标只能选择到最中间的Text文本。</p><p><img src="/2020/01/01/使用伪元素创建一个圆点/16-57-16%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="1657"></p><p>代码可以点击<a href="https://jsfiddle.net/justforlxz/shg21kvb/18/" target="_blank" rel="noopener">这里</a>查看。</p><p>今天写这篇文章呢，是因为今天我在实现hexo的Next主题，看到它在列表中使用after创建了一个小圆点，并且我遇到了一个问题，所以写这篇文章记录一下。</p><p>Next用的是浮动布局来实现的，而我决定flex一把梭，整体布局是垂直的flex，首页、分类等列表内部是用水平的inline-flex实现的，最左边是图标，来自fortawesome，中间的文本使用span包裹一下，实现左对齐，然后通过伪元素在最右边创建一个小圆点，设置a元素的宽度为100%，就可以实现圆点在最右边。</p><p>坑就是在这里遇到的，如果a元素的宽度设置为100%，伪元素创建的小圆点就不能完全显示，少1像素或者多1像素就可以完全显示。最终的解决办法是给小圆点的周围增加了1像素的padding解决了，但是原因位置，谁看到这篇文章并且恰好知道原因的，还请帮忙评论回复一下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;site-nav&quot;&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;item in items&quot; v-bind:key=&quot;item.title&quot;&gt;</span><br><span class="line">      &lt;a v-bind:href=&quot;item.link&quot;&gt;</span><br><span class="line">        &lt;span id=&quot;menu-left&quot; v-bind:class=&quot;item.class&quot;&gt;&lt;/span&gt;</span><br><span class="line">        &lt;span id=&quot;menu-text&quot;&gt;</span><br><span class="line">          &#123;&#123; item.title &#125;&#125;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">      &lt;/a&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#site-nav &#123;</span><br><span class="line">  background: white;</span><br><span class="line">  padding: 20px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ul &#123;</span><br><span class="line">  margin: 0;</span><br><span class="line">  padding: 0 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#site-nav li &#123;</span><br><span class="line">  list-style-type: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#site-nav li a &#123;</span><br><span class="line">  padding: 5px 0px;</span><br><span class="line">  text-align: left;</span><br><span class="line">  line-height: inherit;</span><br><span class="line">  transition-property: background-color;</span><br><span class="line">  transition-duration: 0.2s;</span><br><span class="line">  transition-timing-function: ease-in-out;</span><br><span class="line">  transition-delay: 0s;</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: space-between;</span><br><span class="line">  align-items: center;</span><br><span class="line">  text-decoration: none;</span><br><span class="line">  font-size: 13px;</span><br><span class="line">  border-bottom: 1px solid transparent;</span><br><span class="line">  color: #555;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#site-nav li a:hover &#123;</span><br><span class="line">  background: #f9f9f9;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#menu-left &#123;</span><br><span class="line">  align-content: center;</span><br><span class="line">  margin-left: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#menu-text &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  margin-left: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#site-nav li a::after &#123;</span><br><span class="line">  content: &apos; &apos;;</span><br><span class="line">  background: #bbb;</span><br><span class="line">  width: 6px;</span><br><span class="line">  height: 6px;</span><br><span class="line">  border-radius: 50%;</span><br><span class="line">  margin: 0 10px 0 0;</span><br><span class="line">  min-width: 6px;</span><br><span class="line">  min-height: 6px;</span><br><span class="line">  max-height: 6px;</span><br><span class="line">  max-width: 6px;</span><br><span class="line">  display: block;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我提取了基本结构和css，demo是能够正常显示小圆点的，但是自己的Vue却不能正常显示，后来发现是display写成块级元素用的flex了，改成inline-flex就能正常显示了，但是在调整宽度的时候，就发现了上面的问题，它又不正常显示了，实在解决不了了，就用padding处理了。</p><p>参考资料： <a href="https://github.com/qianguyihao/Web/blob/master/02-CSS%E5%9F%BA%E7%A1%80/10-CSS3%E9%80%89%E6%8B%A9%E5%99%A8%E8%AF%A6%E8%A7%A3.md" target="_blank" rel="noopener">千古壹号</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我最早接触到CSS中的伪元素是在一次写背景模糊的时候，CSS中的blur会模糊下面所有的元素，但是可以通过伪元素在before中先模糊，这样下层是没有任何元素的，自然也不会有元素被模糊。&lt;/p&gt;
&lt;p&gt;伪元素就如同它的名字一样，是假的元素，只是CSS引擎在排版的时候创建出来
      
    
    </summary>
    
      <category term="Web" scheme="https://blog.justforlxz.com/categories/Web/"/>
    
    
      <category term="CSS" scheme="https://blog.justforlxz.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>在ArchLinux通过串口调试VMware虚拟机中的deepin</title>
    <link href="https://blog.justforlxz.com/2019/12/26/use-serial-port-debug-deepin-on-archlinux/"/>
    <id>https://blog.justforlxz.com/2019/12/26/use-serial-port-debug-deepin-on-archlinux/</id>
    <published>2019-12-26T17:26:13.000Z</published>
    <updated>2020-02-24T10:48:36.824Z</updated>
    
    <content type="html"><![CDATA[<p>电脑主板上的接口：进行串行传输的接口，它一次只能传输1Bit。串行端口可以用于连接外置调制解调器、绘图仪或串行打印机。它也可以控制台连接的方式连接网络设备，例如路由器和交换机，主要用来配置它们。消费性电子已经由USB取代串列接口；但在非消费性用途，如网络设备等，串列接口仍是主要的传输控制方式。</p><a id="more"></a><p>首先给虚拟机分配一个串口设备，选择Settings-&gt;Add-&gt;Serial Port。分配好串口设备以后，我们需要选择一个串口设备的调试方式，一个是将输出转向一个文件，或者是通过socket。</p><p>如果只是查看方式，选择outpu file即可。如果需要调试，则可以通过socket方式来进行。</p><p>socket方式需要给一个固定的路径分配/tmp/<socket>，我调试的时候给出的是/tmp/vhost，From选择Server，To选择An Application。From的意思是信息从哪里来，信息是虚拟机里的系统发出的，所以这里选择的是Server，如果是反向操作，需要选择Client。To也是有两个选项，第一个是An Virtual Machine，第二个是An Application。用于把消息发送给另外的虚拟机，或者是宿主机的一个应用程序。</socket></p><p>安装minicom包，用于进行调试，minicom这个东西，不是太好用，退出方式是先按Ctrl+A，然后按q，有时候还不一定管用，不知道是没接受到，还是按错了。</p><p>先minicom -s 进行初始化，选择<code>Serial port setup</code>，按A编辑<code>Serial Device</code>，这里需要注意一下，通过socket进行调试，需要使用<code>unix#</code>前缀，然后加上在虚拟机里写的路径 <code>unix#/tmp/vhost</code>。然后保存，选择Exit，退出以后其实重启minicom，就进入minicom的调试界面了，然后此时开启虚拟机，给内核添加一个console=ttyS0的参数，就看到minicom显示输出的信息了，还可以交互。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[    3.855725] [drm:vmw_fb_setcolreg [vmwgfx]] *ERROR* Bad regno 254.</span><br><span class="line">[    3.857125] [drm:vmw_fb_setcolreg [vmwgfx]] *ERROR* Bad regno 255.</span><br><span class="line">deepin Login:</span><br><span class="line"></span><br><span class="line">CTRL-A Z for help | unix-socket | NOR | Minicom 2.7.1 | VT102 | Offline | unix#/tmp/vhost</span><br></pre></td></tr></table></figure><p>此时就可以交互了，用法和tty一样，最后一行是minicom的输出，可以看到CTRL-A Z可以看help，minicom的版本，和访问的串口socket。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;电脑主板上的接口：进行串行传输的接口，它一次只能传输1Bit。串行端口可以用于连接外置调制解调器、绘图仪或串行打印机。它也可以控制台连接的方式连接网络设备，例如路由器和交换机，主要用来配置它们。消费性电子已经由USB取代串列接口；但在非消费性用途，如网络设备等，串列接口仍是主要的传输控制方式。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://blog.justforlxz.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://blog.justforlxz.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用标准库std::sort函数进行排序</title>
    <link href="https://blog.justforlxz.com/2019/12/26/cpp-sort/"/>
    <id>https://blog.justforlxz.com/2019/12/26/cpp-sort/</id>
    <published>2019-12-26T17:24:23.000Z</published>
    <updated>2020-02-24T10:48:36.784Z</updated>
    
    <content type="html"><![CDATA[<p>std的sort方法接受两个迭代器begin和end。通过迭代器来抽象元素的访问，隐藏内部实现。</p><a id="more"></a><p>这是一个简单的例子:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::list&lt;int&gt; list &#123;</span><br><span class="line">    0,</span><br><span class="line">    4,</span><br><span class="line">    2,</span><br><span class="line">    1,</span><br><span class="line">    3,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::sort(list.begin(), list.end());</span><br></pre></td></tr></table></figure><p>结果就是list被排序了，至于使用了什么排序算法，我们并不需要关心。实际上标准库会通过元素的数量来决定使用什么算法，基于Introspective Sorting(内省式排序)。<br>它是一种混合式的排序算法：</p><ul><li><p>在数据量很大时采用正常的快速排序，此时效率为O(logN)。</p></li><li><p>一旦分段后的数据量小于某个阈值，就改用插入排序，因为此时这个分段是基本有序的，这时效率可达O(N)。</p></li><li><p>在递归过程中，如果递归层次过深，分割行为有恶化倾向时，它能够自动侦测出来，使用堆排序来处理，在此情况下，使其效率维持在堆排序的O(N logN)，但这又比一开始使用堆排序好。</p></li></ul><p>默认情况下排序是升序排序，既结果从小到大，我们可以通过使用std::equal_to<t>、std::not_equal_to<t>、std::greater<t>、std::less<t>、std::greater_equal<t>和std::less_equal<t>来控制排序。</t></t></t></t></t></t></p><p>以上是通过标准库内置的一些方式来控制排序，且适用于元素已实现了自定义比较(Compare)的要求。</p><p>比较 (Compare) 是一些标准库设施针对用户提供的函数对象类型所期待的一组要求。</p><p>对满足比较 (Compare) 的类型的对象运用函数调用操作的返回值，当按语境转换成 bool 时，若此类型所引入的严格弱序关系中，该调用的第一实参先于第二实参，则生成 true，否则生成 false。</p><p>与任何二元谓词 (BinaryPredicate) 相同，不允许该表达式的求值通过解引用的迭代器调用非 const 函数。</p><p>用人话来说就是，Compare必须提供出对比结果。</p><p>看一个例子:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Test &#123;</span><br><span class="line">    int i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::list&lt;Test&gt; list &#123;</span><br><span class="line">    new Test(2),</span><br><span class="line">    new Test(1),</span><br><span class="line">    new Test(4),</span><br><span class="line">    new Test(3),</span><br><span class="line">    new Test(5),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::sort(list.begin(), list.end(), [=] (const Test&amp; test1, const Test&amp; test2) -&gt; bool &#123;</span><br><span class="line">    return test1.i &lt; test2.i;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个例子提供了一个Compare，通过lambda来提供自定义的对比函数，返回值必须是bool，否则将不满足对比函数的要求。</p><p>通过以上三种方式可以看出，标准库的sort函数可以很方便的为使用者提供标准对比和自定义对比。如果元素自己已实现operator&lt;，则只需要使用标准库内置的对比函数即可，但是大部分情况其实并不会涉及到元素的排序，仅在临时情况下需要列表有序，所以我个人倾向于通过lambda提供Compare函数来完成列表的排序。</p><p><a href="https://zh.cppreference.com/w/cpp/algorithm/sort" target="_blank" rel="noopener">std::sort</a><br><a href="http://feihu.me/blog/2014/sgi-std-sort/" target="_blank" rel="noopener">知无涯之std::sort源码剖析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;std的sort方法接受两个迭代器begin和end。通过迭代器来抽象元素的访问，隐藏内部实现。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>记录一个坑爹的usb网卡</title>
    <link href="https://blog.justforlxz.com/2019/12/09/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AA%E5%9D%91%E7%88%B9%E7%9A%84usb%E7%BD%91%E5%8D%A1/"/>
    <id>https://blog.justforlxz.com/2019/12/09/记录一个坑爹的usb网卡/</id>
    <published>2019-12-09T19:31:04.000Z</published>
    <updated>2020-02-24T10:48:36.836Z</updated>
    
    <content type="html"><![CDATA[<p>网卡型号是Realtek RTL8811CU/RTL8821CU USB Wi-Fi adapter，买来是为了让黑苹果上网的，windows下也会自动下载和安装驱动，但是linux比较难受，内核不提供这样的驱动，只能去官方拿源码搞，今天在arch上打算装一下驱动，结果遇到了很多问题。</p><p>wiki上推荐的8821应该使用rtl88xxau-aircrack-dkms-git，但是我安装以后压根不能用，一点变化都没有，而且modprobe也没有作者给出的88XXau，无奈只得放弃。</p><p>继续谷歌之，在<a href="https://forum.mxlinux.org/viewtopic.php?f=107&t=50579" target="_blank" rel="noopener">https://forum.mxlinux.org/viewtopic.php?f=107&amp;t=50579</a>看到了别人给的方案，然后果断clone并make,然后就因为没有适配5.x的内核编译失败，这可不行，翻了一下issue，看到作者在<a href="https://github.com/whitebatman2/rtl8821CU/issues/33" target="_blank" rel="noopener">https://github.com/whitebatman2/rtl8821CU/issues/33</a>提到了一个<a href="https://github.com/whitebatman2/rtl8821CU/issues/23" target="_blank" rel="noopener">#23</a>，这标题写的够可以，<code>Newer version 5.4.1 (Support Linux versions from 4.4.x up to 5.4.x)</code>，赶紧搞起，去源地址clone和make,成功使用上了驱动，按照作者提到的安装<code>usb_modeswitch</code>，并切换usb模式，我成功的使用上了这个usb网卡。</p><blockquote><p>吐槽一下，开发环境还是linux下舒服，仓库的包安装一下就可以开发了，windows下要自己写路径，mac下brew限制太死，一些库安装以后还要自己手动做些处理，一不小心就把shell的环境变量搞不行了，或者压根不能正常工作。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网卡型号是Realtek RTL8811CU/RTL8821CU USB Wi-Fi adapter，买来是为了让黑苹果上网的，windows下也会自动下载和安装驱动，但是linux比较难受，内核不提供这样的驱动，只能去官方拿源码搞，今天在arch上打算装一下驱动，结果遇到
      
    
    </summary>
    
      <category term="Linux" scheme="https://blog.justforlxz.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://blog.justforlxz.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用github actions自动部署hexo文章到html仓库</title>
    <link href="https://blog.justforlxz.com/2019/12/09/use-github-actions-to-depoly-hexo/"/>
    <id>https://blog.justforlxz.com/2019/12/09/use-github-actions-to-depoly-hexo/</id>
    <published>2019-12-09T13:19:11.000Z</published>
    <updated>2020-02-24T10:48:36.824Z</updated>
    
    <content type="html"><![CDATA[<p>请先允许我大喊一声：微软牛逼！</p><p>本文没有啥含金量，就是简单的说一下如何部署github-actions来自动生成hexo的public，并且再推送到html仓库的。</p><p>我的博客仓库一共分为两个，blog仓库是私有的，需要通过我的私钥才能访问，html仓库是公开的，hexo生成的静态内容会被上传到这里。</p><p>首先在package.json中添加一些命令，方便我们一键编译和提交:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;build&quot;: &quot;hexo clean &amp;&amp; hexo g&quot;,</span><br><span class="line">  &quot;deploy&quot;: &quot;yarn run build &amp;&amp; hexo d&quot;,</span><br><span class="line">  &quot;backup&quot;: &quot;hexo b&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为CI环境需要提交代码到仓库，所以申请一个个人用的token，访问<a href="https://github.com/settings/tokens" target="_blank" rel="noopener">https://github.com/settings/tokens</a>创建一个新的，勾选上<code>repo</code>，生成完token以后，修改一下<code>_config.yml</code>中对deploy仓库的url，格式固定为<code>https://x-access-token:你的token@github.com/你的名字/仓库名.git</code>,例如我这里是<code>https://x-access-token:xxxxxxxxxx@github.com/justforlxz/html.git</code>。</p><p>然后新家一个github actions，选择nodejs环境，我们只需要修改最后一个步骤，执行我们自己的命令即可。</p><ul><li>设置git的用户名和邮箱地址</li><li>npm install -g yarn</li><li>yarn run deploy</li></ul><p>如果你还有一些其他步骤，可以自行扩展，比如我就有主题相关的操作，具体的内容如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- name: npm install, build, and deploy</span><br><span class="line">  run: |</span><br><span class="line">    git config --global user.email &quot;justforlxz@gmail.com&quot;</span><br><span class="line">    git config --global user.name &quot;justforlxz&quot;</span><br><span class="line">    git submodule update --init</span><br><span class="line">    cd themes/next</span><br><span class="line">    git checkout dev</span><br><span class="line">    cd ../../</span><br><span class="line">    npm install -g yarn</span><br><span class="line">    yarn</span><br><span class="line">    yarn run deploy</span><br></pre></td></tr></table></figure><p>然后就可以愉快的自动部署了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;请先允许我大喊一声：微软牛逼！&lt;/p&gt;
&lt;p&gt;本文没有啥含金量，就是简单的说一下如何部署github-actions来自动生成hexo的public，并且再推送到html仓库的。&lt;/p&gt;
&lt;p&gt;我的博客仓库一共分为两个，blog仓库是私有的，需要通过我的私钥才能访问，htm
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue父子组件传值 —— props &amp; $emit</title>
    <link href="https://blog.justforlxz.com/2019/12/08/vue-component-props/"/>
    <id>https://blog.justforlxz.com/2019/12/08/vue-component-props/</id>
    <published>2019-12-08T21:08:00.000Z</published>
    <updated>2020-02-24T10:48:36.824Z</updated>
    
    <content type="html"><![CDATA[<p>Vue的父子组件传值比较有意思，父组件通过属性绑定，把自身的值和子组件的一个属性绑定起来，子组件通过props属性接收，该属性类型为数组，是Vue对象中比较少有的类型，data、computer、methods等方法都是对象的形式，props则是数组的形式。父组件通过v-on来监听子组件发出的事件来接收子组件的调用。在这里我是理解成子组件发送信号来通知上层，毕竟调用的是this.$emit来做到的。</p><a id="more"></a><p>我们假设子组件名为<hello>，我们通过v-bind来绑定一个值给它。</hello></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=&quot;#app&quot;&gt;</span><br><span class="line">        // 通过v-bind绑定父子组件的属性</span><br><span class="line">        &lt;hello v-bind:messageFromParent=&quot;message&quot;/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">import Hello from &apos;./Hello.vue&apos;;</span><br><span class="line">export default Vue.extend(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: &quot;this message from parent&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        &quot;hello&quot;: Hello</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>子组件hello.vue通过props属性接收，内容是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &#123;&#123; messageFromParent &#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">export default Vue.extend(&#123;</span><br><span class="line">    // 通过props数组接收</span><br><span class="line">    props: [ &quot;messageFromParent&quot; ]</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这里有个需要注意的地方，父组件给子组件的数据是单向的，虽然子组件也可以修改父组件传入的数据，但是会产生一个错误，并打印在终端里。</p><p>那么我们怎么才能修改父组件的值呢？答案是<code>this.$emit</code>。</p><p>我们给子组件绑定上v-on，来监听子组件的事件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=&quot;#app&quot;&gt;</span><br><span class="line">        // 通过v-bind绑定父子组件的属性，通过v-on监听子组件的属性变化</span><br><span class="line">        &lt;hello v-bind:messageFromParent=&quot;message&quot; v-on:changeParentData=&quot;changeData&quot;/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">import Hello from &apos;./Hello.vue&apos;;</span><br><span class="line">export default Vue.extend(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: &quot;this message from parent&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        &quot;hello&quot;: Hello</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        changeData: function(data: string) &#123;</span><br><span class="line">            message = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>子组件只需要发送出修改即可：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;button v-on:click=&quot;change&quot;&gt;修改父组件数据&lt;/button&gt;</span><br><span class="line">        &#123;&#123; messageFromParent &#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">export default Vue.extend(&#123;</span><br><span class="line">    // 通过props数组接收</span><br><span class="line">    props: [ &quot;messageFromParent&quot; ],</span><br><span class="line">    methods: &#123;</span><br><span class="line">        change: function() &#123;</span><br><span class="line">            // 调用this.$emit方法第一个参数是事件的名称，后面全部都是参数。</span><br><span class="line">            // this.$emit方法其实是自定义了一个事件，通过这种方式来完成子组件向父组件传递消息。</span><br><span class="line">            this.$emit(&quot;changeParentData&quot;, &quot;change data by child&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>以上就是Vue父子组件传值的一种常用方法，适用于相邻组件的，如果隔代了，那么这种方式就不好用了，中间路过的组件都需要转发这个事件，处理这种情况就需要使用<code>provide/ inject</code>了，不过那就是另一篇文章啦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue的父子组件传值比较有意思，父组件通过属性绑定，把自身的值和子组件的一个属性绑定起来，子组件通过props属性接收，该属性类型为数组，是Vue对象中比较少有的类型，data、computer、methods等方法都是对象的形式，props则是数组的形式。父组件通过v-on来监听子组件发出的事件来接收子组件的调用。在这里我是理解成子组件发送信号来通知上层，毕竟调用的是this.$emit来做到的。&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://blog.justforlxz.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://blog.justforlxz.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>添加Vue动画</title>
    <link href="https://blog.justforlxz.com/2019/12/08/vue-transitions/"/>
    <id>https://blog.justforlxz.com/2019/12/08/vue-transitions/</id>
    <published>2019-12-08T08:03:40.000Z</published>
    <updated>2020-02-24T10:48:36.824Z</updated>
    
    <content type="html"><![CDATA[<p>以前一直搞不懂动画是怎么做的，它怎么这么神奇，写了一点看不懂的代码，就实现了非常丰富的效果，现在做了三年Qt开发，接触到了Qt的动画类，明白了动画是怎么一会儿事，现在来看当初的css动画代码，也明白了它是如何工作的了。本文会介绍一下Vue提供的组件过渡动画模块——transitions。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Vue在插入、更新和移除DOM元素时，提供了多种不同方式的应用过渡效果。包含以下工具：</p><ul><li>在css过渡和动画中自动应用class</li><li>可以配合第三方动画css类，例如Animae.css</li><li>提供钩子函数来使JS操作DOM元素</li><li>可以配合使用第三方JavaScript动画库，例如Velocity.js</li></ul><h2 id="单元素-组件过渡"><a href="#单元素-组件过渡" class="headerlink" title="单元素/组件过渡"></a>单元素/组件过渡</h2><p>Vue提供了 <code>transitions</code> 的封装组件，在下面的情况中，可以给任意元素或组件添加进入和离开的过渡效果。</p><ul><li>条件渲染 (使用 <code>v-show</code>)</li><li>按需渲染 (使用 <code>v-if</code>)</li><li>动态节点</li><li>组件根元素</li></ul><p>这是一个基本的例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;button v-on:click=&quot;show = !show&quot;&gt;</span><br><span class="line">    Toggle</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">    &lt;transitions name=&quot;fade&quot;&gt;</span><br><span class="line">        &lt;p v-if=&quot;show&quot;&gt; hello! &lt;/p&gt;</span><br><span class="line">    &lt;transitions&gt;</span><br><span class="line">&lt;div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: &quot;#app&quot;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        show: false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在head中添加style：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.fade-enter-active,</span><br><span class="line">.fade-leave-active &#123;</span><br><span class="line">  transition: opacity .5s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.fade-enter,</span><br><span class="line">.fade-leave-to &#123;</span><br><span class="line">  opacity: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有三点需要注意一下，需要动画的元素需要使用transitions节包裹起来，transitions需要一个name，css中需要使用固定的拼写来应用动画，入场动画和离场动画的状态是一致的，所以写在了一组里。</p><p>当插入和删除包含在 <code>transitions</code> 组件中的元素时，Vue会做以下的事情：</p><ul><li>自动嗅探组件是否应用了css的过渡或动画，如果有，则在恰当的实际添加/删除css类名。</li><li>如果 <code>transitions</code> 组件提供了钩子函数，Vue会在恰当的时机调用钩子函数。</li><li>如果没有找到css过渡和动画，也没有找到钩子函数，则DOM的操作(插入和删除)在下一帧中立即执行。(注意是指浏览器的逐帧动画，而不是Vue的nextTick机制)</li></ul><h3 id="过渡的类名"><a href="#过渡的类名" class="headerlink" title="过渡的类名"></a>过渡的类名</h3><p>Vue的过渡动画一共有6个状态：</p><ol><li><code>v-enter</code>: 定义进入过渡的开始状态，在元素被插入之前生效，待元素插入以后被移除。</li><li><code>v-enter-active</code>: 定义进入过渡生效时的状态，在整个进入过渡的阶段中应用，在元素插入之前生效，在过渡/动画完成后被移除。这个类可以定义过渡时间、延迟和动画曲线。</li><li><code>v-enter-to</code>: <strong>在2.1.8版本及以上</strong> 定义进入过渡的结束状态，在元素被插入的下一帧生效(与此同时 <code>v-enter</code> 被移除)，在过渡/动画完成后移除。</li><li><code>v-leave</code>: 定义离开过渡的开始状态，在离开过渡被触发时立即生效，下一帧被移除。</li><li><code>v-leave-active</code>: 定义离开过渡生效时的状态，在整个离开过渡的阶段中应用，在离开过渡触发时立即生效，在过渡/动画完成后立即被移除。这个类可以定义离开过渡的过程时间、延迟和动画曲线。</li><li><code>v-leave-to</code>: <strong>在2.1。8版本及以上</strong> 定义离开过渡的结束状态，在离开过渡被触发之后的下一帧被移除(与此同时<code>v-leave</code>也被删除)<br>，在过渡/动画完成之后移除。</li></ol><p><img src="https://cn.vuejs.org/images/transition.png" alt="transitions"></p><p>可以看出一共两组动画，进入和离开的active。并且分别有两个状态，enter和enter-to，这6个状态控制了入场动画和离场动画。(吐槽一下Qt的动画系统，定义一个QAnimation只能做半场动画，想做到Vue这样的要定义两组，或者反向播放)</p><p>对于那些正在过渡中切换的类名来说，如果使用了没有<code>name</code>属性的<code>transition</code>，Vue会使用v-当做默认前缀。为了避免多组动画冲突，我个人建议每一个<code>transition</code>组件都提供name属性。</p><h3 id="JavaScript钩子函数"><a href="#JavaScript钩子函数" class="headerlink" title="JavaScript钩子函数"></a>JavaScript钩子函数</h3><p><code>transition</code>也提供了钩子函数，使我们可以通过JavaScript来控制DOM元素，一共也包含了8个函数：</p><ol><li>beforeEnter</li><li>enter</li><li>afterEnter</li><li>enterCancelled</li><li>beforeLeave</li><li>leave</li><li>afterLeave</li><li>leaveCancelled</li></ol><p>和css上要求的命名保持一致，只是增加了两个取消的接口，当动画被取消的时候被调用。</p><p>这些钩子函数可以结合CSS <code>transition/animations</code> 使用，也可以单独使用。</p><blockquote><p>当只使用JavaScript过渡的时候，必须在 <strong>enter</strong> 和 <strong>leave</strong> 显式调用<code>done()</code>进行回调，否则他们将被同步调用，过渡会立即完成。</p></blockquote><blockquote><p>推荐对于仅使用JavaScript过渡的元素添加<code>v-bind:css=&quot;false&quot;</code>，Vue会跳过CSS的检测，这也可以避免过渡过程中css的影响。</p></blockquote><h2 id="列表元素的过渡"><a href="#列表元素的过渡" class="headerlink" title="列表元素的过渡"></a>列表元素的过渡</h2><p>以上我分享的都是单元素/组件的过渡，那么问题来了，列表这种通过v-for创建的元素该如何增加过渡效果呢？</p><p>Vue提供了<code>&lt;transition-group&gt;</code>组件，在深入了解之前，需要先介绍一下这个组件的一些特点：</p><ul><li>不同于<code>&lt;transition&gt;</code>，<code>&lt;transition-group&gt;</code>会创建一个真实的DOM元素，默认是<span>，可以通过tag属性切换为其他元素。</span></li><li>过渡模式不再可用，因为我们不再相互切换特有的元素</li><li>内部元素总是需要提供唯一的key值来进行区分</li><li>CSS过渡将会应用在内部的元素中，而不是这个组/容器本身</li></ul><h3 id="列表的进入-离开过渡"><a href="#列表的进入-离开过渡" class="headerlink" title="列表的进入/离开过渡"></a>列表的进入/离开过渡</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">&lt;button v-on:click=&quot;add&quot;&gt;add&lt;/button&gt;</span><br><span class="line">&lt;button v-on:click=&quot;remove&quot;&gt;remove&lt;/button&gt;</span><br><span class="line">&lt;transition-group name=&quot;group&quot; tag=&quot;ul&quot;&gt;</span><br><span class="line">&lt;li v-for=&quot;item in items&quot; v-bind:key=&quot;item&quot;&gt;</span><br><span class="line">  &#123;&#123; item &#125;&#125;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;/transition-group&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">el: &quot;#app&quot;,</span><br><span class="line">data: &#123;</span><br><span class="line">items: [1,2,3]</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">  add() &#123;</span><br><span class="line">  this.items.push(0)</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.group-enter,</span><br><span class="line">.group-leave-to &#123;</span><br><span class="line">  opacity: 0;</span><br><span class="line">  transform: translateY(10px)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.group-enter-active,</span><br><span class="line">.group-leave-active &#123;</span><br><span class="line">  transition: all 1s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码在<a href="https://jsfiddle.net/justforlxz/9denwmor/20/" target="_blank" rel="noopener">这里，点击访问</a>，只实现了添加元素的过渡效果。</p><p>希望本文可以帮助你理解Vue是如何处理过渡动画，本文是基于官网的知识和demo所编写的，本文只写了一部分我觉得需要掌握的基本功能，Vue的transition组件还有很多功能等待你的挖掘，<a href="https://cn.vuejs.org/v2/guide/transitions.html" target="_blank" rel="noopener">点击前往Vue官网文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前一直搞不懂动画是怎么做的，它怎么这么神奇，写了一点看不懂的代码，就实现了非常丰富的效果，现在做了三年Qt开发，接触到了Qt的动画类，明白了动画是怎么一会儿事，现在来看当初的css动画代码，也明白了它是如何工作的了。本文会介绍一下Vue提供的组件过渡动画模块——transitions。&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://blog.justforlxz.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://blog.justforlxz.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>使用webpack-dev-server来监听项目变化</title>
    <link href="https://blog.justforlxz.com/2019/11/25/%E4%BD%BF%E7%94%A8webpack-dev-server%E6%9D%A5%E7%9B%91%E5%90%AC%E9%A1%B9%E7%9B%AE%E5%8F%98%E5%8C%96/"/>
    <id>https://blog.justforlxz.com/2019/11/25/使用webpack-dev-server来监听项目变化/</id>
    <published>2019-11-25T17:54:36.000Z</published>
    <updated>2020-02-24T10:48:36.828Z</updated>
    
    <content type="html"><![CDATA[<p>webpack的出现方便了前端开发者，使开发和部署分成了两部分，开发者可以正常根据工程化的要求进行开发，部署时通过webpack实现代码的裁剪和优化。</p><p>本次就介绍一个webpack的功能 <code>webpack-dev-server</code></p><p>将webpack与提供实时重载的开发服务器一起使用。这仅应用于开发。<br>它在后台使用了webpack-dev-middleware，它提供了对Webpack资产的快速内存访问。</p><a id="more"></a><p>webpack-dev-server提供了一个小型的express的http服务器，这个http服务器和client使用了websocket通讯协议，原始文件作出改动后，webpack-dev-server会实时的编译，但是最后的编译的文件并没有输出到目标文件夹。</p><p><strong>注意：启动webpack-dev-server后，在目标文件夹中是看不到编译后的文件的,编译后的文件都保存到了内存当中来加速访问。</strong></p><h2 id="启用webpack-dev-server"><a href="#启用webpack-dev-server" class="headerlink" title="启用webpack-dev-server"></a>启用webpack-dev-server</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -D webpack-dev-server</span><br></pre></td></tr></table></figure><p>在webpack.config.js中添加devServer对象：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  //...</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: path.join(__dirname, &apos;dist&apos;),</span><br><span class="line">    compress: true, // 开启压缩</span><br><span class="line">    port: 9000 // 指定运行的端口</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后通过<code>npx webpack-dev-server</code>启动，终端上会输出一些信息，一般我们会增加一些参数来使输出更加好看:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-dev-server --devtool eval-source-map --progress --colors --hot --inline</span><br></pre></td></tr></table></figure><p>上面的命令增加一个开发工具 <code>eval-source-map</code>，开启了progress进度显示，开启了colors颜色，hot热更新和inline更新模式。上面的参数也可以添加到devServer的属性中。</p><p>终端输出的内容如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10% building 1/1 modules 0 activeℹ ｢wds｣: Project is running at http://localhost:9000/</span><br><span class="line">ℹ ｢wds｣: webpack output is served from /dist/</span><br><span class="line">ℹ ｢wds｣: Content not from webpack is served from /home/justforlxz/Projects/VueBlog/dist</span><br><span class="line">ℹ ｢wdm｣: Hash: ff9005d9f6ffafd11cd4</span><br><span class="line">Version: webpack 4.41.0</span><br><span class="line">Time: 2938ms</span><br><span class="line">Built at: 11/25/2019 6:03:50 PM</span><br><span class="line">  Asset      Size  Chunks             Chunk Names</span><br><span class="line">main.js  2.09 MiB    main  [emitted]  main</span><br><span class="line">Entrypoint main = main.js</span><br><span class="line">[0] multi (webpack)-dev-server/client?http://localhost:9000 (webpack)/hot/dev-server.js ./src/main.ts 52 bytes &#123;main&#125; [built]</span><br></pre></td></tr></table></figure><p>我们就可以通过localhost:9000来访问我们的应用了。</p><p>需要注意的是，由于我们经常把内容输出到dist目录，但是webpack运行是在项目目录的，访问webpack生成在dist目录的main.js时，需要写上相对于webpack的目录，例如dist/main.js。否则会找不到文件。</p><p>如果遇到问题，导航到 /webpack-dev-server 路径，可以显示出文件的服务位置。 例如，<a href="http://localhost:9000/webpack-dev-server。" target="_blank" rel="noopener">http://localhost:9000/webpack-dev-server。</a></p><h2 id="配置webpack"><a href="#配置webpack" class="headerlink" title="配置webpack"></a>配置webpack</h2><p>webpack-dev-server支持在服务内部调用中间件对数据进行处理。</p><h3 id="devServer-before"><a href="#devServer-before" class="headerlink" title="devServer.before"></a>devServer.before</h3><p><code>function (app, server)</code></p><p>在服务内部的所有其他中间件之前， 提供执行自定义中间件的功能。 这可以用来配置自定义处理程序，例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  //...</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    before: function(app, server) &#123;</span><br><span class="line">      app.get(&apos;/some/path&apos;, function(req, res) &#123;</span><br><span class="line">        res.json(&#123; custom: &apos;response&apos; &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="devServer-after"><a href="#devServer-after" class="headerlink" title="devServer.after"></a>devServer.after</h3><p>同devServer.before，在服务内部的所有中间件之后，提供执行自定义中间件的功能。</p><h3 id="devServer-allowedHosts"><a href="#devServer-allowedHosts" class="headerlink" title="devServer.allowedHosts"></a>devServer.allowedHosts</h3><p>允许添加白名单服务，允许一些开发服务器访问。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  //...</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    allowedHosts: [</span><br><span class="line">      &apos;host.com&apos;,</span><br><span class="line">      &apos;subdomain.host.com&apos;,</span><br><span class="line">      &apos;subdomain2.host.com&apos;,</span><br><span class="line">      &apos;host2.com&apos;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>模仿 django 的 ALLOWED_HOSTS，以 . 开头的值可以用作子域通配符。.host.com 将会匹配 host.com, <a href="http://www.host.com" target="_blank" rel="noopener">www.host.com</a> 和 host.com 的任何其他子域名。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  //...</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    // 这实现了与第一个示例相同的效果，</span><br><span class="line">    // 如果新的子域名需要访问 dev server，</span><br><span class="line">    // 则无需更新您的配置</span><br><span class="line">    allowedHosts: [</span><br><span class="line">      &apos;.host.com&apos;,</span><br><span class="line">      &apos;host2.com&apos;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="devServer-clientLogLevel"><a href="#devServer-clientLogLevel" class="headerlink" title="devServer.clientLogLevel"></a>devServer.clientLogLevel</h3><p><code>string: &#39;none&#39; | &#39;info&#39; | &#39;error&#39; | &#39;warning&#39;</code></p><p>当使用内联模式(inline mode)时，会在开发工具(DevTools)的控制台(console)显示消息，例如：在重新加载之前，在一个错误之前，或者 模块热替换(Hot Module Replacement) 启用时。默认值是 info。</p><p>devServer.clientLogLevel 可能会显得很繁琐，你可以通过将其设置为 ‘none’ 来关闭 log。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  //...</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    clientLogLevel: &apos;none&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="devServer-color-只用于命令行工具-CLI"><a href="#devServer-color-只用于命令行工具-CLI" class="headerlink" title="devServer.color  - 只用于命令行工具(CLI)"></a>devServer.color  - 只用于命令行工具(CLI)</h3><p>只在终端下启用，启用/禁用控制台的彩色输出。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-dev-server --color</span><br></pre></td></tr></table></figure><h3 id="devServer-compress"><a href="#devServer-compress" class="headerlink" title="devServer.compress"></a>devServer.compress</h3><p><code>boolean</code></p><p>一切服务都开启gzip压缩。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  //...</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    compress: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="devServer-contentBase"><a href="#devServer-contentBase" class="headerlink" title="devServer.contentBase"></a>devServer.contentBase</h3><p><code>boolean: false string [string] number</code></p><p>告诉服务器从哪个目录中提供内容。只有在你想要提供静态文件时才需要。devServer.publicPath 将用于确定应该从哪里提供 bundle，并且此选项优先。</p><p>默认情况下，将使用当前工作目录作为提供内容的目录。将其设置为 false 以禁用 contentBase。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  //...</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: path.join(__dirname, &apos;public&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可以从多个目录提供内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  //...</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: [path.join(__dirname, &apos;public&apos;), path.join(__dirname, &apos;assets&apos;)]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="devServer-disableHostCheck"><a href="#devServer-disableHostCheck" class="headerlink" title="devServer.disableHostCheck"></a>devServer.disableHostCheck</h3><p><code>boolean</code></p><p>设置为 true 时，此选项绕过主机检查。不建议这样做，因为不检查主机的应用程序容易受到 DNS 重新连接攻击。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  //...</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    disableHostCheck: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="devServer-filename"><a href="#devServer-filename" class="headerlink" title="devServer.filename"></a>devServer.filename</h3><p><code>string</code></p><p>在 lazy mode(惰性模式) 中，此选项可减少编译。 默认在 lazy mode(惰性模式)，每个请求结果都会产生全新的编译。使用 filename，可以只在某个文件被请求时编译。</p><p>如果 output.filename 设置为 ‘bundle.js’ ，devServer.filename 用法如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  //...</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;bundle.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    lazy: true,</span><br><span class="line">    filename: &apos;bundle.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在只有在请求了bundle.js时，才会去编译bundle。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>webpack的功能确实很强大，可以针对代码进行各种操作，最终生成出可以适应各种场景的代码，使开发和部署彻底分离开来，开发者可以更加专注项目。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;webpack的出现方便了前端开发者，使开发和部署分成了两部分，开发者可以正常根据工程化的要求进行开发，部署时通过webpack实现代码的裁剪和优化。&lt;/p&gt;
&lt;p&gt;本次就介绍一个webpack的功能 &lt;code&gt;webpack-dev-server&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将webpack与提供实时重载的开发服务器一起使用。这仅应用于开发。&lt;br&gt;它在后台使用了webpack-dev-middleware，它提供了对Webpack资产的快速内存访问。&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://blog.justforlxz.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://blog.justforlxz.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>给Archlinux开启BFQ和MuQSS</title>
    <link href="https://blog.justforlxz.com/2019/10/24/%E7%BB%99Archlinux%E5%BC%80%E5%90%AFBFQ%E5%92%8CMuQSS/"/>
    <id>https://blog.justforlxz.com/2019/10/24/给Archlinux开启BFQ和MuQSS/</id>
    <published>2019-10-24T13:19:21.000Z</published>
    <updated>2020-02-24T10:48:36.836Z</updated>
    
    <content type="html"><![CDATA[<p>最近在Arch上更新系统的时候，总是遇到图形完全卡住的情况，今天上午突然想起来自己曾经设置了使用noop的IO调度，猜测是因为这个。然后本着不折腾不舒服的原则，打算使用ck内核上MuQSS的进程调度和BFQ的IO调度。</p><a id="more"></a><p>ck内核并没有在arch的仓库，但是aur有linux-ck的包，安装一下就可以了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yay -S linux-ck linux-ck-headers</span><br></pre></td></tr></table></figure><p>编译需要一些时间，在我的破本子i7-8550U编译了一顿过桥米线的时间，然后成功使用了ck内核。</p><h3 id="开启MuQSS"><a href="#开启MuQSS" class="headerlink" title="开启MuQSS"></a>开启MuQSS</h3><p>ck内核默认使用的就是MuQSS调度，并不需要修改什么，开机即可。</p><h3 id="开启BFQ"><a href="#开启BFQ" class="headerlink" title="开启BFQ"></a>开启BFQ</h3><p>开启BFQ需要一些手动设置。分为两步：</p><ol><li>修改grub，给内核提供新的参数</li><li>使用udev开启动态调整</li></ol><p><strong>修改grub</strong></p><p>编辑<code>/etc/default/grub</code>中<code>GRUB_CMDLINE_LINUX_DEFAULT</code>，增加一行内容:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet scsi_mod.use_blk_mq=1&quot;</span><br></pre></td></tr></table></figure><p>然后更新grub配置文件:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><p><strong>创建udev规则</strong></p><p>创建并编辑<code>/etc/udev/rules.d/60-scheduler.rules</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># set deadline scheduler for non-rotating disks</span><br><span class="line">ACTION==&quot;add|change&quot;, KERNEL==&quot;sd[a-z]&quot;, TEST!=&quot;queue/rotational&quot;, ATTR&#123;queue/scheduler&#125;=&quot;deadline&quot;</span><br><span class="line">ACTION==&quot;add|change&quot;, KERNEL==&quot;sd[a-z]&quot;, ATTR&#123;queue/rotational&#125;==&quot;0&quot;, ATTR&#123;queue/scheduler&#125;=&quot;bfq&quot;</span><br><span class="line"></span><br><span class="line"># set cfq scheduler for rotating disks</span><br><span class="line">ACTION==&quot;add|change&quot;, KERNEL==&quot;sd[a-z]&quot;, ATTR&#123;queue/rotational&#125;==&quot;1&quot;, ATTR&#123;queue/scheduler&#125;=&quot;bfq&quot;</span><br><span class="line">ACTION==&quot;add|change&quot;, KERNEL==&quot;nvme[0-9]n1&quot;, ATTR&#123;queue/rotational&#125;==&quot;0&quot;, ATTR&#123;queue/scheduler&#125;=&quot;bfq&quot;</span><br></pre></td></tr></table></figure><p>上面的配置是给固态硬盘使用deadline，给机械盘使用bfq，给nvme盘bfq。</p><p>本着电脑只有ssd，所以天不怕地不怕的原则，我选择全部使用bfq。</p><p>然后重启电脑，查看所有硬盘的调度器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># justforlxz @ archlinux in ~ [13:29:04]</span><br><span class="line">$ cat /sys/block/*/queue/scheduler</span><br><span class="line">mq-deadline kyber [bfq] none</span><br><span class="line">mq-deadline kyber [bfq] none</span><br></pre></td></tr></table></figure><p>通过dmesg查看MuQSS是否开启：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo dmesg | grep -i scheduler</span><br><span class="line">Alias tip: _ dmesg | grep -i scheduler</span><br><span class="line">[    0.295872] rcu: RCU calculated value of scheduler-enlistment delay is 10 jiffies.</span><br><span class="line">[    1.223982] io scheduler mq-deadline registered</span><br><span class="line">[    1.223984] io scheduler kyber registered</span><br><span class="line">[    1.224038] io scheduler bfq registered</span><br><span class="line">[    1.586191] MuQSS CPU scheduler v0.193 by Con Kolivas.</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MuQSS是BFS(脑残调度器)的进化版，主要是改进了BFS的O(n)复杂度，BFS适用于桌面环境用户，可以提供较好的进程切换和延迟。<br>BFQ是针对硬盘的IO调度，它通过预先分配一定的IO吞吐量来合理安排每个进程的IO操作。我需要用几天来感受一下MuQSS和CFQ的好处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在Arch上更新系统的时候，总是遇到图形完全卡住的情况，今天上午突然想起来自己曾经设置了使用noop的IO调度，猜测是因为这个。然后本着不折腾不舒服的原则，打算使用ck内核上MuQSS的进程调度和BFQ的IO调度。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://blog.justforlxz.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://blog.justforlxz.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用webpack打包Vue和TypeScript</title>
    <link href="https://blog.justforlxz.com/2019/10/22/%E4%BD%BF%E7%94%A8webpack%E6%89%93%E5%8C%85Vue%E5%92%8CTypeScript/"/>
    <id>https://blog.justforlxz.com/2019/10/22/使用webpack打包Vue和TypeScript/</id>
    <published>2019-10-22T15:20:08.000Z</published>
    <updated>2020-02-24T10:48:36.828Z</updated>
    
    <content type="html"><![CDATA[<p>本文将会介绍如何通过Webpack将基于TypeScript的Vue项目进行打包。</p><a id="more"></a><h2 id="webpack基础配置"><a href="#webpack基础配置" class="headerlink" title="webpack基础配置"></a>webpack基础配置</h2><p>首先创建一个基本的webpack.config.js文件:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path = require( &apos;path&apos; );</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: &quot;./src/index.ts&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve( __dirname, &apos;dist&apos; ),</span><br><span class="line">        publicPath: &apos;/dist/&apos;,</span><br><span class="line">        filename: &apos;[name].js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: &apos;inline-source-map&apos;,</span><br><span class="line">    mode: &apos;development&apos;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时webpack只能将src/index.ts文件直接输出为index.js，我们需要添加typescript的loader，进行typescript的转换。</p><p>将以下代码加入rules节:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.ts?$/,</span><br><span class="line">    loader: &apos;ts-loader&apos;,</span><br><span class="line">    exclude: /node_modules/,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>通过ts-loader进行ts文件的转换，我们还需要创建typescript的一个配置文件。</p><h2 id="添加typescript支持"><a href="#添加typescript支持" class="headerlink" title="添加typescript支持"></a>添加typescript支持</h2><p>创建tsconfig.json</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;outDir&quot;: &quot;./dist/&quot;,</span><br><span class="line">        &quot;sourceMap&quot;: true,</span><br><span class="line">        &quot;strict&quot;: true,</span><br><span class="line">        &quot;module&quot;: &quot;commonjs&quot;,</span><br><span class="line">        &quot;moduleResolution&quot;: &quot;node&quot;,</span><br><span class="line">        &quot;target&quot;: &quot;es5&quot;,</span><br><span class="line">        &quot;skipLibCheck&quot;: true,</span><br><span class="line">        &quot;esModuleInterop&quot;: true,</span><br><span class="line">        &quot;experimentalDecorators&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;include&quot;: [</span><br><span class="line">        &quot;./src/**/*&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要在webpack的配置中添加ts文件，在resolve节中添加:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extensions: [ &apos;.ts&apos;, &apos;.js&apos; ],</span><br></pre></td></tr></table></figure><p>我们指定ts转换出的js代码是es5的。</p><p>这个时候我们运行webpack，将会看到正常的转换输出。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hash: c3a0ae2c47032de12eec</span><br><span class="line">Version: webpack 4.41.0</span><br><span class="line">Time: 1880ms</span><br><span class="line">Built at: 10/22/2019 3:40:59 PM</span><br><span class="line">   Asset      Size  Chunks             Chunk Names</span><br><span class="line">index.js  11.8 KiB   index  [emitted]  index</span><br><span class="line">Entrypoint index = index.js</span><br><span class="line">[./src/index.ts] 269 bytes &#123;index&#125; [built]</span><br></pre></td></tr></table></figure><p>入口文件就是index.ts了，之后我们就正常的在index.ts中写我们的代码，webpack就会查找所有的依赖，并打包输出到index.js中。</p><h2 id="添加Vue单文件的支持"><a href="#添加Vue单文件的支持" class="headerlink" title="添加Vue单文件的支持"></a>添加Vue单文件的支持</h2><p>Vue单文件组件(SFC)规范是指在一个文件中，提供html、css和script代码，三者包含在顶级语言块 <code>&lt;template&gt;</code>、<code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code><br> 中，还允许添加可选的自定义块。</p><p>这是一个简单的vue单文件例子:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;example&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &apos;Hello world!&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.example &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;custom1&gt;</span><br><span class="line">  This could be e.g. documentation for the component.</span><br><span class="line">&lt;/custom1&gt;</span><br></pre></td></tr></table></figure><p>我们通过vue-loader来解析该文件，提取每一个语言块，如有需要，会传递给其他loader进行处理，最后组装为一个ES Module。</p><p>我们在webpack的rules节中添加vue-loader:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.vue$/,</span><br><span class="line">  loader: &apos;vue-loader&apos;,</span><br><span class="line">  options: &#123;</span><br><span class="line">    loaders: &#123;</span><br><span class="line">      // Since sass-loader (weirdly) has SCSS as its default parse mode, we map</span><br><span class="line">      // the &quot;scss&quot; and &quot;sass&quot; values for the lang attribute to the right configs here.</span><br><span class="line">      // other preprocessors should work out of the box, no loader config like this necessary.</span><br><span class="line">      &apos;scss&apos;: &apos;vue-style-loader!css-loader!sass-loader&apos;,</span><br><span class="line">      &apos;sass&apos;: &apos;vue-style-loader!css-loader!sass-loader?indentedSyntax&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">    // other vue-loader options go here</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="如果vue是typescript代码？"><a href="#如果vue是typescript代码？" class="headerlink" title="如果vue是typescript代码？"></a>如果vue是typescript代码？</h2><p>其实这很简单，ts-loader有一个appendTsSuffixTo的功能，可以给某个文件增加.ts的后缀，从而识别这个文件为ts文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.tsx?$/,</span><br><span class="line">  loader: &apos;ts-loader&apos;,</span><br><span class="line">  exclude: /node_modules/,</span><br><span class="line">  options: &#123;</span><br><span class="line">    appendTsSuffixTo: [/\.vue$/],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>我们还需要在项目中添加一个vue-shim.d.ts来让ts正确的识别vue。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare module &apos;*.vue&apos; &#123;</span><br><span class="line">  import Vue from &apos;vue&apos;</span><br><span class="line">  export default Vue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要在webpack的resolve节追加vue的后缀:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  extensions: [ &apos;.tsx&apos;, &apos;.ts&apos;, &apos;.js&apos; , &apos;.vue&apos;],</span><br><span class="line">  alias: &#123;</span><br><span class="line">    &apos;vue&apos;: &apos;vue/dist/vue.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>vue-loader现在需要手动处理一下插件，在webpack.config.js的头部导入vue-loader，并在plugins节创建对象。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; VueLoaderPlugin &#125; = require(&apos;vue-loader&apos;)</span><br><span class="line"></span><br><span class="line">.......</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  new VueLoaderPlugin()</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>否则将不能正确工作。</p><p>此时已经完成了webpack+vue+typescript的全部工作。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hash: 320d4ed3f55f52872694</span><br><span class="line">Version: webpack 4.41.0</span><br><span class="line">Time: 2494ms</span><br><span class="line">Built at: 10/22/2019 4:00:50 PM</span><br><span class="line">      Asset       Size    Chunks             Chunk Names</span><br><span class="line">  bundle.js   1.12 MiB    bundle  [emitted]  bundle</span><br><span class="line">electron.js   12.2 KiB  electron  [emitted]  electron</span><br><span class="line"> index.html  194 bytes            [emitted]</span><br><span class="line">Entrypoint bundle = bundle.js</span><br><span class="line">Entrypoint electron = electron.js</span><br><span class="line">[./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js?!./src/app.vue?vue&amp;type=style&amp;index=0&amp;id=5ef48958&amp;rel=stylesheet%2Fscss&amp;lang=scss&amp;scoped=true&amp;] ./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib??vue-loader-options!./src/app.vue?vue&amp;type=style&amp;index=0&amp;id=5ef48958&amp;rel=stylesheet%2Fscss&amp;lang=scss&amp;scoped=true&amp; 542 bytes &#123;bundle&#125; [built]</span><br><span class="line">[./node_modules/ts-loader/index.js?!./node_modules/vue-loader/lib/index.js?!./src/Components/About.vue?vue&amp;type=script&amp;lang=ts&amp;] ./node_modules/ts-loader??ref--1!./node_modules/vue-loader/lib??vue-loader-options!./src/Components/About.vue?vue&amp;type=script&amp;lang=ts&amp; 305 bytes &#123;bundle&#125; [built]</span><br><span class="line">[./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/Components/About.vue?vue&amp;type=template&amp;id=aa9c95a6&amp;] ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/Components/About.vue?vue&amp;type=template&amp;id=aa9c95a6&amp; 235 bytes &#123;bundle&#125; [built]</span><br><span class="line">[./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/app.vue?vue&amp;type=template&amp;id=5ef48958&amp;scoped=true&amp;] ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/app.vue?vue&amp;type=template&amp;id=5ef48958&amp;scoped=true&amp; 589 bytes &#123;bundle&#125; [built]</span><br><span class="line">[./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js?!./src/app.vue?vue&amp;type=style&amp;index=0&amp;id=5ef48958&amp;rel=stylesheet%2Fscss&amp;lang=scss&amp;scoped=true&amp;] ./node_modules/vue-style-loader!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib??vue-loader-options!./src/app.vue?vue&amp;type=style&amp;index=0&amp;id=5ef48958&amp;rel=stylesheet%2Fscss&amp;lang=scss&amp;scoped=true&amp; 1.64 KiB &#123;bundle&#125; [built]</span><br><span class="line">[./src/Components/About.vue] 1.06 KiB &#123;bundle&#125; [built]</span><br><span class="line">[./src/Components/About.vue?vue&amp;type=script&amp;lang=ts&amp;] 350 bytes &#123;bundle&#125; [built]</span><br><span class="line">[./src/Components/About.vue?vue&amp;type=template&amp;id=aa9c95a6&amp;] 203 bytes &#123;bundle&#125; [built]</span><br><span class="line">[./src/app.vue] 1.08 KiB &#123;bundle&#125; [built]</span><br><span class="line">[./src/app.vue?vue&amp;type=style&amp;index=0&amp;id=5ef48958&amp;rel=stylesheet%2Fscss&amp;lang=scss&amp;scoped=true&amp;] 716 bytes &#123;bundle&#125; [built]</span><br><span class="line">[./src/app.vue?vue&amp;type=template&amp;id=5ef48958&amp;scoped=true&amp;] 207 bytes &#123;bundle&#125; [built]</span><br><span class="line">[./src/entry.ts] 538 bytes &#123;bundle&#125; [built]</span><br><span class="line">[./src/main.ts] 1.11 KiB &#123;electron&#125; [built]</span><br><span class="line">[./src/route.ts] 1.35 KiB &#123;bundle&#125; [built]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将会介绍如何通过Webpack将基于TypeScript的Vue项目进行打包。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://blog.justforlxz.com/categories/Web/"/>
    
    
      <category term="Vue" scheme="https://blog.justforlxz.com/tags/Vue/"/>
    
      <category term="Webpack" scheme="https://blog.justforlxz.com/tags/Webpack/"/>
    
      <category term="TypeScript" scheme="https://blog.justforlxz.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>webpack入门</title>
    <link href="https://blog.justforlxz.com/2019/10/14/webpack%E5%85%A5%E9%97%A8/"/>
    <id>https://blog.justforlxz.com/2019/10/14/webpack入门/</id>
    <published>2019-10-14T15:34:52.000Z</published>
    <updated>2020-02-24T10:48:36.824Z</updated>
    
    <content type="html"><![CDATA[<p>现在前端开发不像以前一样，只需要写html、css和javascript文件就可以了。现代前端开发讲究工程化。</p><p><strong>什么是工程化？</strong></p><p>工程化即系统化、模块化、规范化的一个过程。</p><p><strong>为什么要工程化？</strong></p><p>工程化是让开发、测试和维护都变得更加可靠和提高效率的方式。</p><ol><li>制定规范</li><li>版本管理</li><li>单元测试</li><li>自动化</li></ol><p>通过制定流程的方式，规范了开发和测试的流程，让工作有章可循，方便团队协作。</p><a id="more"></a><p>最初的网页开发，是写好几份的javascript代码和css文件，手动在html中引入的。这样不适合多人协作开发，一旦开发人员多了，不可避免的会造成文件和命名冲突。<br>为了避免这些事情的发生，javascript增加了模块的概念。</p><p>有好的事情出现，就会有坏的事情发生。</p><p>过多的模块导致js文件下载很慢，而且有冗余，为了避免这件事情影响用户体验，webpack横空出世了。</p><p>webpack是一个现代javascript的静态模块打包器。它会递归的构建出依赖图，并根据依赖图来输出应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p><p>webpack有四个核心概念:</p><ul><li>入口(entry)</li><li>输出(output)</li><li>loader</li><li>插件</li></ul><p>入口决定了webpack要从哪个文件开始构建依赖图。</p><p>看一个简单的例子:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &apos;./src/index.js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output则决定了webpack会在哪里输出生成的bundles，以及如何命名这些bundles。输出目录默认为 <code>./dist/</code> 。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &apos;./src/index.js&apos;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">        filename: &apos;bundle.js&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loader可以让webpack打包非javascript文件，loader可以将所有类型的文件转换为webpack可以识别的有效模块，然后利用webpack的打包能力，对他们进行处理。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &apos;./src/index.js&apos;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">        filename: &apos;bundle.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: &#123;</span><br><span class="line">            test: /\.css$/,</span><br><span class="line">            use: &apos;css-loader&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rules中的意思是，当require()/impot中被解析为.css的路径时，先使用css-loader转换一下。</p><p>我们可以开发新的loader去加载不同的文件，最终都通过webpack来打包到一起。</p><p>loader用于转换某些类型的模块，插件则工作的更加广泛。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。</p><p>想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); // 通过 npm 安装</span><br><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &apos;./src/index.js&apos;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">        filename: &apos;bundle.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: &#123;</span><br><span class="line">            test: /\.css$/,</span><br><span class="line">            use: &apos;css-loader&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new HtmlWebpackPlugin(&#123;template: &apos;./src/index.html&apos;&#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过webpack，我们可以将整个项目都打包为一个文件进行分发，而且还可以进行优化。webpack的出现，将前端的开发和发布彻底的分离开，开发人员可以以各种方式进行开发，通过webpack打包以后输出部署需要的文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在前端开发不像以前一样，只需要写html、css和javascript文件就可以了。现代前端开发讲究工程化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是工程化？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;工程化即系统化、模块化、规范化的一个过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么要工程化？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;工程化是让开发、测试和维护都变得更加可靠和提高效率的方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;制定规范&lt;/li&gt;
&lt;li&gt;版本管理&lt;/li&gt;
&lt;li&gt;单元测试&lt;/li&gt;
&lt;li&gt;自动化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过制定流程的方式，规范了开发和测试的流程，让工作有章可循，方便团队协作。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://blog.justforlxz.com/categories/Web/"/>
    
      <category term="webpack" scheme="https://blog.justforlxz.com/categories/Web/webpack/"/>
    
    
      <category term="Web" scheme="https://blog.justforlxz.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>wsl2的使用体验</title>
    <link href="https://blog.justforlxz.com/2019/06/16/wsl2%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/"/>
    <id>https://blog.justforlxz.com/2019/06/16/wsl2的使用体验/</id>
    <published>2019-06-16T12:59:59.000Z</published>
    <updated>2020-02-24T10:48:36.824Z</updated>
    
    <content type="html"><![CDATA[<p>wsl2已经是虚拟机平台了。</p><a id="more"></a><p>需要Windows版本在18917及以上，先开启虚拟机平台才能继续，在管理员权限的powershell中执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform</span><br></pre></td></tr></table></figure><p>对已安装的wsl1进行转换</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wsl --set-version &lt;Distro&gt; 2</span><br></pre></td></tr></table></figure><p>Distro可以通过 <code>wsl --list</code> 查看。</p><p>转换需要点时间，完成以后就可以浪起来了。</p><p>wsl2新增了一些参数：</p><ul><li><code>wsl --set-version &lt;Distro&gt; &lt;Version&gt;</code></li></ul><p>可以设置某个wsl的版本，1是旧版，2是新版。</p><ul><li><code>wsl --set-default-version &lt;Version&gt;</code></li></ul><p>设置默认的wsl版本，推荐设置一下。</p><ul><li><code>wsl --shutdown</code></li></ul><p>出于某些目的，比如已经完成了任务，不再需要wsl工作在后台，可以手动关闭。</p><ul><li><code>wsl --list --quiet</code></li></ul><p>仅列出分发名称，此命令对于脚本编写很有用，因为它只会输出您已安装的发行版的名称，而不显示其他信息，如默认发行版，版本等。</p><ul><li><code>wsl --list --verbose</code></li></ul><p>显示有关所有分发的详细信息。此命令列出每个发行版的名称，发行版所处的状态以及正在运行的版本。它还显示哪些分发是默认的星号。</p><p>当一切准备就绪，我就安装了docker，测试一波。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install docker-ce</span><br></pre></td></tr></table></figure><p>添加用户到docker组。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service docker --full-restart</span><br></pre></td></tr></table></figure><p>已经可以跑docker了，我们来做个测试，请出万能的hello world！</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull hello-world</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --rm hello-world</span><br></pre></td></tr></table></figure><p>然后就看到了想要的结果，hello world成功的跑起来了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure><p>总的来说，因为wsl2改成虚拟机方案了，不过wsl2的启动速度还是挺快的，微软也努力让wsl2和wsl1之间在使用上没有差异。目前微软还没有完成wsl2的网络部分，wsl2和宿主机之间还需要使用专门的ip进行访问，等微软完成wsl2的localhost网络以后，就可以像以前一样直接跑一些网站或者需要端口的服务了。</p><p><img src="/2019/06/16/wsl2的使用体验/Snipaste_2019-06-16_21-52-42.png" alt="网络截图"></p><p>来一张合照</p><p><img src="/2019/06/16/wsl2的使用体验/Snipaste_2019-06-16_21-49-15.png" alt="合照"></p><p><a href="https://devblogs.microsoft.com/commandline/wsl-2-is-now-available-in-windows-insiders/" target="_blank" rel="noopener">点我查看wsl2的发布说明</a></p><p><a href="https://docs.microsoft.com/en-us/windows/wsl/wsl2-install" target="_blank" rel="noopener">点我查看如何安装wsl2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;wsl2已经是虚拟机平台了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Windows" scheme="https://blog.justforlxz.com/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>入坑typescript了</title>
    <link href="https://blog.justforlxz.com/2019/06/15/%E5%85%A5%E5%9D%91typescript%E4%BA%86/"/>
    <id>https://blog.justforlxz.com/2019/06/15/入坑typescript了/</id>
    <published>2019-06-15T23:41:49.000Z</published>
    <updated>2020-02-24T10:48:36.828Z</updated>
    
    <content type="html"><![CDATA[<p>今天算是正式入坑 typescript 了，基于 vue 写了第一个函数，用来做一个文字效果。</p><p>演示效果：<br><img src="/2019/06/15/入坑typescript了/%E6%B7%B1%E5%BA%A6%E5%BD%95%E5%B1%8F_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190615202044.gif" alt></p><a id="more"></a><p>整体思路听简单的，就是用定时器和延时器来做，通过定时器来间隔的处理文本，延时器来延后所有的方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TextHandle &#123;</span><br><span class="line">    private allDuration: number = 0;</span><br><span class="line">    public appendText(text: string) : void &#123;</span><br><span class="line">        setTimeout(() = &gt;&#123;</span><br><span class="line">            const LeftMessage = document.getElementById(&apos;LeftMessage&apos;);</span><br><span class="line">            if (LeftMessage === null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            let index: number = 0;</span><br><span class="line">            const MessageText: string = LeftMessage.innerText;</span><br><span class="line"></span><br><span class="line">            // tslint:disable-next-line:only-arrow-functions</span><br><span class="line">            const interval = setInterval(function() &#123;</span><br><span class="line">                if ((LeftMessage === null) || (index++ === text.length + 1)) &#123;</span><br><span class="line">                    return clearInterval(interval);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                LeftMessage.innerText = MessageText + text.substring(0, index);</span><br><span class="line">            &#125;,</span><br><span class="line">            300);</span><br><span class="line">        &#125;,</span><br><span class="line">        this.AllDuration);</span><br><span class="line">        this.AllDuration += text.length * 300 + 100;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>typescript确实挺不错的，平时都在写静态语言，如C++，所以当我开始学动态语言的时候，就会觉得水土不服，现在<br>通过typescript就可以让我继续使用静态语言的开发方式来写web，而且代码更容易理解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天算是正式入坑 typescript 了，基于 vue 写了第一个函数，用来做一个文字效果。&lt;/p&gt;
&lt;p&gt;演示效果：&lt;br&gt;&lt;img src=&quot;/2019/06/15/入坑typescript了/%E6%B7%B1%E5%BA%A6%E5%BD%95%E5%B1%8F_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190615202044.gif&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="typescript" scheme="https://blog.justforlxz.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>CMake CTests for dde-control-center</title>
    <link href="https://blog.justforlxz.com/2019/05/23/CMake-CTests-for-dde-control-center/"/>
    <id>https://blog.justforlxz.com/2019/05/23/CMake-CTests-for-dde-control-center/</id>
    <published>2019-05-23T17:16:15.000Z</published>
    <updated>2020-02-24T10:48:36.784Z</updated>
    
    <content type="html"><![CDATA[<p>什么是单元测试?</p><blockquote><p>在计算机编程中，单元测试又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。</p></blockquote><p>单元测试存在的意义在于，如果程序发生了异常情况，比如接收了错误的值，从而导致结果不正确，当修正程序中的错误后，为了避免再次遇到这个问题，需要对出问题的值和函数/功能进行一次测试，确保结果符合预期。</p><p>单元测试很重要，如果是新项目，请一定要刚开始就规划好单元测试。</p><p>为什么说单元测试很重要呢？因为单元测试的目的是隔离其他单元，并证明当前单元是正确的。这需要开发者在设计程序的时候就要考虑很多，合理的设计和规划项目。当未来重构项目的时候，可以局部重构来优化项目，而不是从零重写。</p><p>本文没有详细说明Qt的单元测试是如何编写的，编写Qt的单元测试放在以后再写(<del>咕咕咕</del>)。</p><a id="more"></a><p>写这篇文章是因为最近在给控制中心写单元测试，控制中心的模块都是MVC的，本身就做好了大方向的隔离，每个函数也基本是拆分出来的最小功能，可以单独拿出来测试。控制中心目前存在一个问题，Worker类是从DBus上接收数据，处理完成后放入Model中，如果测试Worker类，需要做很多和DBus相关的处理，比较麻烦，所以最开始我先把重心放在了创建Tests和测试一个基本的转换函数的功能，验证单元测试的流程。</p><blockquote><p><a href="https://github.com/linuxdeepin/dde-control-center/pull/171" target="_blank" rel="noopener">控制中心单元测试PR</a></p></blockquote><p>控制中心项目使用的CMake作为项目构建工具，所以用到了CTests，控制中心使用的Qt进行的开发，Qt也提供了自己的单元测试，我两个都做了支持。</p><p>在顶层的CMakeLists.txt中添加CTests的支持：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启用CTest检查</span><br><span class="line">include(Dart)</span><br><span class="line"></span><br><span class="line"># 启用CTest</span><br><span class="line">include(CTest)</span><br></pre></td></tr></table></figure><p>这两行内容需要在顶层CMakeLists.txt中添加，不然不会生效。</p><p>在子项目中创建一个dcc_test.h，用来写单元测试的类。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef DCC_TEST_H</span><br><span class="line">#define DCC_TEST_H</span><br><span class="line"></span><br><span class="line">#include &lt;QMap&gt;</span><br><span class="line">#include &lt;QString&gt;</span><br><span class="line">#include &lt;QTest&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;modules/display/displaywidget.h&quot;</span><br><span class="line"></span><br><span class="line">namespace Tests &#123;</span><br><span class="line"></span><br><span class="line">class Tests : public QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">private Q_SLOTS:</span><br><span class="line">    void testSliderValue_data()</span><br><span class="line">    &#123;</span><br><span class="line">        QTest::addColumn&lt;float&gt;(&quot;value&quot;);</span><br><span class="line">        QTest::addColumn&lt;int&gt;(&quot;result&quot;);</span><br><span class="line"></span><br><span class="line">        QMap&lt;float, int&gt; testMap&#123; &#123; 1.0, 1 &#125;,  &#123; 1.25, 2 &#125;, &#123; 1.5, 3 &#125;,</span><br><span class="line">                                  &#123; 1.75, 4 &#125;, &#123; 2.0, 5 &#125;,  &#123; 2.25, 6 &#125;,</span><br><span class="line">                                  &#123; 2.5, 7 &#125;,  &#123; 2.75, 8 &#125;, &#123; 3.0, 9 &#125; &#125;;</span><br><span class="line"></span><br><span class="line">        for (auto it = testMap.constBegin(); it != testMap.constEnd(); ++it) &#123;</span><br><span class="line">            QTest::newRow(&quot;converToSlider&quot;) &lt;&lt; it.key() &lt;&lt; it.value();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void testSliderValue()</span><br><span class="line">    &#123;</span><br><span class="line">        QFETCH(float, value);</span><br><span class="line">        QFETCH(int, result);</span><br><span class="line"></span><br><span class="line">        using namespace dcc::display;</span><br><span class="line"></span><br><span class="line">        QCOMPARE(DisplayWidget::convertToSlider(value), result);</span><br><span class="line">        QCOMPARE(DisplayWidget::convertToScale(result), value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  // namespace Tests</span><br><span class="line"></span><br><span class="line">QTEST_MAIN(Tests::Tests)</span><br><span class="line">#endif  // !DCC_TEST_H</span><br></pre></td></tr></table></figure><p>在子项目的CMakeLists.txt中添加一个二进制，用来当作单元测试程序。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这个宏是Dart提供的，用来判断是否开启CTest</span><br><span class="line">if(BUILD_TESTING)</span><br><span class="line">find_package(Qt5 COMPONENTS</span><br><span class="line">    Test</span><br><span class="line">REQUIRED)</span><br><span class="line"></span><br><span class="line">set(Qt_LIBS</span><br><span class="line">    $&#123;Qt_LIBS&#125;</span><br><span class="line">    Qt5::Test</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">set(TEST_SRCS</span><br><span class="line">tests/dcc_test.h</span><br><span class="line">$&#123;DISPLAY_FILES&#125;</span><br><span class="line">$&#123;WIDGETS_FILES&#125;</span><br><span class="line">$&#123;MODULE_FILES&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 添加一个叫unit-test的二进制</span><br><span class="line">add_executable(unit-test</span><br><span class="line">$&#123;TEST_SRCS&#125;</span><br><span class="line">$&#123;PROJECT_BINARY_DIR&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">target_include_directories(unit-test PUBLIC</span><br><span class="line">$&#123;TEST_SRCS&#125;</span><br><span class="line">$&#123;PROJECT_BINARY_DIR&#125;</span><br><span class="line">$&#123;DFrameworkDBus_INCLUDE_DIRS&#125;</span><br><span class="line">$&#123;QGSettings_INCLUDE_DIRS&#125;</span><br><span class="line">$&#123;Qt5Gui_PRIVATE_INCLUDE_DIRS&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">target_link_libraries(unit-test PRIVATE</span><br><span class="line">$&#123;Qt_LIBS&#125;</span><br><span class="line">$&#123;DFrameworkDBus_LIBRARIES&#125;</span><br><span class="line">$&#123;QGSettings_LIBRARIES&#125;</span><br><span class="line">$&#123;DtkWidget_LIBRARIES&#125;</span><br><span class="line">$&#123;XCB_EWMH_LIBRARIES&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>到这里，直接编译启动unit-test就可以使用Qt的单元测试了，但是加上CTest的支持只需要一行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add_test(ctest unit-test)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure><p>使用ctest -j6 -C Debug -T test –output-on-failure跑CTest，得到执行结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ctest]    Site: xiaomi-air</span><br><span class="line">[ctest]    Build name: Linux-c++</span><br><span class="line">[ctest] Test project /home/justforlxz/Projects/Deepin/dde-control-center/build</span><br><span class="line">[ctest]     Start 1: ctest</span><br><span class="line">[ctest] 1/1 Test #1: ctest ............................   Passed    0.05 sec</span><br><span class="line">[ctest]</span><br><span class="line">[ctest] 100% tests passed, 0 tests failed out of 1</span><br><span class="line">[ctest]</span><br><span class="line">[ctest] Total Test time (real) =   0.06 sec</span><br><span class="line">[ctest] CTest finished with return code 0</span><br></pre></td></tr></table></figure><p>如果是跑unit-test二进制，则会得到Qt打印的相关信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">********* Start testing of Tests::Tests *********</span><br><span class="line">Config: Using QtTest library 5.12.3, Qt 5.12.3 (x86_64-little_endian-lp64 shared (dynamic) release build; by GCC 8.3.0)</span><br><span class="line">PASS   : Tests::Tests::initTestCase()</span><br><span class="line">PASS   : Tests::Tests::testSliderValue(converToSlider)</span><br><span class="line">PASS   : Tests::Tests::testSliderValue(converToSlider)</span><br><span class="line">PASS   : Tests::Tests::testSliderValue(converToSlider)</span><br><span class="line">PASS   : Tests::Tests::testSliderValue(converToSlider)</span><br><span class="line">PASS   : Tests::Tests::testSliderValue(converToSlider)</span><br><span class="line">PASS   : Tests::Tests::testSliderValue(converToSlider)</span><br><span class="line">PASS   : Tests::Tests::testSliderValue(converToSlider)</span><br><span class="line">PASS   : Tests::Tests::testSliderValue(converToSlider)</span><br><span class="line">PASS   : Tests::Tests::testSliderValue(converToSlider)</span><br><span class="line">PASS   : Tests::Tests::cleanupTestCase()</span><br><span class="line">Totals: 11 passed, 0 failed, 0 skipped, 0 blacklisted, 0ms</span><br><span class="line">********* Finished testing of Tests::Tests *********</span><br></pre></td></tr></table></figure><p>对比CTest和Qt的单元测试，Qt会告诉你详细的函数调用和执行过程，CTest更注重结果，不过在Qtcreator的单元测试面板中，会看到更好的输出。</p><p>说到底，CTest支持启动了一个带有单元测试的程序，而程序自己使用了Qt提供的单元测试类进行测试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是单元测试?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在计算机编程中，单元测试又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单元测试存在的意义在于，如果程序发生了异常情况，比如接收了错误的值，从而导致结果不正确，当修正程序中的错误后，为了避免再次遇到这个问题，需要对出问题的值和函数/功能进行一次测试，确保结果符合预期。&lt;/p&gt;
&lt;p&gt;单元测试很重要，如果是新项目，请一定要刚开始就规划好单元测试。&lt;/p&gt;
&lt;p&gt;为什么说单元测试很重要呢？因为单元测试的目的是隔离其他单元，并证明当前单元是正确的。这需要开发者在设计程序的时候就要考虑很多，合理的设计和规划项目。当未来重构项目的时候，可以局部重构来优化项目，而不是从零重写。&lt;/p&gt;
&lt;p&gt;本文没有详细说明Qt的单元测试是如何编写的，编写Qt的单元测试放在以后再写(&lt;del&gt;咕咕咕&lt;/del&gt;)。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://blog.justforlxz.com/categories/Linux/"/>
    
    
      <category term="CMake Linux" scheme="https://blog.justforlxz.com/tags/CMake-Linux/"/>
    
  </entry>
  
  <entry>
    <title>如何在Deepin上使用LNMP</title>
    <link href="https://blog.justforlxz.com/2019/02/21/how-to-use-LNMP-on-deepin/"/>
    <id>https://blog.justforlxz.com/2019/02/21/how-to-use-LNMP-on-deepin/</id>
    <published>2019-02-21T10:11:15.000Z</published>
    <updated>2020-02-24T10:48:36.792Z</updated>
    
    <content type="html"><![CDATA[<p>为了节省读者的时间，我先简述一下阅读这篇文章需要了解的知识。</p><p>这篇文章将基于Docker来构建nginx、php和mysql来搭建LNMP环境，和其他教程有所不同的是，需要有一定的Docker基础。</p><a id="more"></a><p>Docker是一个不错的工具，使我们不需要虚拟机那样的庞然大物就可以轻松的隔离运行的程序，这要感谢Linux的资源分离机制，避免启动一个虚拟机造成了大量资源浪费。</p><p>首先需要在Deepin上安装Docker，添加Docker的deb仓库，并安装docker-ce。</p><p>创建文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/apt/sources.list.d/docker.list</span><br></pre></td></tr></table></figure><p>写入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb [arch=amd64] https://download.docker.com/linux/debian jessie edge</span><br></pre></td></tr></table></figure><p>刷新一下仓库就可以安装了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install docker-ce docker-compose</span><br></pre></td></tr></table></figure><p>安装完成后重启一下系统，准备工作就算完成了一半了。</p><p>在家目录创建一个Projects目录，当做我们LNMP的工作目录，创建一个名叫<em>docker-compose.yaml</em>的文件，这是docker-compose的配置文件，我们通过docker-compose这个工具来管理我们的Docker容器。</p><p>所有的镜像均采用最新版本，nginx(1.15.8)，php(7.3.2)，mysql(8.0.15)，如有需要，自行选择不同版本的镜像。</p><p>注意PHP7已经不支持mysql扩展，使用内置的MySQLnd。</p><p>写入以下配置文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &apos;3&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  nginx:</span><br><span class="line">    # 设置容器名字</span><br><span class="line">    container_name: &quot;nginx&quot;</span><br><span class="line">    # 采用最新的nginx</span><br><span class="line">    image: nginx:latest</span><br><span class="line">    # 绑定80端口</span><br><span class="line">    ports:</span><br><span class="line">        - &quot;80:80&quot;</span><br><span class="line">    # 添加php容器的依赖</span><br><span class="line">    depends_on:</span><br><span class="line">        - &quot;php&quot;</span><br><span class="line">    # 绑定数据目录</span><br><span class="line">    volumes:</span><br><span class="line">        - &quot;./volumes/nginx/conf.d:/etc/nginx/conf.d&quot;</span><br><span class="line">        - &quot;./volumes/html:/usr/share/nginx/html&quot;</span><br><span class="line">    restart: always</span><br><span class="line"></span><br><span class="line">  php:</span><br><span class="line">    # 设置容器名字</span><br><span class="line">    container_name: &quot;php&quot;</span><br><span class="line">    # 采用最新的php</span><br><span class="line">    image: php:fpm</span><br><span class="line">    # 绑定端口</span><br><span class="line">    ports:</span><br><span class="line">        - &quot;9000:9000&quot;</span><br><span class="line">    # 绑定数据目录</span><br><span class="line">    volumes:</span><br><span class="line">        - &quot;./volumes/html:/var/www/html&quot;</span><br><span class="line">    restart: always</span><br><span class="line"></span><br><span class="line">  mysql:</span><br><span class="line">    # 设置容器名字</span><br><span class="line">    container_name: &quot;mysql&quot;</span><br><span class="line">    # 采用最新的mysql</span><br><span class="line">    image: mysql:latest</span><br><span class="line">    # 绑定端口</span><br><span class="line">    ports:</span><br><span class="line">        - &quot;3306:3306&quot;</span><br><span class="line">    # 设置环境变量</span><br><span class="line">    environment:</span><br><span class="line">        - MYSQL_ROOT_PASSWORD=(自己设置密码)</span><br><span class="line">    # 绑定数据目录</span><br><span class="line">    volumes:</span><br><span class="line">        - &quot;./volumes/mysql:/var/lib/mysql&quot;</span><br><span class="line">    restart: always</span><br></pre></td></tr></table></figure><p>创建nginx的配置文件，编辑 <em>./volumes/nginx/conf.d/nginx.conf</em> ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">        index  index.html index.htm index.php;</span><br><span class="line">    &#125;</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        fastcgi_pass   php:9000;</span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME /var/www/html/$fastcgi_script_name;</span><br><span class="line">        include        fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建php测试文件，编辑 <em>./volumes/html/index.php</em> :</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">phpinfo();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>启动docker，第一次需要拉取一下镜像:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up --build -d</span><br></pre></td></tr></table></figure><p>等全部结束以后，就可以访问localhost看到php的信息了。</p><p>通过Docker的方法来使用LNMP，不污染宿主机环境，不会再因为各种依赖问题而搞坏系统，这恰恰是新手容易犯的错误，使用Docker，方便你我。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了节省读者的时间，我先简述一下阅读这篇文章需要了解的知识。&lt;/p&gt;
&lt;p&gt;这篇文章将基于Docker来构建nginx、php和mysql来搭建LNMP环境，和其他教程有所不同的是，需要有一定的Docker基础。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://blog.justforlxz.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://blog.justforlxz.com/tags/Linux/"/>
    
      <category term="LNMP" scheme="https://blog.justforlxz.com/tags/LNMP/"/>
    
      <category term="Deepin" scheme="https://blog.justforlxz.com/tags/Deepin/"/>
    
      <category term="Web" scheme="https://blog.justforlxz.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>解决用了xposed后淘宝闪退</title>
    <link href="https://blog.justforlxz.com/2019/01/23/fuck-taobao/"/>
    <id>https://blog.justforlxz.com/2019/01/23/fuck-taobao/</id>
    <published>2019-01-23T10:27:52.000Z</published>
    <updated>2020-02-24T10:48:36.792Z</updated>
    
    <content type="html"><![CDATA[<p>反正都用xposed了，肯定也有root权限。<br>删除/data/data/com.taobao.taobao/files/bundleBaseline/里的文件，然后设置该目录为500。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;反正都用xposed了，肯定也有root权限。&lt;br&gt;删除/data/data/com.taobao.taobao/files/bundleBaseline/里的文件，然后设置该目录为500。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用swapfile来休眠</title>
    <link href="https://blog.justforlxz.com/2018/12/12/hibernate-for-swapfile/"/>
    <id>https://blog.justforlxz.com/2018/12/12/hibernate-for-swapfile/</id>
    <published>2018-12-12T11:01:55.000Z</published>
    <updated>2020-02-24T10:48:36.792Z</updated>
    
    <content type="html"><![CDATA[<p>最近deepin要添加休眠功能，但是之前测试的通过swapfile来休眠失败了，所以对正在使用swap分区的用户提供休眠功能。但是昨天我在askubuntu上看到有人发了在ubuntu下通过swapfile休眠的方案，今天试了一下，效果良好，觉得可以考虑给deepin也加上这样的功能。</p><a id="more"></a><p>原文链接: <a href="https://askubuntu.com/questions/6769/hibernate-and-resume-from-a-swap-file" target="_blank" rel="noopener">Hibernate and resume from a swap file</a></p><p>具体步骤是通过uswsusp这个包来做的，uswsusp是一组用户空间工具，用于Linux系统上的休眠(挂起到磁盘)和挂起(挂起到RAM或待机)。详细内容可以在ArchWiki上参考。<a href="https://wiki.archlinux.org/index.php/Uswsusp" target="_blank" rel="noopener">点这里</a></p><p>先创建一个和内存同等大小的swapfile，为了确保休眠成功，不能小于内存的容量。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo fallocate -l 16g /swapfile # 我的机子是16G，具体自己修改</span><br><span class="line">sudo chmod 600 /swapfile</span><br><span class="line">sudo mkswap /swapfile</span><br><span class="line">sudo swapon /swapfile</span><br><span class="line">echo &apos;/swapfile swap swap defaults 0 0&apos; | sudo tee -a /etc/fstab</span><br></pre></td></tr></table></figure><p>安装用户空间软休眠(Userspace Software Suspend)包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install uswsusp</span><br></pre></td></tr></table></figure><p>创建需要的配置文件，只需要创建文件即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo touch /etc/uswsusp.conf</span><br><span class="line">sudo dpkg-reconfigure -pmedium uswsusp</span><br></pre></td></tr></table></figure><p>这时候终端会提醒是否继续，选择Yes，然后会要求你创建一个密码，设置一个密码继续即可。</p><p>此时就可以测试一下功能了，不过我是跳过这个步骤了(比较喜欢作死)。</p><p>修改systemd的hibernate服务，使用uswsusp来代替systemd的功能。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl edit systemd-hibernate.service</span><br></pre></td></tr></table></figure><p>写入以下内容:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/sbin/s2disk</span><br><span class="line">ExecStartPost=/bin/run-parts -a post /lib/systemd/system-sleep</span><br></pre></td></tr></table></figure><p>这时候可以使用systemd的命令来测试的，我表示工作的非常正常。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl hibernate</span><br></pre></td></tr></table></figure><p>执行以后可以看到屏幕上会打印当前保存的进度，然后设备就关机了，此时再开机，等待一会儿以后就看到了背景是我漂亮老婆的锁屏，解锁以后看到工作区还是执行命令前的，一切ok。</p><p>参考以下内容:</p><blockquote><p><a href="https://askubuntu.com/questions/6769/hibernate-and-resume-from-a-swap-file" target="_blank" rel="noopener">https://askubuntu.com/questions/6769/hibernate-and-resume-from-a-swap-file</a></p></blockquote><blockquote><p><a href="https://wiki.archlinux.org/index.php/Uswsusp" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Uswsusp</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近deepin要添加休眠功能，但是之前测试的通过swapfile来休眠失败了，所以对正在使用swap分区的用户提供休眠功能。但是昨天我在askubuntu上看到有人发了在ubuntu下通过swapfile休眠的方案，今天试了一下，效果良好，觉得可以考虑给deepin也加上这样的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://blog.justforlxz.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://blog.justforlxz.com/tags/Linux/"/>
    
  </entry>
  
</feed>
