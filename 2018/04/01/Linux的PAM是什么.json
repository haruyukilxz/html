{"attributes":{"layout":"post","title":"Linux的PAM是什么","subtitle":"我的linux日常","date":"2018-04-01T12:16:08.000Z","author":"张丁元","tags":["Linux"]},"body":"本文会基础的介绍一下PAM是什么，让你能够回答PAM是什么、PAM有什么用、如何根据需求自己开发PAM模块。\r\n### PAM是什么\r\nPAM即可插拔认证模块。它提供了一个所有服务的中心验证机制，适用于普通登录、ssh登录等需要进行身份认证的系统中。\r\n### 为什么使用PAM\r\n为了安全起见，计算机只能给通过授权的用户进行使用，在创建用户时，密码会被加密保存在/etc/passwd中,在用户登录时，重新计算密码，然后在/etc/passwd中进行对比。\r\n除了上面这种，还有其他方式的验证，比如现在经常使用的指纹认证，其核心思想都是检查内容是否匹配。但是这些方案都有一些通病，那就是需要随着应用程序一起编译来使用，如果认证系统有问题，或者更新了算法，就需要重新编译才能使用。\r\n> 鉴于以上原因，人们开始寻找一种更佳的替代方案：一方面，将鉴别功能从应用中独立出来，单独进行模块化设计，实现和维护；另一方面，为这些鉴别模块建立标准 API，以便各应用程序能方便的使用它们提供的各种功能；同时，鉴别机制对其上层用户（包括应用程序和最终用户）是透明的。\r\n### PAM是如何工作的\r\n![](Linux的PAM是什么/PAM结构.png)\r\nPAM采用了分层的模块式开发，提供了四种类型的模块:\r\n- 认证管理\r\n- 账号管理\r\n- 会话管理\r\n- 口令管理\r\n这四个接口就可以满足用户的认证和管理。一个模块可以同时属于多种类型，只需实现对应的函数就可以。\r\n目前PAM的实现有以下三种：\r\n>1. Linux-PAM: Linux-PAM 涵盖了本文中讨论的所有 PAM。在任何一个 Linux 平台中的 PAM 的主要结构都类似于 Linux-PAM 版本。\r\n>2. OpenPAM: OpenPAM 是由 NAI 实验室的 Dag-Erling Smorgrav 开发的另一个 PAM 实现，属于 DARPA-CHATS 研究项目。由于它是开源的，因此它主要由 FreeBSD、NetBSD 及应用程序（加上 Mac OS X）使用。\r\n>3. Java™ PAM 或 JPam: PAM 主要是支持 Linux 和 UNIX 的标准验证模块。JPam 将 Java 部分与普通 PAM 联系了起来。JPam 允许基于 Java 的应用程序使用 PAM 模块或工具（如 auth、account、passwd、session 等）。它提供了 JAAS 和直接 API，并且支持大多数 Unix OS 和架构。\r\n虽然有不同的PAM实现，但是主要功能都是类似的，完成用户的验证。\r\n想要了解更多，可查看IBM的文档库。\r\n[深入 Linux PAM 体系结构](https://www.ibm.com/developerworks/cn/linux/l-cn-pam/index.html)\r\n### 如何自己开发PAM模块\r\nPAM模块使用一个pam_handle类型的结构当做句柄，也是唯一一个PAM和程序进行通信的结构。\r\n首先在编写的服务模块的源程序里要包含下列头文件：\r\n```\r\n#include <security/pam_modules.h>\r\n```\r\nPAM模块是一个个的so动态库。PAM会通过dlopen来装载这些so。四个模块分别需要实现对应的方法，PAM会根据配置文件来调用这些方法。\r\n每个PAM模块的认证程序都以pam_start开始，以pam_end结束。PAM还提供了pam_get_item和pam_set_item共享有关认证会话的某些公共信息，例如用户名、服务名和密码。应用程序在调用了pam_start以后可以用这些APIs来改变状态信息。实际工作的函数有6个：\r\n模块类型 | 函数 | 功能\r\n---- | ---- | ----\r\n认证管理 | PAM_EXTERN int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv) | 认证用户\r\n认证管理 |  PAM_EXTERN int pam_sm_setcred(pam_handle_t *pamh, int flags, int argc, const char **argv) | 设置用户证书\r\n账号管理 | PAM_EXTERN int pam_sm_acct_mgmt(pam_handle_t *pamh, int flags, int argc, const char **argv) | 账号管理\r\n会话管理 | PAM_EXTERN int pam_sm_open_session(pam_handle_t *pamh, int flags, int argc, const char **argv) | 打开会话\r\n会话管理 | PAM_EXTERN int pam_sm_close_session(pam_handle_t *pamh, int flags, int argc, const char **argv) | 关闭会话\r\n口令管理 | PAM_EXTERN int pam_sm_chauthtok(pam_handle_t *pamh, int flags, int argc, const char **argv) | 设置口令\r\n同一个模块可以同时支持不同的类型，可以一个模块全部实现这些方法，也可以实现部分。PAM自带的pam_unix.so就是支持四种类型。\r\n在函数内进行详细的操作，最后返回结果，即可完成整个验证流程。\r\n### 配置PAM\r\nPAM的配置通常在/etc/pam.d/下。\r\n模块将按照在配置文件中列出的顺序被调用，这取决于每个条目允许的 Control_flag 的值。Control_flag 值包括：\r\n> Required：堆栈中的所有 Required 模块必须看作一个成功的结果。如果一个或多个 Required 模块失败，则实现堆栈中的所有 Required 模块，但是将返回第一个错误。\r\n>\r\n>Sufficient：如果标记为 sufficient 的模块成功并且先前没有 Required 或 sufficient 模块失败，则忽略堆栈中的所有其余模块并返回成功。\r\n>\r\n>Optional：如果堆栈中没有一个模块是 required 并且没有任何一个 sufficient 模块成功，则服务/应用程序至少要有一个 optional 模块成功。\r\n### 在程序中使用PAM进行验证\r\n1. 开发PAM验证模块\r\n```\r\n#include <security/pam_appl.h>\r\n#include <security/pam_modules.h>\r\n#include <stdio.h>\r\n// 只实现账户认证\r\nPAM_EXTERN int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc,\r\n                                   const char **argv) {\r\n  char *username;\r\n  char password[256];\r\n  //得到用户名\r\n  pam_get_user(pamh, &username, \"Username: \");\r\n  // 得到密码\r\n  printf(\"Password: \");\r\n  gets(password);\r\n  // 测试判断，如果用户名和密码不相等，就认证失败\r\n  if (strcmp(username, password) != 0) {\r\n    return PAM_AUTH_ERR;\r\n  }\r\n  printf(\"Password is: %s\\n\", password);\r\n  return PAM_SUCCESS;\r\n}\r\n```\r\n编译:\r\n```\r\ngcc -fPIC -fno-stack-protector -c pam_test_mod.c\r\nsudo ld -x --shared -o /lib/security/pam_test_mod.so pam_test_mod.o\r\n```\r\n还需要修改pam的配置，来加载这个so。编辑/etc/pam.d/common-auth\r\n```\r\nauth [success=1 default=ignore] pam_test_mod.so\r\n```\r\n这里的success的值需要根据实际情况来调整，必须是所有里面的最大值。\r\n2. 使用模块进行验证\r\n```\r\n// PAM必须的两个头文件\r\n#include <iostream>\r\n#include <security/pam_appl.h>\r\n#include <security/pam_misc.h>\r\nusing namespace std;\r\nextern int misc_conv(int num_msg, const struct pam_message **msgm,\r\n                     struct pam_response **response, void *appdata_ptr) {\r\n  return PAM_SUCCESS;\r\n}\r\nconst struct pam_conv conv = {misc_conv, NULL};\r\nint main(int argc, char *argv[]) {\r\n  // 初始化\r\n  pam_handle_t *pamh = NULL;\r\n  int retval;\r\n  const char *username = argv[1];\r\n  // 初始化PAM 设置common-auth为验证配置\r\n  if ((pam_start(\"common-auth\", username, &conv, &pamh)) != PAM_SUCCESS) {\r\n    return -1;\r\n  }\r\n  // //认证用户\r\n  retval = pam_authenticate(pamh, 0);\r\n  cout << (retval == PAM_SUCCESS ? \"SUCCESS\\n\" : \"Failed\\n\") << endl;\r\n  // // 结束PAM\r\n  if (pam_end(pamh, retval) != PAM_SUCCESS) {\r\n    cout << \"check_user: failed to release authenticator\\n\" << endl;\r\n    return -1;\r\n  }\r\n  return retval == PAM_SUCCESS ? 0 : 1;\r\n}\r\n```\r\n编译测试一下:\r\n```\r\ng++ -o pam_test pam_test.cc -lpam -lpam_misc\r\nsudo ./pam_test $USER\r\n```\r\n输出为：\r\n```\r\n$ ./pam_test test       \r\nPassword: test\r\nPassword is: test\r\nSUCCESS\r\n```\r\n### 总结\r\n基于PAM认证体系，我们可以根据自己的需求任意的扩展linux账户，linux下的pbis-open，就是基于PAM扩展出来的一个AD域登录模块，它提供了一个pam_lsass.so的文件，来进行账户的验证。我们也可以自己设计一套认证流程，只需要满足上面的接口要求就可以。\r\n> 提供机制，而非策略\r\n","id":"f0eead78c7e0c2081f9998024c6be8d3","link":"/2018/04/01/Linux的PAM是什么"}