{
    "attributes": {
        "title": "智能指针",
        "s": "cpp-smart-pointer",
        "date": "2018-08-29T09:43:17.000Z",
        "tags": "C++",
        "categories": "C++"
    },
    "body": "<p>其实一直都对智能指针的应用场景不清楚，项目中也很少用到，今天在 <a href=\"https://zccrs.com\">@zccrs</a> 大佬的帮助下，大概理解了智能指针的作用和应用场景。</p>\n<h1>设计思想</h1>\n<p>智能指针依赖一种叫引用计数的手段来协助管理对象指针，通过引用计数为0时删除对象指针来完成内存的释放，本质上是通过栈对象来管理堆对象的一种方法。</p>\n<h2>传统做法</h2>\n<pre><code>void test() {\n    Test* t = new Test;\n    ...\n    if (...) {\n        throw exception();\n    }\n    delete t;\n}\n</code></pre>\n<p>当出现异常时，delete将不会被执行到，t也就泄露了。虽然我们可以在异常那里把delete给加上，但是在较为大型的项目中，如果对代码进行review来排查这种错误，将会是非常麻烦的一件事，所以为了避免内存泄漏，发明了基于引用技术的智能指针。</p>\n<h2>智能指针做法</h2>\n<pre><code>void test() {\n    std::unique_ptr&lt;Test&gt; t(new Test);\n    ...\n    if (...) {\n        throw exception();\n    }\n}\n</code></pre>\n<p>如果不关心std::unique_ptr是什么，这段代码无意是糟糕的，new出来的Test对象根本没有地方被删除，内存泄露了。\n但是不必担心，指针已经由std::unique_ptr来管理了，根本不会发生内存泄漏，对象将在离开函数作用域以后被删除。\n这就是智能指针的方便之处。</p>\n<h1>智能指针的基本实现</h1>\n<p>智能指针都通过模板编程来实现，模板是C++的另一大功能，可以使我们更关心实现而不需要关心具体的对象，通过更加抽象的方式来编写程序。\n智能指针有两层，里层用来保存对象的指针和引用计数，外层用来调用里层来控制引用计数。\n里层的辅助类</p>\n<pre><code>template&lt;typename T&gt;\nclass P_ptr {\n    private:\n        friend class Pointer&lt;T&gt;;\n        P_ptr(T t)\n        : pointer(t)\n        , count(1)\n        {\n        }\n        uint count;\n        T pointer;\n}\n</code></pre>\n<p>外层的控制类</p>\n<pre><code>template&lt;typename T&gt;\nclass Pointer {\n    public:\n        Pointer(T t)\n        : m_ptr(new P_ptr(t))\n        {\n        }\n        Pointer(const Pointer &amp;pointer)\n        : m_ptr(pointer.m_ptr)\n        {\n            ++m_ptr-&gt;count;\n        }\n        Pointer&amp; operator=(const Pointer &amp;pointer) {\n            ++pointer-&gt;count;\n            if (--m_ptr-&gt;count == 0) { // 应对自赋值\n                delete m_ptr;\n            }\n            m_ptr = pointer-&gt;m_ptr;\n            return *this;\n        }\n        ~Pointer() {\n            if (--m_ptr-&gt;count == 0) {\n                delete m_ptr;\n            }\n        }\n    private:\n        P_ptr m_ptr;\n}\n</code></pre>\n<p>通过重写控制类的拷贝构造函数和赋值运算符重载来更新引用计数。\n使用实例</p>\n<pre><code>void test() {\n    Pointer&lt;Test&gt; t(new Test); // 引用计数目前是1\n    Pointer&lt;Test&gt; t1 = t; // t的引用计数是2，t1的引用计数也是2\n}\n// 离开作用域，t被删除，引用计数是1. t1被删除，引用计数为0，Test被删除，内存没有泄露。\n</code></pre>\n<p>这样我们就有一个简单的智能指针了，不过他还存在一些问题，比如循环引用导致内存泄漏，没有-&gt;和*的操作运算符等。所以我们需要更强大的智能指针来帮助我们。</p>\n<h1>几种智能指针的介绍</h1>\n<p>标准库提供了几个针对不同方面使用的智能指针，以满足我们的需求。</p>\n<ul>\n<li>unique_ptr\n<blockquote>\n<p>只允许一个所有者，除非确信你需要共享该指针，则应该使用<code>shared_ptr</code>。可以转移到新的所有者，但是不会复制和共享。</p>\n</blockquote>\n</li>\n<li>shared_ptr\n<blockquote>\n<p>采用引用计数的智能指针，如果你想将一个原始指针分配给多个所有者，请使用该智能指针，直到<code>shared_ptr</code>所有者超出了范围或放弃所有权，才会删除原始指针，大小为两个指针，一个用于对象，一个用于引用计数。</p>\n</blockquote>\n</li>\n<li>weak_ptr\n<blockquote>\n<p>结合<code>shared_ptr</code>使用的特殊智能指针，提供一个或多个<code>shared_ptr</code>实例所拥有的对象的访问，但是不会增加引用计数。如果你想观察某个对象，但是不需要保持活动状态，则可以使用该智能指针。在某些情况下，需要断开<code>shared_ptr</code>实例间的循环引用。</p>\n</blockquote>\n</li>\n</ul>\n<h1>如何正确的选择智能指针</h1>\n<p>智能指针只需要区分需不需要共享使用，如果外部需要使用这个对象，使用<code>shared_ptr</code>，否则就使用unique_ptr进行独占使用。</p>\n<h1>陷阱和坑</h1>\n<ul>\n<li>不要使用相同的内置指针来初始化多个智能指针</li>\n<li>不要主动回收智能指针内原始指针的内存</li>\n<li>不要使用智能指针的get来初始化或者reset另一个智能指针</li>\n<li>智能指针管理的资源只会默认删除new分配的内存，如果不是new分配的，则需要使用删除器</li>\n</ul>\n",
    "id": "942a38b40f95acee16c02efc161cba2a",
    "link": "/2018/08/29/智能指针"
}