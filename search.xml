<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>deepin git version</title>
      <link href="/2020/09/06/deepin-git-version/"/>
      <url>/2020/09/06/deepin-git-version/</url>
      
        <content type="html"><![CDATA[<p>This repository only provides the git version of deepin. You can replace the deepin group in the community by installing the deepin-git group.</p><a id="more"></a><p>The PKGBUILD for all packages are there <a href="https://github.com/justforlxz/deepin-git-repo" target="_blank" rel="noopener">https://github.com/justforlxz/deepin-git-repo</a>, Each branch saves the corresponding software.</p><p>Before adding this repository, you should first add the key used to sign the packages in it. You can do this by running the following commands:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -qO - https://packages.justforlxz.com/deepingit.asc \</span><br><span class="line">    | sudo pacman-key --add -</span><br></pre></td></tr></table></figure><p>It is recommended that you now fingerprint it by running</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman-key --finger DCAF15B4605D5BEB</span><br></pre></td></tr></table></figure><p>and in a final step, you have to locally sign the key to trust it via</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman-key --lsign-key DCAF15B4605D5BEB</span><br></pre></td></tr></table></figure><p>More infos on this process can be found at <a href="https://wiki.archlinux.org/index.php/Pacman/Package_signing#Adding_unofficial_keys" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Pacman/Package_signing#Adding_unofficial_keys</a>. You can now add the repository by editing /etc/pacman.conf and adding</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[deepingit]</span><br><span class="line">Server = https://packages.justforlxz.com/</span><br></pre></td></tr></table></figure><p>at the end of the file. See <a href="https://wiki.archlinux.org/index.php/Pacman#Repositories_and_mirrors" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Pacman#Repositories_and_mirrors</a> for details.</p><p>to install deepin git version:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -Syy deepin-git</span><br></pre></td></tr></table></figure><p>If you don’t want to use the repository anymore, you can uninstall deepin git, or install the deepin group in Community.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -Rscn deepin-git</span><br></pre></td></tr></table></figure><p>to install deepin group for community.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S deepin</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用VSCode远程开发DDE</title>
      <link href="/2020/09/03/use-vscode-to-remotely-develop-dde/"/>
      <url>/2020/09/03/use-vscode-to-remotely-develop-dde/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍如何使用VSCode的远程开发套件连接到Deepin主机，进行DDE和其他软件的开发与调试.</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Visual Studio Code（简称VS Code）是一个由微软开发，同时支持Windows 、 Linux和macOS等操作系统的免费代码编辑器，它支持测试，并内置了Git 版本控制功能，同时也具有开发环境功能，例如代码补全（类似于 IntelliSense）、代码片段和代码重构等。该编辑器支持用户个性化配置，例如改变主题颜色、键盘快捷方式等各种属性和参数，同时还在编辑器中内置了扩展程序管理的功能。</p><p>在VSCode出来之前，Sublime曾经是前端开发者必备的软件，它使用python作为插件运行环境，并且也拥有不少的插件，但是很遗憾的是插件不能更改界面元素，可玩性不是很高。</p><p>再后来Atom作为GitHub的顶梁柱出现了，它基于使用Chromium和Node.js的跨平台应用框架Electron（最初名为Atom Shell），并使用CoffeeScript和Less撰写，并且支持js开发的插件，一时间拥有非常多的用户，并且从Sublime那里拉拢了非常多的前端开发者。</p><p>但是一切都在VSCode面世以后变了。VSCode同样也是基于Chromim和Electron开发，并且支持TypeScript开发插件，而且启动速度比Atom快很多，而且作为微软面向开源社区的主力产品，它和TypeScript一样，吸收了社区的很多意见和贡献，使得软件越来越好用。在语言支持方面，对 C#、JavaScript、和 TypeScript 等编程语言的原生支持最为完善。</p><h2 id="安装VS-Code"><a href="#安装VS-Code" class="headerlink" title="安装VS Code"></a>安装VS Code</h2><p>官网提供的有vscode的安装包，windows用户下载stable版本的exe(System Installer)。</p><p>System Installer可以自动下载对应语言的环境包，推荐安装此版本。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/W1KvXk0ylxHa9w8E.png" class="" title="图片"><p>安装完成后就可以安装插件了。</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>插件系统是一个编辑器的左膀右臂，emacs和vim作为终端下开发经常使用的编辑器，就拥有非常丰富的插件，几乎每个大佬使用的emacs和vim都不能互换使用。</p><p>dde的项目几乎都是cmake的项目，所以需要安装cmake插件和c++的插件，安装了这两个插件以后。vscode打开项目工程就会自动解析CMakeLists.txt，并且开启vscode的快速调试功能，还可以开始构建项目和调试项目了。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/XvMxNUQrs9oyEYJF.png" class="" title="图片"><p>安装CMake、CMake Tools这两个插件就可以开发了。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/tBB60YiLW79oMLC1.png" class="" title="图片"><p>安装C/C++和C++ Intellisense这两个插件可以对项目中的c++代码进行智能感知和代码补全，推荐安装。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/idQexXGZXPrqCBby.png" class="" title="图片"><p>安装Remote - SSH插件，可以让vscode通过ssh连接到目标机器，打开远程机器的目录和文件，并且在该模式下，部分插件可以自动切换成本地/远程模式，这样就可以在本机直接开发，但是操作的内容都是远程环境的。</p><p>安装完Remote - SSH插件以后，vscode的左下角就会有一个绿色的按钮，可以用来切换模式。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/MWorTAHEAsJRt47E.png" class="" title="图片"><h2 id="配置远程环境"><a href="#配置远程环境" class="headerlink" title="配置远程环境"></a>配置远程环境</h2><p>因为是要在Windows上进行远程开发，如果是直接在UOS或者Deepin上开发DDE，这一部分是可以不用看的，上面的插件安装完成以后就可以开发项目了。</p><p>点击左下角的绿色按钮，在弹出的面板选择Remote-SSH: Connect to Host。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/WFN9jpqyRRXORtuP.png" class="" title="图片"><p>会继续弹出一个面板，用来选择配置ssh的连接。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/Cw7Z7sF3rb8RiBzZ.png" class="" title="图片"><p>选择Add New SSH Host添加一个服务器。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/qcXsO8ayHXyTMr62.png" class="" title="图片"><p>输入ssh的命令，例如 ssh <a href="mailto:&#x6c;&#120;&#122;&#x40;&#x31;&#x30;&#x2e;&#50;&#x30;&#x2e;&#51;&#50;&#x2e;&#53;&#52;">&#x6c;&#120;&#122;&#x40;&#x31;&#x30;&#x2e;&#50;&#x30;&#x2e;&#51;&#50;&#x2e;&#53;&#52;</a>。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/9Cla2rDtfzfsHVSh.png" class="" title="图片"><p>然后选择一个保存配置的位置，一般默认选择用户家目录的.ssh目录即可。然后就提示添加成功，此时可以点击Connect按钮进行连接。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/Do8KoBS0lwM1g09G.png" class="" title="图片"><p>输入密码</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/J7dPRyLYI4QBcma5.png" class="" title="图片"><p>登录以后会打开一个新的窗口，并提示正在连接。连接成功以后可以在左下角看到机器的信息。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/LjLHBXGQeuvXMk8k.png" class="" title="图片"><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/VJQhRC7LXbhWyWdN.png" class="" title="图片"><p>然后打开命令面板，选择在SSH中安装本地扩展。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/XJEqsfmwIO5FpUKS.png" class="" title="图片"><p>在打开的列表选择全选，然后安装。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/zmVjGPVL7gphBZ7h.png" class="" title="图片"><p>等待全部安装成功。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/P1yXbz7pkrwXOEAS.png" class="" title="图片"><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/WbxesoOf0RF1QqtZ.png" class="" title="图片"><h2 id="开发和调试"><a href="#开发和调试" class="headerlink" title="开发和调试"></a>开发和调试</h2><h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>CMake插件提供了编译、运行和调试的功能和命令，可以点击下方面板中的select target，选择要运行的目标程序，选择切换编译模式，可以选择Debug或者Release。还可以选择使用哪个编译器进行构建。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/je8iADCEbmCT7sMZ.png" class="" title="图片"><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/uUIxae7PVFDwSyUB.png" class="" title="图片"><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/Ah6NUPpjjoDIL93K.png" class="" title="图片"><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/UbibgDc1gL0tXNPy.png" class="" title="图片"><h3 id="设置启动参数"><a href="#设置启动参数" class="headerlink" title="设置启动参数"></a>设置启动参数</h3><p>如果程序启动不需要提供参数，则可以直接点击下方面板的Debug按钮，或者打开命令面板选择CMake Debug Target，如果没有选择过Target，则会询问一次设置Target。</p><p>点击左侧的调试按钮，选择添加配置。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/kTjwUYxwt19QlwPt.png" class="" title="图片"><p>在弹出的面板选择GDB</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/5Q4JOQWUZnDMtBNx.png" class="" title="图片"><p>此时vscode会创建出一个json文件，并生成了默认的配置文件。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/l1IZdMrxfd0dH45a.png" class="" title="图片"><p>我们需要进行一些调整，以便使用该配置文件进行调试。</p><p>program字段是程序二进制文件的位置，一般情况下我们是要手动写好路径，但是如果项目的二进制特别多，更换配置文件就会非常麻烦，而且配置文件里写死路径也不是很方便，我查阅了CMake插件的文档，发现CMake插件提供了两个很重要的变量，可以让我们方便的查找到路径。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"program": "$&#123;command:cmake.launchTargetPath&#125;"</span><br></pre></td></tr></table></figure><p>CMake插件提供了launchTargetPath的变量，它对应的是CMake插件选择的默认target，启动调试之前需要我们先选择好Target。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;value&quot;: &quot;$PATH:$&#123;command:cmake.launchTargetDirectory&#125;&quot;</span><br></pre></td></tr></table></figure><p>CMake插件还提供了launchTargetDirectory变量，用于获取程序启动所在的目录，一般需要我们指定到本次调试所需的环境变量中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;environment&quot;: [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;PATH&quot;,</span><br><span class="line">    &quot;value&quot;: &quot;$PATH:$&#123;command:cmake.launchTargetDirectory&#125;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后我们就可以添加启动参数了。<br>args字段保存了程序启动会传递的参数列表，例如这里会给fuse传递-d和/tmp/x。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;args&quot;: [</span><br><span class="line">  &quot;-d&quot;,</span><br><span class="line">  &quot;&#x2F;tmp&#x2F;x&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>完整的配置如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"(gdb) fuse"</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">    <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">    <span class="attr">"program"</span>: <span class="string">"$&#123;command:cmake.launchTargetPath&#125;"</span>,</span><br><span class="line">    <span class="attr">"args"</span>: [</span><br><span class="line">        <span class="string">"-d"</span>,</span><br><span class="line">        <span class="string">"/tmp/x"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"stopAtEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"cwd"</span>: <span class="string">"$&#123;workspaceFolder&#125;"</span>,</span><br><span class="line">    <span class="attr">"environment"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"PATH"</span>,</span><br><span class="line">            <span class="attr">"value"</span>: <span class="string">"$PATH:$&#123;command:cmake.launchTargetDirectory&#125;"</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"externalConsole"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"MIMode"</span>: <span class="string">"gdb"</span>,</span><br><span class="line">    <span class="attr">"setupCommands"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"为 gdb 启用整齐打印"</span>,</span><br><span class="line">            <span class="attr">"text"</span>: <span class="string">"-enable-pretty-printing"</span>,</span><br><span class="line">            <span class="attr">"ignoreFailures"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h3><p>此时我们就可以先通过CMake插件构建整个项目，再切换到运行面板，启动调试。</p><p>点击下方面板的Build按钮，构建项目。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/FAkfeLuV4JBsc4Mx.png" class="" title="图片"><p>再点击左侧的gdb fuse(deepin-turbo)按钮，因为配置文件里面我们起的名字是gdb fuse。我们在main函数添加一个断点，用来测试gdb是否工作正常。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/mKDIuN2GI1pSfVpQ.png" class="" title="图片"><p>一切都工作正常，在调试控制台可以使用-exec作为前缀来执行gdb的命令。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/sxNL1dJG5uFm22O1.png" class="" title="图片"><h3 id="调试图形程序"><a href="#调试图形程序" class="headerlink" title="调试图形程序"></a>调试图形程序</h3><p>调试图形程序稍微有一些麻烦，因为是远程开发，图形程序又只能工作在目标机器，这里提供两个可行的方案。</p><ol><li>synergy之类的键盘鼠标共享软件</li><li>在windows安装xserver</li></ol><p>第一种方案是通过共享本机的键盘鼠标到远程机器，这样就可以在远程环境上面进行直接操作，好处是除了调试，也可以同时操作远程机器进行使用。</p><p>第二种方案是利用X11协议的网络透明，既图形程序和显示服务不一定在同一台机器上运行，我们只需要在Windows安装XServer程序，就可以让远程机器上的程序的画面显示到当前机器，并且可以操作。但是此方案有缺点，虽然设计上这种分离结构设计的很巧妙，但是因为远程OpenGL调用并不支持，所以图形无法调用3D程序渲染，并且和远程机器沟通需要大量的带宽，所以用起来体验并不好。</p><p>为了使用这两种方案，我们都需要在调试的launch.json中添加一个环境变量。</p><p>在运行面板点击齿轮按钮，可以编辑当前方案。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/X32Q5bhGX2B7CLGg.png" class="" title="图片"><p>在打开的json文件中，找到environment字段，添加DISPLAY环境变量。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;environment&quot;: [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;DISPLAY&quot;,</span><br><span class="line">    &quot;value&quot;: &quot;:0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样程序启动就有DISPLAY环境变量，我们就可以让程序在目标机器的屏幕上运行了。</p><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/7JuWfnnURIt1NrdR.png" class="" title="图片"><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/20200903_023112910_iOS.jpg" class="" title="图片"><img src="/2020/09/03/use-vscode-to-remotely-develop-dde/20200903_023116260_iOS.jpg" class="" title="图片"><p>还有一种自动化测试的方案，该方案是我个人认为所有开发都应该掌握的，通过自动化测试，我们就可以完全使用远程开发来完成开发任务，调试的时候只需要等待自动测试结果返回即可，设想一下，某个模块需要点击很多地方才可以重现一个问题，我们只需要设置好断点，让程序自动开始执行所有函数，并在最终出现问题的地方停下，我们就可以开始手动单步跟踪问题，完全不需要使用鼠标人工点击。（然而理想很美好，现实很残酷，我个人目前都没有掌握自动化测试的方式，现在也是只能通过鼠标点点点来重现问题。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> VS Code </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在ArchLinux上开发startdde</title>
      <link href="/2020/08/06/develop-startdde-on-archlinux/"/>
      <url>/2020/08/06/develop-startdde-on-archlinux/</url>
      
        <content type="html"><![CDATA[<p>dde 后端使用 go 作为主要的开发语言，使用 dbus 提供接口，主要使用 gsettings 来保存配置。 所以在进行后端开发前需要对以上内容有基本的了解，这里假定本文档的阅读者熟悉 dbus 和 gsettings，并有一定的开发经验。</p><a id="more"></a><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>虽然本项目是go语言开发的，但是我们并没有直接使用go的mod作为依赖管理方案，而是走系统包管理器的方式，所以要先安装startdde的编译依赖。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -Sy golang-github-linuxdeepin-go-dbus-factory golang-deepin-gir golang-deepin-lib golang-deepin-dde-api go git jq golang-golang-x-net golang-github-linuxdeepin-go-x11-client</span><br></pre></td></tr></table></figure><p>这些包会被安装到系统的/usr/share/gocode目录下。还需要手动go get一个依赖到本地的GOPATH中。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get -v github.com/cryptix/wav</span><br></pre></td></tr></table></figure><h2 id="设置GOPATH"><a href="#设置GOPATH" class="headerlink" title="设置GOPATH"></a>设置GOPATH</h2><p>为了方便以后的开发，可以将GOPATH环境变量定义到~/.xprofile等文件中，或者shell的配置文件。例如我使用的zsh：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export GOPATH=$HOME/Develop/Go:/usr/share/gocode</span><br><span class="line">export PATH=$HOME/Develop/Go/bin:$PATH</span><br></pre></td></tr></table></figure><h2 id="设置项目目录"><a href="#设置项目目录" class="headerlink" title="设置项目目录"></a>设置项目目录</h2><p>go要求项目目录必须在GOPATH中，所以要将startdde放到GOPATH的pkg.deepin.io/dde/目录下，但是GOPATH每次进入不方便，可以采用软链的形式将startdde的目录链接到GOPATH下。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/Develop/Deepin</span><br><span class="line">git clone https://github.com/linuxdeepin/startdde</span><br><span class="line">mkdir -p ~/Develop/Go/src/pkg.deepin.io/dde/</span><br><span class="line">ln -sf ~/Develop/Deepin/startdde ~/Develop/Go/src/pkg.deepin.io/dde/startdde</span><br></pre></td></tr></table></figure><p>这样就可以在一个方便的目录进行开发了。</p><h2 id="vscode开发工具"><a href="#vscode开发工具" class="headerlink" title="vscode开发工具"></a>vscode开发工具</h2><p>我个人推荐使用vscode当作开发工具，打开vscode安装go的插件，打开startdde目录，vscode会提示安装一些go的工具，选择全部安装即可。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dde </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>use github action to check dde-launcher</title>
      <link href="/2020/07/27/use-github-action-to-check-dde-launcher/"/>
      <url>/2020/07/27/use-github-action-to-check-dde-launcher/</url>
      
        <content type="html"><![CDATA[<p>本来打算7月份给dde添加github action验证，但是被各种事情耽误了，然后发现麒麟居然抢在我前面部署了全套的github action，这不能忍，赶紧把dde的github action也提上日程。并且打算听<a href="https://github.com/felixonmars" target="_blank" rel="noopener">肥肥猫</a>大佬的话，在aur给dde弄一套commit构建包，这样就可以在arch上使用比testing仓库更testing的dde了！</p><a id="more"></a><p>github actions是github官方出的持续集成功能，以前大家在github上的项目都使用的第三方的Travis CI或者自建jenkins构建，但是github被微软收购以后，微软为了表现出给社区和用户的诚意，将大量github的付费功能免费公开给开发者使用，希望能将github打造成开发者中心，于是在2019年微软推出了免费的github actions，每个项目都可以免费使用官方提供的持续集成和持续部署功能，这对第三方业务无疑是个巨大的打击，虽然Travis CI和jenkins等方式仍然有一定的市场，但是对于中小项目的开源项目，使用官方提供的功能无疑是方便的。</p><p>github actions的配置十分简单，只需要几个简单的步骤就可以实现构建、执行和测试代码。并且可以使用Linux、Windows和MacOS环境，机器性能也十分强劲，编译速度非常的快。</p><p>这是给dde-launcher的一份基础配置，需要将配置文件放在.github/workflows/目录下，以build.yaml文件名保存。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">CI</span> <span class="string">Build</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">uos</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">uos</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">archlinux:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Archlinux</span> <span class="string">Build</span> <span class="string">Check</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">container:</span> <span class="string">docker.io/library/archlinux:latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">branch</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Refresh</span> <span class="string">pacman</span> <span class="string">repository</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">pacman</span> <span class="string">-Syy</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">build</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">pacman</span> <span class="string">-S</span> <span class="string">--noconfirm</span> <span class="string">base-devel</span> <span class="string">cmake</span> <span class="string">ninja</span> <span class="string">qt5-tools</span> <span class="string">deepin-qt-dbus-factory</span> <span class="string">dtkwidget</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CMake</span> <span class="string">&amp;</span> <span class="string">Make</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">mkdir</span> <span class="string">build</span></span><br><span class="line">          <span class="string">cd</span> <span class="string">build</span></span><br><span class="line">          <span class="string">cmake</span> <span class="string">../</span> <span class="string">-G</span> <span class="string">Ninja</span></span><br><span class="line">          <span class="string">ninja</span></span><br></pre></td></tr></table></figure><p>介绍一下配置文件吧，name是设置ci的名字，github允许有多个ci存在，可以做不同的事情，例如部署三个ci，一个做语法检查，一个做静态检查，一个做编译检查。name就是用来在界面上显示的。on是设置ci对哪些事件感兴趣，在这里我设置了push和pull_request，当发生push和pull request时，这个ci就会被启动，执行接下来的jobs的内容。jobs里是可以设置多个任务的，同样name字段也是用来展示本次动作的名称。runs-on是设置该job工作的环境，ubuntu-latest是linux环境，container是指使用哪个docker容器，github actions是可以使用docker的，也可以将自己的ci配置共享给其他人使用。run就是执行命令了，在配置文件中我手动运行了刷新仓库和编译项目所需的命令。job的steps可以理解成shell中一次动作的执行，uses是使用其他人封装好的命令，run则是执行本地命令。</p><p>可以看出github actions的配置是十分简单的，并且构建速度也非常的快，并且构建环境是使用的arch linux环境，为什么要选择arch作为ci的基础构建环境呢，原因当然不是因为和肥肥猫有py交易，arch上的dde更新速度很快，并且很多用户都使用arch+dde的方式使用linux，deepin自己维护的发行版因为基础仓库更新较慢，不适合一些用户，所以为了能让dde被更多的人接受和使用，在arch上及时更新dde是十分有必要的。所以才选择actions的环境为arch linux。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用perf工具分析程序性能</title>
      <link href="/2020/07/21/use-perf-to-analytics-program/"/>
      <url>/2020/07/21/use-perf-to-analytics-program/</url>
      
        <content type="html"><![CDATA[<p>最近在对DDE进行性能优化，所以补习了一下linux下的各种分析工具的使用方法。</p><img src="/2020/07/21/use-perf-to-analytics-program/bpf_performance_tools_book.png" class="" title="bpf_performance_tools_book.png"><p>这张图是来自Brendan Gregg大佬提供的linux分析工具的应用场景，可以看出几乎包含了系统每个地方应该用什么工具去分析。</p><a id="more"></a><h2 id="Linux-Perf-Tool"><a href="#Linux-Perf-Tool" class="headerlink" title="Linux Perf Tool"></a>Linux Perf Tool</h2><h3 id="允许系统进行分析"><a href="#允许系统进行分析" class="headerlink" title="允许系统进行分析"></a>允许系统进行分析</h3><p>为了能够正常分析，首先需要打开系统的调试功能，允许我们去对其他进程进行访问。</p><h3 id="SysCtl"><a href="#SysCtl" class="headerlink" title="SysCtl"></a>SysCtl</h3><p>较新的Linux内核具有sysfs可调参数<code>/proc/sys/kernel/perf_event_paranoid</code>，该参数允许用户调整perf_events非root用户的可用功能，数量越大则越安全（相应地提供较少的功能）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Consider tweaking &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;perf_event_paranoid:</span><br><span class="line"> -1 - Not paranoid at all</span><br><span class="line">  0 - Disallow raw tracepoint access for unpriv</span><br><span class="line">  1 - Disallow cpu events for unpriv</span><br><span class="line">  2 - Disallow kernel profiling for unpriv</span><br></pre></td></tr></table></figure><p>默认值是不允许获取任何信息，所以我们需要修改为1或者0，允许我们访问CPU的事件信息。</p><ul><li>临时修改</li></ul><p>执行命令向内核接口直接写入值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tee &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;perf_event_paranoid &lt;&lt;&lt; 1&#39;</span><br></pre></td></tr></table></figure><ul><li>永久修改</li></ul><p>使用sysctl来配置其值，创建<code>/etc/sysctl.d/50_perf_event_paranoid.conf</code>文件，并写入<code>kernel.perf_event_paranoid=1</code>，执行<code>sysctl -p</code>来刷新系统配置。</p><h3 id="perf-采样"><a href="#perf-采样" class="headerlink" title="perf 采样"></a>perf 采样</h3><blockquote><p>性能优化相关的三种类型的工具，一种是sampling类型的，即采样，这种工具就是不停“询问”程序在做什么，perf在我们使用的这种模式下就是 sampling模式，如果是追踪某些event，就工作在trace模式，实际上就是第二种类型的工具，这种工具主要依靠事件或者hook，程序在运行的过程中不停主动告诉工具它自己在做什么，比如 strace；第三种是 instrument 类型的，这种主要就是依赖编译器进行插桩，精确知道代码行级别的执行情况（参考gcc instrumentation ）。</p><p>by hualet on <a href="https://docsin.uniontech.com/?p=735" target="_blank" rel="noopener">deepin 15.7</a></p></blockquote><p>我们通过perf record命令才对程序进行采样记录。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perf record -g --call-graph&#x3D;dwarf -F 99 &#x2F;usr&#x2F;bin&#x2F;dde-shutdown</span><br></pre></td></tr></table></figure><p>命令介绍：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-g: 即采样全部信息</span><br><span class="line">--call-graph: 设置并启用调用图（堆栈链&#x2F;回溯）记录，参数有fp(frame pointers)、dwarf(debug information)和lbr(Last Branch Record)。</span><br><span class="line">-F: 采样率</span><br></pre></td></tr></table></figure><p>perf可以直接启动一个程序进行分析，也可以使用-p参数指定一个pid进行采样。</p><h3 id="查看-perf-的采样结果"><a href="#查看-perf-的采样结果" class="headerlink" title="查看 perf 的采样结果"></a>查看 perf 的采样结果</h3><p>当我们通过perf record完成采样以后，会在执行目录生成perf.data文件，此时我们就可以使用perf report命令对data文件进行数据分析了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perf report --stdio</span><br></pre></td></tr></table></figure><p>perf report会自动打开当前目录下的perf.data文件，当然也可以在最后指定perf.data文件的路径。</p><p>perf report会根据–call-graph参数来生成不同的图，使用dwarf参数时会以函数调用栈的顺序来显示，使用这种方式可以方便的看出哪个函数执行的时间比较长，因为每次采样都能落到该函数上，也就意味着函数执行的时间非常长，再通过调用栈的深度来分析函数执行期间都在做什么事情。</p><h3 id="hotspot火焰图"><a href="#hotspot火焰图" class="headerlink" title="hotspot火焰图"></a>hotspot火焰图</h3><p>在命令行下查看函数调用不是特别方便，所以就有图形化的工具用来方便的查看perf工具的生成结果，其中使用比较友好的是kde开发的hotspot工具，该工具可以直接打开perf.data文件，并生成对应的火焰图，火焰图是函数调用的另一种表现形式，火焰越高，也就意味着调用栈越深，火焰越广，也就意味着函数执行的时间很长。</p>]]></content>
      
      
      <categories>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTest &amp; QTest/GTest</title>
      <link href="/2020/06/16/CTest%20&amp;%20QTEST/"/>
      <url>/2020/06/16/CTest%20&amp;%20QTEST/</url>
      
        <content type="html"><![CDATA[<p>本文会介绍一下QTest和GTest的一些功能和区别。</p><a id="more"></a><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><h2 id="ctest"><a href="#ctest" class="headerlink" title="ctest"></a>ctest</h2><p>ctest是CMake提供的运行单元测试的工具，在使用CMakeLists.txt文件编译工程的时候，CTest会自动configure、build、test和展现测试结果。</p><p>ctest有两个模式：</p><ul><li>模式一：使用CMake configure和build工程，在CMakeLists.txt，使用特殊的命令创建tests。使用CTest来执行那些测试。</li><li>模式二：使用CTest来执行一个script，这个script的语法必须和CMakeLists.txt相同。</li></ul><p>使用方法：</p><p>在CMakeLists.txt使用include(CTest)和include(Dart)来导入CTest模块和开启ctest。使用add_test()来添加一个测试程序，测试程序是一个普通的二进制，只不过内部运行的是qtest或者gtest编写的测试用例。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include(CTest)</span><br><span class="line">include(Dart)</span><br><span class="line">add_executable(tests tests&#x2F;test.cpp)</span><br><span class="line">add(NAME tests COMMAND $&lt;TARGET_FILE:tests&gt;)</span><br></pre></td></tr></table></figure><h2 id="qt-qtest"><a href="#qt-qtest" class="headerlink" title="qt qtest"></a>qt qtest</h2><p>qtest是Qt提供的单元测试框架，Qt Test是用于对基于Qt的应用程序和库进行单元测试的框架。Qt Test提供了单元测试框架中常见的所有功能以及用于测试图形用户界面的扩展。</p><p>Qt测试旨在简化基于Qt的应用程序和库的单元测试的编写：</p><table><thead><tr><th align="left">特征</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">轻量</td><td align="left">Qt Test大约有6000行代码和60个导出符号组成</td></tr><tr><td align="left">自成体系</td><td align="left">Qt Test仅需要Qt Core模块中的几个符号即可进行非GUI测试</td></tr><tr><td align="left">快速测试</td><td align="left">Qt Test不需要特殊的测试运行程序，没有特殊的测试注册</td></tr><tr><td align="left">数据驱动测试</td><td align="left">可以使用不同的数据进行多次的测试</td></tr><tr><td align="left">基本的GUI测试</td><td align="left">Qt Test提供了用于鼠标和键盘的模拟功能</td></tr><tr><td align="left">标杆管理</td><td align="left">Qt Test支持基准测试，并提供多个测量后端</td></tr><tr><td align="left">IDE友好</td><td align="left">Qt Test输出可以由Qt Creator、Visual Studio等IDE解释的消息</td></tr><tr><td align="left">线程安全</td><td align="left">错误报告是线程安全和原子的</td></tr><tr><td align="left">类型安全</td><td align="left">模板的广泛使用可以防止隐式类型转换引起的错误</td></tr><tr><td align="left">易于扩展</td><td align="left">可以将自定义类型轻松添加到测试数据和测试输出中</td></tr></tbody></table><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>QVERIFY() 用于验证数据是否正确。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QVERIFY(<span class="number">1</span> == <span class="number">1</span>);</span><br><span class="line">QVERIFY2(<span class="number">1</span> != <span class="number">1</span>, <span class="string">"1不等于1"</span>);</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>QFETCH_GLOBAL() 该宏从全局数据表中的一行中获取类型类型为name的变量。 名称和类型必须与全局数据表中的列匹配。 这是断言，如果断言失败，则测试将中止。</p><p>QFETCH() 宏会在堆栈上创建一个类型为name的本地变量。 名称和类型必须与测试数据表中的列匹配。 这是断言，如果断言失败，则测试将中止。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QFETCH(QString, aString);</span><br><span class="line">QFETCH_GLOBAL(QLocale, locale);</span><br></pre></td></tr></table></figure><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>QCOMPARE宏用于判断两个值是否相等，如果实际值和预期值匹配，将会继续运行，否则将失败记录在测试日至中，并且测试将被终止，不会尝试任何后续操作。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QCOMPARE(QString(<span class="string">"hello"</span>).toUpper(), QString(<span class="string">"HELLO"</span>));</span><br></pre></td></tr></table></figure><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p>通过在包含_data()的函数中调用QTest::addColumn和QTest::newRow向测试用例增加数据，并通过QFETCH宏在测试用例中访问数据。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestQString::toInt_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QTest::addColumn&lt;QString&gt;(<span class="string">"aString"</span>);</span><br><span class="line">    QTest::addColumn&lt;<span class="keyword">int</span>&gt;(<span class="string">"expected"</span>);</span><br><span class="line">    QTest::newRow(<span class="string">"positive value"</span>) &lt;&lt; <span class="string">"42"</span> &lt;&lt; <span class="number">42</span>;</span><br><span class="line">    QTest::newRow(<span class="string">"negative value"</span>) &lt;&lt; <span class="string">"-42"</span> &lt;&lt; <span class="number">-42</span>;</span><br><span class="line">    QTest::newRow(<span class="string">"zero"</span>) &lt;&lt; <span class="string">"0"</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestQString::toInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     QFETCH(QString, aString);</span><br><span class="line">     QFETCH(<span class="keyword">int</span>, expected);</span><br><span class="line">     QCOMPARE(aString.toInt(), expected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建测试"><a href="#创建测试" class="headerlink" title="创建测试"></a>创建测试</h3><p>要创建测试，需要派生自QObject，并添加一个或多个专用槽函数。每个专用槽函数都是测试中的一个测试功能且必须为private。函数命名方法以casen_函数名或者以test结尾的方式。</p><p>使用QTest::qExec()可用于执行测试对象中的所有测试功能。</p><p>此外，还可以定义不用于测试功能的专用槽函数。如果存在，它们将由测试框架执行，并用于初始化和清除整个测试或当前的测试功能。</p><ul><li><strong>initTestCase()</strong> 将在第一个测试功能执行之前被调用</li><li><strong>initTestCase_data()</strong> 将被调用以创建全局测试数据表</li><li><strong>cleanupTestCase()</strong> 在最后一个测试函数执行后被调用</li><li><strong>init()</strong> 将在每个测试功能执行之前被调用</li><li><strong>cleanup()</strong> 将在每个测试函数之后调用</li></ul><p>使用initTestCase()准备测试。每次测试都应使系统处于可用状态，因此可以重复运行。清理操作应在cleanupTestCase()中处理，因此即使测试失败也可以运行清理操作。</p><p>使用init()创建测试功能。每个测试功能都应使系统保持可用状态，以便可以重复运行。清理操作应在cleanup()中，即使测试功能失败并提前退出，清理动作也可以运行。</p><p>另外，可以使用RAII,并在析构函数中调用清除操作，以确保他们在测试函数返回且对象移出作用域时发生。</p><p>如果initTestCase()失败，将不执行任何测试功能。如果init()失败，则不执行以下测试功能，测试将继续进行下一个测试功能。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">  Q_OBJECT</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">verify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">initTestCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"init test case"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">firstTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QVERIFY(<span class="literal">true</span>);</span><br><span class="line">    QCOMPARE(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">secondTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QVERIFY(verify());</span><br><span class="line">    QVERIFY(<span class="number">1</span> != <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cleanupTestCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"clean test case"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后，如果测试类具有静态且公共的void initMain()方法，则在实例化QApplication对象之前，由QTEST_MAIN宏调用该方法。例如，这允许设置应用程序的属性，例如Qt::AA_DisableHighDpiScaling。这是在Qt5.14添加的。</p><h3 id="使用CMake和CTest构建测试项目"><a href="#使用CMake和CTest构建测试项目" class="headerlink" title="使用CMake和CTest构建测试项目"></a>使用CMake和CTest构建测试项目</h3><p>CMake还有其他优点。例如，几乎可以毫不费力地使用CDash将测试运行的结果发布到Web服务器上。</p><p>CTest可以扩展到非常不同的单元测试框架，并且可以与QTest一起使用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">project(mytest LANGUAGES CXX)</span><br><span class="line">include(CTest)</span><br><span class="line">include(Dart)</span><br><span class="line">find_package(Qt5 COMPONENTS Test REQUIRED)</span><br><span class="line">set(CMAKE_INCLUDE_CURRENT_DIR ON)</span><br><span class="line">set(CMAKE_AUTOMOC ON)</span><br><span class="line">add_executable(mytest tst_mytest.cpp)</span><br><span class="line">add_test(NAME mytest COMMAND mytest)</span><br><span class="line">target_link_libraries(mytest PRIVATE Qt5::Test)</span><br></pre></td></tr></table></figure><h2 id="google-test"><a href="#google-test" class="headerlink" title="google test"></a>google test</h2><p>google test(gtest)是google公司推出的c++单元测试框架，基于xUnit架构，并且支持Linux、Windows和mac，并且支持任何类型的测试和模拟，而不仅仅是单元测试。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>当使用gtest时，通过编写断言来检查条件是否为真。断言的结果可能是成功、非致命失败或者致命失败。如果发生致命故障，将终止当前功能，否则将继续运行。</p><p>一个测试套件包含一个或者多个测试。当测试套件中的多个测试需要共享通用对象和子例程时，可以将他们放入一个测试桶中。</p><p>一个测试程序可以包含多个测试套件。</p><h3 id="断言-1"><a href="#断言-1" class="headerlink" title="断言"></a>断言</h3><p>gtest断言类似于函数调用的宏，可以通过断言其行为来测试类或者函数。断言失败时，gtest会输出断言的源文件和行号位置以及失败消息。还可以提供自定义失败消息，该消息将会附加到gtest的消息之后。</p><p>断言成对出现，测试相同的事物，但是对当前函数有不同的影响。ASSERT_<em>版本失败时会产生致命错误，并终止当前功能。EXPECT_</em>会产生非致命错误，不会导致当前测试失败。通常EXPECT_<em>是首选，因为他们允许在测试中报告多个鼓掌，但是如果在断言失败时继续运行将没有意义时应当使用ASSERT_</em>。</p><p>由于ASSERT_*失败会从当前函数立即返回，可能会跳过其后的清理代码，导致内存泄漏。</p><h3 id="基本断言"><a href="#基本断言" class="headerlink" title="基本断言"></a>基本断言</h3><p>基本断言可以进行基本的真/假条件测试</p><table><thead><tr><th align="left">致命断言</th><th align="left">非致命断言</th><th align="left">验证</th></tr></thead><tbody><tr><td align="left">ASSERT_TRUE(condition);</td><td align="left">EXPECT_TRUE(condition);</td><td align="left">condition是真的</td></tr><tr><td align="left">ASSERT_FALSE(condition);</td><td align="left">EXPECT_FLASE(condition);</td><td align="left">condition是假的</td></tr></tbody></table><p>请记住，当它们失败时，将导致ASSERT_<em>致命故障并从当前函数返回，而当它们发生EXPECT_</em>非致命故障时，将允许该函数继续运行。无论哪种情况，断言失败都意味着其包含测试失败。</p><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>该组中的断言比较两个C字符串。如果要比较两个string对象，请改用EXPECT_EQ，EXPECT_NE等。</p><table><thead><tr><th align="center">致命断言</th><th align="center">非致命断言</th><th align="center">验证</th></tr></thead><tbody><tr><td align="center">ASSERT_STREQ(str1,str2);</td><td align="center">EXPECT_STREQ(str1,str2);</td><td align="center">这两个C字符串的内容相同</td></tr><tr><td align="center">ASSERT_STRNE(str1,str2);</td><td align="center">EXPECT_STRNE(str1,str2);</td><td align="center">两个C字符串的内容不同</td></tr><tr><td align="center">ASSERT_STRCASEEQ(str1,str2);</td><td align="center">EXPECT_STRCASEEQ(str1,str2);</td><td align="center">两个C字符串的内容相同，忽略大小写</td></tr><tr><td align="center">ASSERT_STRCASENE(str1,str2);</td><td align="center">EXPECT_STRCASENE(str1,str2);</td><td align="center">两个C字符串的内容不同，忽略大小写</td></tr></tbody></table><p>注意，断言名称中的“ CASE”表示忽略大小写。一个NULL 指针和一个空字符串被认为是不同的。</p><p><em>STREQ</em>并<em>STRNE</em>接受宽C字符串（wchar_t*）。如果两个宽字符串的比较失败，则它们的值将打印为UTF-8窄字符串。</p><h3 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h3><p>创建测试：</p><ol><li>使用TEST()宏定义和命名测试功能。这些是没有返回值的普通C++函数。</li><li>在此函数，要与包含的所有有效C++语句一起使用各种gtest断言来检查。</li><li>测试结果由断言确定，如果测试中的任何声明失败（致命或非致命），或者测试崩溃，整个测试都会失败，否则测试应当成功。</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TEST(TestSuiteName, TestName) &#123;</span><br><span class="line">  ...测试代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TEST()函数第一个参数是测试套件的名称，第二个参数是测试套件内的测试名称。这两个名称都必须是有效的C++标识符，并且不应包含任何下划线。来自不同测试套件的测试可以具有相同的名称。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><h2 id="qtest"><a href="#qtest" class="headerlink" title="qtest"></a>qtest</h2><p><a href="https://doc.qt.io/qt-5/qtest.html" target="_blank" rel="noopener">https://doc.qt.io/qt-5/qtest.html</a></p><h2 id="gtest"><a href="#gtest" class="headerlink" title="gtest"></a>gtest</h2><p><a href="https://github.com/google/googletest/blob/master/googletest/docs/primer.md" target="_blank" rel="noopener">https://github.com/google/googletest/blob/master/googletest/docs/primer.md</a></p>]]></content>
      
      
      <categories>
          
          <category> unit test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> C++ </tag>
            
            <tag> CMake </tag>
            
            <tag> GTest </tag>
            
            <tag> CTest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP项目的一些坑</title>
      <link href="/2020/06/15/CPP%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
      <url>/2020/06/15/CPP%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>本篇文章记录这几年项目中C++的一些问题和优化方法。需要注意的是，代码优化没有一本万利的方法，只能见招拆招，而且还要避免过早优化等问题，代码优化一定是要中后期才可以，而且不要为了优化而优化。</p><a id="more"></a><h2 id="const和const-amp"><a href="#const和const-amp" class="headerlink" title="const和const &amp;"></a>const和const &amp;</h2><p>在接收一个返回值或者声明局部只读变量时没有使用const修饰。const的目的不仅仅是为了只读，更多的是编译器可以在此处提供优化。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QRect <span class="built_in">rect</span> = m_displayInter-&gt;primaryRawRect();</span><br><span class="line">qreal scale = qApp-&gt;primaryScreen()-&gt;devicePixelRatio();</span><br></pre></td></tr></table></figure><p>在这两行例子中，react和scale都在当前函数内没有任何修改，而且不应该修改，需要添加const来修饰只读，并且QRect应该使用&amp;来减少内存复制带来的额外影响。</p><h2 id="类型强转"><a href="#类型强转" class="headerlink" title="类型强转"></a>类型强转</h2><p>在部分代码中，经常能看到C风格的代码强转，应当根据具体情况使用static_cast、dynamic_cast和reinterpret_cast。</p><p>static_cast是使用的比较多的cast，经常用于派生类和基类之间转换。dynamic_cast也用于派生类和基类的转换，如果类型T是指针类型，若转换失败，则返回T类型的空指针，如果时T是引用类型，则会抛出异常，返回std::bad_cast。reinterpret_cast并不会做实际的转换，只会在编译时进行检查，如果不能进行cast转换，则编译报错。</p><h2 id="过多的嵌套"><a href="#过多的嵌套" class="headerlink" title="过多的嵌套"></a>过多的嵌套</h2><p>过多的嵌套会严重影响代码阅读，经常出现只有if通过才会进入执行的情况，这种情况应该修改为不通过就不要继续执行，或者安排合理的if将条件限制在之前。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BluetoothWorker::setAdapterPowered</span><span class="params">(<span class="keyword">const</span> Adapter *adapter, <span class="keyword">const</span> <span class="keyword">bool</span> &amp;powered)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QDBusObjectPath <span class="title">path</span><span class="params">(adapter-&gt;id())</span></span>;</span><br><span class="line">    <span class="comment">//关闭蓝牙之前删除历史蓝牙设备列表，确保完全是删除后再设置开关</span></span><br><span class="line">    <span class="keyword">if</span> (!powered) &#123;</span><br><span class="line">        QDBusPendingCall call = m_bluetoothInter-&gt;ClearUnpairedDevice();</span><br><span class="line">        QDBusPendingCallWatcher *watcher = <span class="keyword">new</span> QDBusPendingCallWatcher(call, <span class="keyword">this</span>);</span><br><span class="line">        <span class="built_in">connect</span>(watcher, &amp;QDBusPendingCallWatcher::finished, [ = ] &#123;</span><br><span class="line">            <span class="keyword">if</span> (!call.isError()) &#123;</span><br><span class="line">                QDBusPendingCall adapterPoweredOffCall  = m_bluetoothInter-&gt;SetAdapterPowered(path, <span class="literal">false</span>);</span><br><span class="line">                QDBusPendingCallWatcher *watcher = <span class="keyword">new</span> QDBusPendingCallWatcher(adapterPoweredOffCall, <span class="keyword">this</span>);</span><br><span class="line">                <span class="built_in">connect</span>(watcher, &amp;QDBusPendingCallWatcher::finished, [<span class="keyword">this</span>, adapterPoweredOffCall, adapter] &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!adapterPoweredOffCall.isError()) &#123;</span><br><span class="line">                        setAdapterDiscoverable(adapter-&gt;id());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        qWarning() &lt;&lt; adapterPoweredOffCall.error().message();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                qWarning() &lt;&lt; call.error().message();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        QDBusPendingCall adapterPoweredOnCall  = m_bluetoothInter-&gt;SetAdapterPowered(path, <span class="literal">true</span>);</span><br><span class="line">        QDBusPendingCallWatcher *watcher = <span class="keyword">new</span> QDBusPendingCallWatcher(adapterPoweredOnCall, <span class="keyword">this</span>);</span><br><span class="line">        <span class="built_in">connect</span>(watcher, &amp;QDBusPendingCallWatcher::finished, [<span class="keyword">this</span>, adapterPoweredOnCall, adapter] &#123;</span><br><span class="line">            <span class="keyword">if</span> (!adapterPoweredOnCall.isError()) &#123;</span><br><span class="line">                setAdapterDiscoverable(adapter-&gt;id());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                qWarning() &lt;&lt; adapterPoweredOnCall.error().message();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码其实是可以优化的，我们可以通过三元表达式获取某个QDBusPendingCall，这样就可以使用一个QDBusPendingCallWatcher对象，然后将原本的lambda内容提取到其他函数内，在新的lambda中同样使用三元表达式运行对应的函数，这样拆分代码的好处是，阅读代码时的顺序会和执行顺序一致，分支判断对机器和人类都不是太友好，特别是判断体内有很长的代码段，找到else段是一件不容易的事情，通过降低if else块来提高代码可读性。同时应提取相同动作的代码到公共区域，以免将来修改时发现没有将所有的地方都做修改。</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>避免使用数组的方式来访问元素，使用迭代器的方式统一循环方式。</p><p>我注意到有些情况下，有人在for循环内直接定义静态变量，这种方式使用的时候需要注意，静态变量将会永远存在，但是大部分for循环内需要保存的数据都是成员变量，否则内存空间将永远不会释放，对内存有浪费。</p><p>而且经常遇到的问题就是foreach宏和for混用，在语法上就没有统一使用。</p><p>我推荐的方式是for+迭代器的方式，如果是简单遍历，使用原生的foreach语法即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原生foreach语法，推荐只读遍历使用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> item: <span class="built_in">list</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for+迭代器，只读遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">list</span>.cbegin(); it != <span class="built_in">list</span>.cend(); ++it) &#123;</span><br><span class="line">    <span class="comment">// it是迭代器对象，需要解引用使用。</span></span><br><span class="line">    *it</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for+迭代器方式，推荐需要修改容器的长度使用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">list</span>.<span class="built_in">begin</span>(); it != <span class="built_in">list</span>.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="comment">// 注意，如果要移除某个元素，需要手动下一步</span></span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">2</span>) &#123;</span><br><span class="line">        it = <span class="built_in">list</span>.erase(it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>经常遇到使用容器将指针保存下来的场景，但是当对象被析构或者容器被清空的时候，有时候会忘记删除内部的对象，或者删除了不该删除的对象。对数据的处理应该保持RAII原则，避免直接使用裸指针，而是通过智能指针将指针保存起来，当最后一个对象不再持有智能指针对象时，智能指针会删除持有的对象，完成内存释放。</p><p>智能指针的类型</p><p>智能指针包含有三种：独占指针<code>unique_ptr</code>、共享指针<code>shared_ptr</code>和弱引用指针<code>week_ptr</code>。</p><h3 id="独占指针"><a href="#独占指针" class="headerlink" title="独占指针"></a>独占指针</h3><p>独占指针<code>std::unique_ptr</code>可以避免对象被转移到其他对象中，如果某个对象持有<code>unique_ptr</code>，则该ptr不允许转移给其他对象，但是可以使用<code>std::move</code>来转移控制权，注意这和普通的转移不一样，<code>unique_ptr</code>禁止的是拷贝，但是没有禁止移动，我们可以转移控制转，<code>unique_ptr</code>保证的是只有一个智能指针持有对象。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; p1 = <span class="built_in">std</span>::<span class="built_in">move</span>(ptr);</span><br></pre></td></tr></table></figure><h3 id="共享指针"><a href="#共享指针" class="headerlink" title="共享指针"></a>共享指针</h3><p>共享指针<code>std::shared_ptr</code>顾名思义是用作共享的，和独占指针不同的是，它支持复制，内部通过引用计数来维持对象的生命周期，当没有任何一个对象持有共享指针时，也就意味着没有任何一个对象可以访问到内部对象了，就可以安全的删除对象，释放内存。</p><h4 id="弱引用指针"><a href="#弱引用指针" class="headerlink" title="弱引用指针"></a>弱引用指针</h4><p>弱引用指针<code>std::week_ptr</code>是为了避免两个共享指针相互持有导致引用计数永远不会归零，导致内存永远不释放而提出的解决方案，具体就是弱引用指针不会导致引用计数增加，但是week_ptr同样不支持复制，必须转换为共享指针<code>std::shared_ptr</code>。</p><h2 id="优化判断条件"><a href="#优化判断条件" class="headerlink" title="优化判断条件"></a>优化判断条件</h2><p>对于常数的判断，尽量使用宏或者定义静态常量来避免直接使用数字或者字符判断。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>发现很多人在需要排序的时候总是使用冒泡算法，我介绍几个比较方便的排序方法。</p><h3 id="使用std-sort"><a href="#使用std-sort" class="headerlink" title="使用std::sort"></a>使用std::sort</h3><p>C++标准库提供了<code>std::sort</code>方法来方便的排序，它有三个参数，第一个参数是容器的begin迭代器，第二个参数是end迭代器，第三个参数接收一个返回值为bool类型的函数，该函数用于实现手动控制排序的判断。</p><p>我们可以提供一个lambda表达式来方便的控制排序，或者提供一个函数指针。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>&#123; <span class="number">10</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::sort(<span class="built_in">list</span>.<span class="built_in">begin</span>(), <span class="built_in">list</span>.<span class="built_in">end</span>(), [](<span class="keyword">int</span> num1, <span class="keyword">int</span> num2) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 &lt; num2;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种排序方式是直接对原始容器进行操作的，如果不希望数据成为脏数据，应该先复制一份。</p><h3 id="使用容器"><a href="#使用容器" class="headerlink" title="使用容器"></a>使用容器</h3><p>使用容器的方式比较麻烦一些，我们需要对象自己支持大小比较，或者顺序是外部某个列表列表控制的。</p><p>我们可以使用map将内部数据和标记数据建立映射关系，再通过外部的list或者其他方式，从map中将数据读出来，添加到新的列表容器中，从而完成排序。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="string">"page1"</span>, <span class="string">"page2"</span>, <span class="string">"page3"</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">String</span>, QWidget*&gt; <span class="built_in">map</span>;</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> StringList &amp; <span class="built_in">list</span> = QJsonDocument::fromJson(readAll(“order.json”)).toStdList();</span><br><span class="line"></span><br><span class="line">QList&lt;QWidget*&gt; pages;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> QString&amp; key : <span class="built_in">list</span>) &#123;</span><br><span class="line">    pages &lt;&lt; <span class="built_in">map</span>[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用inquirer提供交互式git commit</title>
      <link href="/2020/06/15/%E4%BD%BF%E7%94%A8inquirer%E6%8F%90%E4%BE%9B%E4%BA%A4%E4%BA%92%E5%BC%8Fgit-commit/"/>
      <url>/2020/06/15/%E4%BD%BF%E7%94%A8inquirer%E6%8F%90%E4%BE%9B%E4%BA%A4%E4%BA%92%E5%BC%8Fgit-commit/</url>
      
        <content type="html"><![CDATA[<p>公司计划规范所有commit提交，开发部门综合出来了一份模板。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title（应当使用陈述句，简短的描述这个提交所做的事情）</span><br><span class="line"></span><br><span class="line">Description（详细说明代码的改动，包含代码的实现思路，以及为什么这么做，可能会影响哪些功能。对于代码的审核者，需要从这段描述中能完全理解代码中所有改动的内容）</span><br><span class="line"></span><br><span class="line">Log: 写一段面向于产品的总结性内容，用于自动生成crp上的changlog，需要注意的事，这段描述必须从产品的角度考虑。</span><br><span class="line">Bug: https:&#x2F;&#x2F;xxxxxxxxxxx 对应pms bug的链接</span><br><span class="line">Issue: fix #xx 所修复的bug对于的github issue，其中 &quot;fix #xx&quot;是github关闭issue的规则，此处内容只需要满足github的要求即可，详情请参考 https:&#x2F;&#x2F;help.github.com&#x2F;en&#x2F;enterprise&#x2F;2.16&#x2F;user&#x2F;github&#x2F;managing-your-work-on-github&#x2F;closing-issues-using-keywords</span><br><span class="line">Task: http:&#x2F;&#x2F;xxxxxxxxxxxx 对应pms任务的链接</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="python-inquirer"><a href="#python-inquirer" class="headerlink" title="python inquirer"></a>python inquirer</h2><p>之前在掘金上看到有人在使用交互式的commit来规范commit信息，觉得用起来挺不错的，刚好符合本次公司的要求，不过原项目是nodejs的，项目里肯定不能让每个开发都安装一个node,所以就找一下代替品，然后就发现了<a href="https://github.com/magmax/python-inquirer" target="_blank" rel="noopener">python-inquirer</a>。</p><p>使用起来也非常的方便，通过inquirer.Text、inquirer.List、inquirer.Checkbox就可以创建相应的交互，并把组合好的列表交给inquirer.prompt处理，返回一个对象，内部包含了所有做出的选择。</p><h3 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> inquirer</span><br><span class="line">questions = [</span><br><span class="line">  inquirer.Text(<span class="string">'name'</span>, message=<span class="string">"What's your name"</span>),</span><br><span class="line">  inquirer.Text(<span class="string">'surname'</span>, message=<span class="string">"What's your surname"</span>),</span><br><span class="line">  inquirer.Text(<span class="string">'phone'</span>, message=<span class="string">"What's your phone number"</span>,</span><br><span class="line">                validate=<span class="keyword">lambda</span> _, x: re.match(<span class="string">'\+?\d[\d ]+\d'</span>, x),</span><br><span class="line">                )</span><br><span class="line">]</span><br><span class="line">answers = inquirer.prompt(questions)</span><br></pre></td></tr></table></figure><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> inquirer</span><br><span class="line">questions = [</span><br><span class="line">  inquirer.List(<span class="string">'size'</span>,</span><br><span class="line">                message=<span class="string">"What size do you need?"</span>,</span><br><span class="line">                choices=[<span class="string">'Jumbo'</span>, <span class="string">'Large'</span>, <span class="string">'Standard'</span>, <span class="string">'Medium'</span>, <span class="string">'Small'</span>, <span class="string">'Micro'</span>],</span><br><span class="line">            ),</span><br><span class="line">]</span><br><span class="line">answers = inquirer.prompt(questions)</span><br></pre></td></tr></table></figure><h3 id="CheckBox"><a href="#CheckBox" class="headerlink" title="CheckBox"></a>CheckBox</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> inquirer</span><br><span class="line">questions = [</span><br><span class="line">  inquirer.Checkbox(<span class="string">'interests'</span>,</span><br><span class="line">                    message=<span class="string">"What are you interested in?"</span>,</span><br><span class="line">                    choices=[<span class="string">'Computers'</span>, <span class="string">'Books'</span>, <span class="string">'Science'</span>, <span class="string">'Nature'</span>, <span class="string">'Fantasy'</span>, <span class="string">'History'</span>],</span><br><span class="line">                    ),</span><br><span class="line">]</span><br><span class="line">answers = inquirer.prompt(questions)</span><br></pre></td></tr></table></figure><h2 id="公司的模板"><a href="#公司的模板" class="headerlink" title="公司的模板"></a>公司的模板</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> inquirer</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> Template</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">number_validation</span><span class="params">(answers, current)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> int(current)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">empty_validation</span><span class="params">(answers, current)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> bool(current)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">no_validation</span><span class="params">(answers, current)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addList</span><span class="params">(name, message, list)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> inquirer.List(name, message, list)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addText</span><span class="params">(name, message, valid)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> inquirer.Text(name, message, validate=valid)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addCheck</span><span class="params">(_name, _message, _choices)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> inquirer.Checkbox(_name, message=_message, choices=_choices)</span><br><span class="line"></span><br><span class="line">questions = [</span><br><span class="line">  addCheck(<span class="string">"action"</span>, <span class="string">"选择非选项"</span>, [<span class="string">'Bug'</span>, <span class="string">'Issue'</span>, <span class="string">'Task'</span>])</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">optinalAnswers = inquirer.prompt(questions)</span><br><span class="line"></span><br><span class="line">questions = [</span><br><span class="line">  addList(<span class="string">'action'</span>, <span class="string">"select you action"</span>, [<span class="string">'fix'</span>, <span class="string">'feat'</span>, <span class="string">'refactor'</span>, <span class="string">'docs'</span>, <span class="string">'chore'</span>, <span class="string">'style'</span>, <span class="string">'pref'</span>, <span class="string">'test'</span>]),</span><br><span class="line">  addText(<span class="string">"module"</span>, <span class="string">"input module name"</span>, no_validation),</span><br><span class="line">  addText(<span class="string">'title'</span>, <span class="string">"input title"</span>, empty_validation),</span><br><span class="line">  addText(<span class="string">'description'</span>, <span class="string">"input description"</span>, empty_validation),</span><br><span class="line">  addText(<span class="string">"log"</span>, <span class="string">"input log"</span>, empty_validation),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">optinal = &#123;</span><br><span class="line">  <span class="string">"Bug"</span>: addText(<span class="string">"bug"</span>, <span class="string">"input bug id"</span>, number_validation),</span><br><span class="line">  <span class="string">"Issue"</span>: addText(<span class="string">"issue"</span>, <span class="string">"input issue id"</span>, empty_validation),</span><br><span class="line">  <span class="string">"Task"</span>: addText(<span class="string">"task"</span>, <span class="string">"input task id"</span>, number_validation),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">optinalMap = &#123;</span><br><span class="line">  <span class="string">"Bug"</span>: <span class="string">"bug"</span>,</span><br><span class="line">  <span class="string">"Issue"</span>: <span class="string">"issue"</span>,</span><br><span class="line">  <span class="string">"Task"</span>: <span class="string">"task"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> action <span class="keyword">in</span> optinalAnswers[<span class="string">"action"</span>]:</span><br><span class="line">  questions.append(optinal[action])</span><br><span class="line"></span><br><span class="line">answers = inquirer.prompt(questions)</span><br><span class="line"></span><br><span class="line">template = <span class="string">'$&#123;action&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> answers[<span class="string">"module"</span>]:</span><br><span class="line">  template += <span class="string">'($&#123;module&#125;)'</span></span><br><span class="line"></span><br><span class="line">template += <span class="string">': $&#123;title&#125;\n\nDescription: $&#123;description&#125;\n\nLog: $&#123;log&#125;\n'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> action <span class="keyword">in</span> optinalAnswers[<span class="string">"action"</span>]:</span><br><span class="line">  template += action + <span class="string">": $&#123;"</span> + optinalMap[action] + <span class="string">"&#125;\n"</span></span><br><span class="line"></span><br><span class="line">subprocess.run([<span class="string">"git"</span>, <span class="string">"commit"</span>, <span class="string">"-m"</span>, Template(template).substitute(answers)])</span><br></pre></td></tr></table></figure><h3 id="修改git-editor"><a href="#修改git-editor" class="headerlink" title="修改git editor"></a>修改git editor</h3><p>将上面的内容保存到/usr/bin/git-inquirer。</p><p>当我们执行git inquirer的时候就能看到交互，当操作完成后可以看到git log中message已经是按模板填充了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-router路由复用后页面没有刷新</title>
      <link href="/2020/06/01/vue-router%E8%B7%AF%E7%94%B1%E5%A4%8D%E7%94%A8%E5%90%8E%E9%A1%B5%E9%9D%A2%E6%B2%A1%E6%9C%89%E5%88%B7%E6%96%B0/"/>
      <url>/2020/06/01/vue-router%E8%B7%AF%E7%94%B1%E5%A4%8D%E7%94%A8%E5%90%8E%E9%A1%B5%E9%9D%A2%E6%B2%A1%E6%9C%89%E5%88%B7%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<p>vue-router提供了页面路由功能，可以用来构建单页面应用，在使用vue-router的动态路由匹配的时候，遇到了url变化了，但是页面却没有任何动静的问题，记录一下。</p><a id="more"></a><p>动态路由匹配url变化了，但是组件没有变化是因为vue进行了组件复用，因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会再被调用。所以我们需要手动进行数据刷新。</p><p>我们可以简单的使用watch来监听当前的路由变化，从而实现数据刷新。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; watch &#125; <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">"./router"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">        <span class="comment">// vue2</span></span><br><span class="line">        <span class="comment">// watch: &#123;</span></span><br><span class="line">        <span class="comment">//     $route(to, from) &#123;</span></span><br><span class="line">        <span class="comment">//         // 对路由变化作出响应...</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// vue3</span></span><br><span class="line">        watch(router.currentRoute, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"路由发生了变化"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可以使用2.2中新加的beforeRouteUpdate路由守卫：</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    beforeRouteUpdate(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 不要在这里调用next</span></span><br><span class="line">        <span class="comment">// 通过to来判断是否重载数据</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"路由发生了变化"</span>);</span><br><span class="line">    &#125;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是vue3中使用vue-router-next来处理动态路由变化导致页面不刷新的方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3升级遇到的坑</title>
      <link href="/2020/05/31/vue3-upgrade/"/>
      <url>/2020/05/31/vue3-upgrade/</url>
      
        <content type="html"><![CDATA[<p>最近一直忙工作上的事，对提高自身能力的事有点落下了，趁着今天把之前思考的一些问题都给解决了，也顺手给自己的VueBlog把vue和webpack都升级到最新的beta版本，然后遇到了很多坑，今天就把坑都记录一下，免的以后忘了。</p><p>VueBlog目前使用的是webpack5 + vue3 + vue-router-next + typescript构建，目的在于替换当前的hexo站点，同样也是一个静态博客生成器，不过和hexo的定位不同，我使用的是单页面设计，而不是给每个页面生成对应的html文件，所以对SEO不友好，以后再想办法吧。</p><a id="more"></a><h2 id="升级Vue3"><a href="#升级Vue3" class="headerlink" title="升级Vue3"></a>升级Vue3</h2><p>首先使用<code>vue add vue-next</code>来升级vue到beta版本，执行以后vue会对代码进行一次转换，将旧版本的一些api转换为新版本。</p><h3 id="App"><a href="#App" class="headerlink" title="App"></a>App</h3><p>例如将main.ts中创建App对象的代码转换为新的，在vue2中，我们通过new Vue()来创建app对象，并调用$mount函数挂在元素。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import App from &quot;.&#x2F;App.vue&quot;;</span><br><span class="line">const app &#x3D; new Vue(App);</span><br><span class="line">app.$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure><p>在vue3中，主体思想都尽量通过函数来进行了，因为可以通过函数的参数和返回值进行类型推导。在vue3中，创建app对象通过createApp函数来进行，再通过mount函数挂载dom元素。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import App from &quot;.&#x2F;App.vue&quot;;</span><br><span class="line">const app &#x3D; createApp(APp);</span><br><span class="line">app.mount(&quot;#app&quot;);</span><br></pre></td></tr></table></figure><h3 id="Vur-Router"><a href="#Vur-Router" class="headerlink" title="Vur Router"></a>Vur Router</h3><p>如果使用的有vue-router之类的插件，使用方法也有一些变化，router也需要通过对应的create函数创建。首先需要先升级vue-router，vue-router的下一个版本叫<a href="https://github.com/vuejs/vue-router-next" target="_blank" rel="noopener">vue-router-next</a>。在vue-router中，创建router对象的函数从VueRouter函数改为createRouter。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default router;</span><br></pre></td></tr></table></figure><p>在vue3中则需要使用新的函数返回：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const router &#x3D; createRouter(&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default router;</span><br></pre></td></tr></table></figure><p>内容也改了一部分，可以访问<a href="https://github.com/vuejs/vue-router-next" target="_blank" rel="noopener">github</a>仓库来看文档。</p><h3 id="composition-API"><a href="#composition-API" class="headerlink" title="composition API"></a>composition API</h3><p>composition api是vue3提出的核心功能，其核心目的是通过将分散在各处的数据都整合到一个setup函数中进行初始化，并依赖vue的响应式数据改变来完成功能实现。</p><p>在RFC中就有composition api的动机。</p><blockquote><h4 id="更好的逻辑复用与代码组织"><a href="#更好的逻辑复用与代码组织" class="headerlink" title="更好的逻辑复用与代码组织"></a>更好的逻辑复用与代码组织</h4><ol><li>随着功能的增长，复杂组件的代码变得越来越难以阅读和理解。这种情况在开发人员阅读他人编写的代码时尤为常见。根本原因是 Vue 现有的 API 迫使我们通过选项组织代码，但是有的时候通过逻辑关系组织代码更有意义。</li><li>目前缺少一种简洁且低成本的机制来提取和重用多个组件之间的逻辑。<h4 id="更好的类型推导"><a href="#更好的类型推导" class="headerlink" title="更好的类型推导"></a>更好的类型推导</h4>另一个来自大型项目开发者的常见需求是更好的 TypeScript 支持。Vue 当前的 API 在集成 TypeScript 时遇到了不小的麻烦，其主要原因是 Vue 依靠一个简单的 this 上下文来暴露 property，我们现在使用 this 的方式是比较微妙的。（比如 methods 选项下的函数的 this 是指向组件实例的，而不是这个 methods 对象）。</li></ol><p>换句话说，Vue 现有的 API 在设计之初没有照顾到类型推导，这使适配 TypeScript 变得复杂。<br>相比较过后，本 RFC 中提出的方案更多地利用了天然对类型友好的普通变量与函数。用该提案中的 API 撰写的代码会完美享用类型推导，并且也不用做太多额外的类型标注。</p><p>这也同样意味着你写出的 JavaScript 代码几乎就是 TypeScript 的代码。即使是非 TypeScript 开发者也会因此得到更好的 IDE 类型支持而获益。</p><p><a href="https://composition-api.vuejs.org/zh/api.html" target="_blank" rel="noopener">composition api</a> 文档官方</p><p><a href="https://composition-api.vuejs.org/zh" target="_blank" rel="noopener">vue3 rfc</a> rfc网站</p></blockquote><p>setup函数用起来确实舒服，所有有用的东西都可以放在一块，代码整理也方便，不像以前一样需要分散到各种hook和计算属性、data函数中。但是也有我用起来不舒服的地方，基本类型和对象都需要使用ref函数和reactive函数进行包装，有的时候用起来就各种麻烦，需要多注意一些。不过这个问题倒不是什么大问题，和写c++的时候所有的对象用智能指针包裹一层一样，用多了就习惯了。</p><p>这是一个vue2的经典例子，通过data函数和计算属性来返回不同的数据。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default new Vue(&#123;</span><br><span class="line">    data: function() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            message: &quot;hello&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        reversedMessage: function () &#123;</span><br><span class="line">            return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在vue3中就可以全部集中到setup函数，并且一并返回，模板可以直接使用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; ref, computed &#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">        const message &#x3D; ref(&quot;hello&quot;);</span><br><span class="line">        const reversedMessage &#x3D; computed(() &#x3D;&gt; &#123;</span><br><span class="line">            return message.value.split(&#39;&#39;).reverse().join(&#39;&#39;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return &#123; message, reversedMessage &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出使用setup函数可以将模板所需的内容一块返回，结构更为清晰，vue2的模式也是可以的，只不过侧重点不一样，vue2的目的是一种动作的数据应该被放在一块，而vue3的setup函数则是将数据处理都放在一块，这样对数据的的整理比较方便和集中。</p><h3 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h3><p>props是在组件上注册的自定义属性，当一个值传递给props的时候，它就会成为那个组件的一个property。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;hello v-bind:message&#x3D;&quot;message&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>hello组件可以通过定义props函数来接收自定义属性。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default new Vue(&#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">        message: String</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样就可以在helle.vue中使用message这个属性，不过需要注意的是，hello组件不要修改传递进来的message,否则会破坏数据的流向。</p><p>在vue3中使用会更加方便，因为类型推导更加方便。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Props &#123;</span><br><span class="line">    message?: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">        message: &#123;</span><br><span class="line">            type: String,</span><br><span class="line">            require: false,</span><br><span class="line">            default: &quot;&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    setup(props: Props) &#123;</span><br><span class="line">        const reversedMessage &#x3D; computed(() &#x3D;&gt; &#123;</span><br><span class="line">            if (props.message &#x3D;&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">                return String;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            const innerMessage &#x3D; props.message;</span><br><span class="line">            return innerMessage.split(&#39;&#39;).reverse().join(&#39;&#39;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return &#123; reversedMessage &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在vue3和typescript中使用props需要有一些注意的地方，首先Props里需要设置值可能为空，否则setup函数的签名将无法匹配。其次访问props数据需要开启setup函数的props参数，还有一个context参数，可以访问上下文的内容。</p>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript建造者模式</title>
      <link href="/2020/02/01/JavaScript%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/02/01/JavaScript%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>建造者模式就是指将类的构造和其表示分离开来，调用者可以通过不同的构建过程创造出不同表示的对象。主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，由于需求的变化，这个复杂对象的某些部分经常面临着剧烈的变化，一些基本部件不会变。所以需要将变与不变分离。与抽象工厂的区别：在建造者模式里，有个指导者(Director)，由指导者来管理建造者，用户是与指导者联系的，指导者联系建造者最后得到产品。即建造者模式可以强制实行一种分步骤进行的建造过程。</p><a id="more"></a><h2 id="建造者模式四要素"><a href="#建造者模式四要素" class="headerlink" title="建造者模式四要素"></a>建造者模式四要素</h2><ol><li>产品类Product: 一般是一个较为复杂的对象，也就是说创建对象的过程比较复杂，一般会有较多的代码。</li><li>抽象建造者类Builder: 将建造的具体过程交予它的子类来实现。</li><li>建造者类ConcreateBuilder: 组件产品，返回组件好的产品</li><li>指导类Director: 负责调用适当的建造者来组件产品，指导类一般不与产品类发生依赖关系，与指导类直接交互的是建造者类。</li></ol><h2 id="建造者模式的优点"><a href="#建造者模式的优点" class="headerlink" title="建造者模式的优点"></a>建造者模式的优点</h2><p>建造者模式的封装很好，使用建造者模式可以进行有效的封装变化，在使用建造者模式的场景中，产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指导者类中对整体可以取得比较好的稳定性。</p><p>建造者类也很方便扩展，如果有新的需求，只需要实现一个新的建造者类即可。</p><p>产品类 product.ts</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Product &#123;</span><br><span class="line">    private _name: String;</span><br><span class="line">    public name(): String &#123;</span><br><span class="line">        return this._name;</span><br><span class="line">    &#125;</span><br><span class="line">    public setName(name: String) &#123;</span><br><span class="line">        this._name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象建造类 builder.ts</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Builder &#123;</span><br><span class="line">    _product: Product;</span><br><span class="line">    setName(name: String): Product;</span><br><span class="line">    build(): Product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建造类 concreatebuilder.ts</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ConcreateBuilder implements Builder &#123;</span><br><span class="line">    _product: Product &#x3D; new Product;</span><br><span class="line">    public setName(name: String): Product &#123;</span><br><span class="line">        this._product.setName(name);</span><br><span class="line">        return this._product;</span><br><span class="line">    &#125;</span><br><span class="line">    public build(): Product &#123;</span><br><span class="line">        return this._product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HelloworldBuilder extends ConcreateBuilder &#123;</span><br><span class="line">    public build(): Product &#123;</span><br><span class="line">        this._product.setName(&quot;hello world!&quot;);</span><br><span class="line">        return this._product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指导类 director.ts</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Director &#123;</span><br><span class="line">    private _defaultBuilder: ConcreateBuilder &#x3D; new ConcreateBuilder;</span><br><span class="line">    private _helloworldBuilder: HelloworldBuilder &#x3D; new HelloworldBuilder;</span><br><span class="line">    public buildForDefault(): Product  &#123;</span><br><span class="line">        return this._defaultBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line">    public buildForHelloworld(): Product &#123;</span><br><span class="line">        return this._helloworldBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试运行:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let director &#x3D; new Director();</span><br><span class="line">console.log(director.buildForDefault().name());</span><br><span class="line">console.log(director.buildForHelloworld().name());</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">undefined</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p>通过不同的builder就可以构建不同的对象出来，当需求变动的时候，我们只需要扩展出不同的Builder和Director就可以满足。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Javascript构造器模式</title>
      <link href="/2020/01/31/%E6%B5%85%E8%B0%88Javascript%E6%9E%84%E9%80%A0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/01/31/%E6%B5%85%E8%B0%88Javascript%E6%9E%84%E9%80%A0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>为了简化操作，JavaScript提供了new关键字。new关键字用于创建一个用户定义类型的实例，或者具有构造函数的内置对象的实例。</p><a id="more"></a><p>每当我们在一个函数调用前使用new关键字，该函数便会以一种特殊模式——构造模式来运行，在此模式中，JavaScript可以自动完成一些操作。基本上它是指解释器在你的代码中嵌入几行操作代码。</p><p>在JavaScript中，构造函数通常是认为用来实现实例的，但是JavaScript中没有类的概念，但是有特殊的构造函数，通过new关键字来调用定义的构造函数，你可以告诉JavaScript你需要创建一个新对象，并且新对象的成员声明都是构造函数里定义的。在构造函数内部，this引用的是新创建的对象。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function People(name: String, age: Number) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    this.output &#x3D; function() &#123;</span><br><span class="line">        return this.name + &quot;已经&quot; + this.age + &quot;岁了&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let people &#x3D; new People(&quot;justforlxz&quot;, 24);</span><br><span class="line"></span><br><span class="line">console.log(people.output());</span><br></pre></td></tr></table></figure><p>上面是个很简单的构造函数模式，我们从字面上this是people对象，但是其实并不是这样的，new运算符帮助我们生成了this的初始化代码。</p><p>new运算符一共做了三件事：</p><ol><li>创建一个空对象</li><li>将空对象的原型赋值为构造器函数的原型</li><li>更改构造器函数内部的this，将其指向新创建的对象</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let tmp &#x3D; new Object();</span><br><span class="line">tmp.__proto__ &#x3D; People.prototype;</span><br><span class="line">People.call(tmp);</span><br></pre></td></tr></table></figure><p>最后会经过一个判断，如果构造器函数设置了返回值，并且返回值是一个Object类型的话，就直接返回该Object，否则就会返回新创建的空对象。</p><p>总结一下： JavaScript没有类的概念，但是为了实现OOP，就通过new关键字实现对函数进行插入代码来实现对象实例的初始化。构造器模式就是通过一个方法来new出一个对象，这个操作就叫构造器模式。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019 Review</title>
      <link href="/2020/01/01/2019review/"/>
      <url>/2020/01/01/2019review/</url>
      
        <content type="html"><![CDATA[<p>上一次写年终总结还是18年回家的动车上，可惜写了一半没发表，觉得一年了没有什么能够回想起来的，就又删除了。今年不同了，今年有好多想说的。</p><a id="more"></a><h2 id="脱单"><a href="#脱单" class="headerlink" title="脱单"></a>脱单</h2><p><strong>第一件重要的事是我遇到了生命中的她。</strong></p><p>自从工作以后，我妈天天念叨我的就是找对象，和我预想的没错，上学的时候盼我毕业，毕业以后盼我工作，工作以后盼我找对象结婚，找对象以后盼我赶紧生个娃让她抱。<del>（大家的父母应该都这样）</del></p><h2 id="加薪"><a href="#加薪" class="headerlink" title="加薪"></a>加薪</h2><p>这件事确实也令我挺开心的，我的工资在2019年成功涨到了0.375乔(1乔等于**元  <a href="https://blog.nanpuyue.com/" target="_blank" rel="noopener">@nanpuyue</a>)</p><p>涨工资谁不高兴，我估计也就马云不高兴了，毕竟他看不上钱。</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>今年看了很多C++的资料，对C++和编译器都有了更深的了解。想2016年半夜<a href="https://zcc.rs/" target="_blank" rel="noopener">@zccrs</a>在家教我编译原理，到现在我可以理解一门语言从设计到实现，再到使用模板完成编译时计算，我走了快三年，这三年里我一直没停下学习的脚步，在学习各种知识，从各种编程语言到各种框架原理，到图形界面的实现。还学习了单元测试，并且<a href="https://hualet.org/" target="_blank" rel="noopener">@hualet</a>大佬给我讲了单元测试是什么，以及单元测试的重要性，从那以后我才算真正的了解单元测试的重要性，也使我在写代码的时候注重通过单元测试来保障我的功能。</p><p>去年对深度学习进行了一波学习，今年对Web工程化和TypeScript也学习了一下，也算是对目前最热门的两个领域进行了一定的了解。</p><h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>去年买的TensorFlow看了没一半，今年倒是没买书，开始在微信读书上读书，利用一些空余时间读一点，我也推荐大家多利用空闲时间读读书，少刷抖音和bilibili。</p><ul><li>《TensorFlow》未读完</li><li>《TypeScript实战》正在读</li></ul><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><p>2019年我一共水了15篇文章。</p><ul><li><p>12-26 <a href="https://blog.justforlxz.com/2019/12/26/use-serial-port-debug-deepin-on-archlinux/">在ArchLinux通过串口调试VMware虚拟机中的deepin</a></p></li><li><p>12-26 <a href="https://blog.justforlxz.com/2019/12/26/cpp-sort/">使用标准库std::sort函数进行排序</a></p></li><li><p>12-09 <a href="https://blog.justforlxz.com/2019/12/09/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AA%E5%9D%91%E7%88%B9%E7%9A%84usb%E7%BD%91%E5%8D%A1/">记录一个坑爹的usb网卡</a></p></li><li><p>12-09 <a href="https://blog.justforlxz.com/2019/12/09/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AA%E5%9D%91%E7%88%B9%E7%9A%84usb%E7%BD%91%E5%8D%A1/">使用github actions自动部署hexo文章到html仓库</a></p></li><li><p>12-08 <a href="https://blog.justforlxz.com/2019/12/08/vue-component-props/">Vue父子组件传值 —— props &amp; $emit</a></p></li><li><p>12-08 <a href="https://blog.justforlxz.com/2019/12/08/vue-transitions/">添加Vue动画</a></p></li><li><p>11-25 <a href="https://blog.justforlxz.com/2019/11/25/%E4%BD%BF%E7%94%A8webpack-dev-server%E6%9D%A5%E7%9B%91%E5%90%AC%E9%A1%B9%E7%9B%AE%E5%8F%98%E5%8C%96/">使用webpack-dev-server来监听项目变化</a></p></li><li><p>10-24 <a href="https://blog.justforlxz.com/2019/10/24/%E7%BB%99Archlinux%E5%BC%80%E5%90%AFBFQ%E5%92%8CMuQSS/">给Archlinux开启BFQ和MuQSS</a></p></li><li><p>10-22 <a href="https://blog.justforlxz.com/2019/10/22/%E4%BD%BF%E7%94%A8webpack%E6%89%93%E5%8C%85Vue%E5%92%8CTypeScript/">使用webpack打包Vue和TypeScript</a></p></li><li><p>10-14 <a href="https://blog.justforlxz.com/2019/10/14/webpack%E5%85%A5%E9%97%A8/">webpack入门</a></p></li><li><p>06-16 <a href="https://blog.justforlxz.com/2019/06/16/wsl2%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/">wsl2的使用体验</a></p></li><li><p>06-15 <a href="https://blog.justforlxz.com/2019/06/15/%E5%85%A5%E5%9D%91typescript%E4%BA%86/">入坑typescript了</a></p></li><li><p>05-23 <a href="https://blog.justforlxz.com/2019/05/23/CMake-CTests-for-dde-control-center/">CMake CTests for dde-control-center</a></p></li><li><p>02-21 <a href="https://blog.justforlxz.com/2019/02/21/how-to-use-LNMP-on-deepin/">如何在Deepin上使用LNMP</a></p></li><li><p>02-23 <a href="https://blog.justforlxz.com/2019/01/23/fuck-taobao/">解决用了xposed后淘宝闪退</a></p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019</span><br><span class="line">├── 01</span><br><span class="line">│   └── 23</span><br><span class="line">│       └── fuck-taobao</span><br><span class="line">│           └── index.html</span><br><span class="line">├── 02</span><br><span class="line">│   └── 21</span><br><span class="line">│       └── how-to-use-LNMP-on-deepin</span><br><span class="line">│           └── index.html</span><br><span class="line">├── 05</span><br><span class="line">│   └── 23</span><br><span class="line">│       └── CMake-CTests-for-dde-control-center</span><br><span class="line">│           └── index.html</span><br><span class="line">├── 06</span><br><span class="line">│   ├── 15</span><br><span class="line">│   │   └── 入坑typescript了</span><br><span class="line">│   │       ├── 深度录屏_选择区域_20190615202044.gif</span><br><span class="line">│   │       └── index.html</span><br><span class="line">│   └── 16</span><br><span class="line">│       └── wsl2的使用体验</span><br><span class="line">│           ├── index.html</span><br><span class="line">│           ├── Snipaste_2019-06-16_21-49-15.png</span><br><span class="line">│           └── Snipaste_2019-06-16_21-52-42.png</span><br><span class="line">├── 10</span><br><span class="line">│   ├── 14</span><br><span class="line">│   │   └── webpack入门</span><br><span class="line">│   │       └── index.html</span><br><span class="line">│   ├── 22</span><br><span class="line">│   │   └── 使用webpack打包Vue和TypeScript</span><br><span class="line">│   │       └── index.html</span><br><span class="line">│   └── 24</span><br><span class="line">│       └── 给Archlinux开启BFQ和MuQSS</span><br><span class="line">│           └── index.html</span><br><span class="line">├── 11</span><br><span class="line">│   └── 25</span><br><span class="line">│       └── 使用webpack-dev-server来监听项目变化</span><br><span class="line">│           └── index.html</span><br><span class="line">└── 12</span><br><span class="line">    ├── 08</span><br><span class="line">    │   ├── vue-component-props</span><br><span class="line">    │   │   └── index.html</span><br><span class="line">    │   └── vue-transitions</span><br><span class="line">    │       └── index.html</span><br><span class="line">    ├── 09</span><br><span class="line">    │   ├── 记录一个坑爹的usb网卡</span><br><span class="line">    │   │   └── index.html</span><br><span class="line">    │   └── use-github-actions-to-depoly-hexo</span><br><span class="line">    │       └── index.html</span><br><span class="line">    └── 26</span><br><span class="line">        ├── cpp-sort</span><br><span class="line">        │   └── index.html</span><br><span class="line">        └── use-serial-port-debug-deepin-on-archlinux</span><br><span class="line">            └── index.html</span><br><span class="line"></span><br><span class="line">34 directories, 18 files</span><br></pre></td></tr></table></figure><h2 id="科普视频"><a href="#科普视频" class="headerlink" title="科普视频"></a>科普视频</h2><ol><li>妈咪叔 (一个较真的理工男)</li></ol><p>这个名字我第一眼看到的时候，还以为是个卖母婴的，没想到居然是个搞科普的，而且内容讲的也很好，有数学、物理、化学和天文学。</p><ol start="2"><li>李永乐老师</li></ol><p>以前偶尔看过老师的视频，因为一直都在热榜，所以没想到关注，后来是youtube上看到了，就点了关注，youtube上更新的和bilibili的还不是一样的，看最后结尾的时候youtube的只说youtube帐号关注，而bilibili的是bilibili，有时候还要多个平台去看。</p><ol start="3"><li>萝王二号</li></ol><p>之前在科普区随便看的时候，对生物学产生了一些兴趣，萝王讲的风格我很喜欢，特别是他注重昆虫分类学(骨包皮，皮包骨啊2333)，还有一些辟谣视频。</p><ol start="4"><li>芳斯塔夫 (鬼古)</li></ol><p>也使对生物学产生了一些兴趣，鬼古说以他很中二的风格带领我学习了一波古生物的相关知识(旧日支配者！！！)。</p><ol start="5"><li>木偶君</li></ol><p>和鬼古一样是专门讲古生物的，不过每次结束的比较仓促，突然就结束了。</p><ol start="6"><li>木鱼水心</li></ol><p>木鱼并不是今年才关注的，最开始关注是他做EVA剧场版解析，后来《木鱼说》开始做一些科普，我开始一直关注了。</p><ol start="7"><li>宇宙视觉 (永远不要停止思考)</li></ol><p>一个讲天文的科普up，不过年底的时候换了配音，疑似配音出去单干了。</p><h2 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h2><ol><li>流浪地球</li><li>阿丽塔：战斗天使</li><li>战狼2</li><li>惊奇队长</li><li>复仇者联盟4</li><li>何以为家</li><li>速度与激情： 特别行动</li><li>叶问4</li></ol><h2 id="纪录片"><a href="#纪录片" class="headerlink" title="纪录片"></a>纪录片</h2><ol><li>混沌：数学探秘</li><li>维度：数学漫步</li></ol><h2 id="动漫"><a href="#动漫" class="headerlink" title="动漫"></a>动漫</h2><ol><li>刀剑神域</li><li>紫罗兰永恒花园</li><li>darling in the franxx</li><li>心理测量者</li><li>进击的巨人第三季</li><li>五等分的新娘</li><li>citrus～柑橘味香气～</li></ol>]]></content>
      
      
      <categories>
          
          <category> 年度总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用伪元素创建一个圆点</title>
      <link href="/2020/01/01/%E4%BD%BF%E7%94%A8%E4%BC%AA%E5%85%83%E7%B4%A0%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9C%86%E7%82%B9/"/>
      <url>/2020/01/01/%E4%BD%BF%E7%94%A8%E4%BC%AA%E5%85%83%E7%B4%A0%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9C%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>我最早接触到CSS中的伪元素是在一次写背景模糊的时候，CSS中的blur会模糊下面所有的元素，但是可以通过伪元素在before中先模糊，这样下层是没有任何元素的，自然也不会有元素被模糊。</p><p>伪元素就如同它的名字一样，是假的元素，只是CSS引擎在排版的时候创建出来的，在DOM树中是不存在的，所以javascript是没办法操作伪元素的。伪元素分为before和after，可以在元素的前面或者后面创建一个假的元素，伪元素选择器的标志符号是<code>::</code>。</p><ol><li><code>div::before</code> 在div元素的前面创建一个元素，配合content属性一起使用。</li><li><code>div::after</code> 在div元素的后面创建一个元素，配合content属性一起使用。</li></ol><img src="/2020/01/01/%E4%BD%BF%E7%94%A8%E4%BC%AA%E5%85%83%E7%B4%A0%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9C%86%E7%82%B9/16-57-30%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" class="" width="1657"><p>使用伪元素选择器需要注意一点的是，必须使用content属性，否则将不起任何作用。</p><p>伪元素选择器生效以后，可以在DOM中看到::before或者::after，这里提供一个例子。</p><p>html部分：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        Text</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><p>css部分：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div::before &#123;</span><br><span class="line">  content: &quot;This is before Text, &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div::after &#123;</span><br><span class="line">  content: &quot;, This is after Text.&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时页面上会看到输出这么一句话，<code>This  is before Text, Text , This is after Text.</code>，并且使用鼠标只能选择到最中间的Text文本。</p><img src="/2020/01/01/%E4%BD%BF%E7%94%A8%E4%BC%AA%E5%85%83%E7%B4%A0%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9C%86%E7%82%B9/16-57-16.png" class="" width="1657"><p>代码可以点击<a href="https://jsfiddle.net/justforlxz/shg21kvb/18/" target="_blank" rel="noopener">这里</a>查看。</p><p>今天写这篇文章呢，是因为今天我在实现hexo的Next主题，看到它在列表中使用after创建了一个小圆点，并且我遇到了一个问题，所以写这篇文章记录一下。</p><p>Next用的是浮动布局来实现的，而我决定flex一把梭，整体布局是垂直的flex，首页、分类等列表内部是用水平的inline-flex实现的，最左边是图标，来自fortawesome，中间的文本使用span包裹一下，实现左对齐，然后通过伪元素在最右边创建一个小圆点，设置a元素的宽度为100%，就可以实现圆点在最右边。</p><p>坑就是在这里遇到的，如果a元素的宽度设置为100%，伪元素创建的小圆点就不能完全显示，少1像素或者多1像素就可以完全显示。最终的解决办法是给小圆点的周围增加了1像素的padding解决了，但是原因位置，谁看到这篇文章并且恰好知道原因的，还请帮忙评论回复一下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;site-nav&quot;&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for&#x3D;&quot;item in items&quot; v-bind:key&#x3D;&quot;item.title&quot;&gt;</span><br><span class="line">      &lt;a v-bind:href&#x3D;&quot;item.link&quot;&gt;</span><br><span class="line">        &lt;span id&#x3D;&quot;menu-left&quot; v-bind:class&#x3D;&quot;item.class&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span id&#x3D;&quot;menu-text&quot;&gt;</span><br><span class="line">          &#123;&#123; item.title &#125;&#125;</span><br><span class="line">        &lt;&#x2F;span&gt;</span><br><span class="line">      &lt;&#x2F;a&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#site-nav &#123;</span><br><span class="line">  background: white;</span><br><span class="line">  padding: 20px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ul &#123;</span><br><span class="line">  margin: 0;</span><br><span class="line">  padding: 0 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#site-nav li &#123;</span><br><span class="line">  list-style-type: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#site-nav li a &#123;</span><br><span class="line">  padding: 5px 0px;</span><br><span class="line">  text-align: left;</span><br><span class="line">  line-height: inherit;</span><br><span class="line">  transition-property: background-color;</span><br><span class="line">  transition-duration: 0.2s;</span><br><span class="line">  transition-timing-function: ease-in-out;</span><br><span class="line">  transition-delay: 0s;</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: space-between;</span><br><span class="line">  align-items: center;</span><br><span class="line">  text-decoration: none;</span><br><span class="line">  font-size: 13px;</span><br><span class="line">  border-bottom: 1px solid transparent;</span><br><span class="line">  color: #555;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#site-nav li a:hover &#123;</span><br><span class="line">  background: #f9f9f9;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#menu-left &#123;</span><br><span class="line">  align-content: center;</span><br><span class="line">  margin-left: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#menu-text &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  margin-left: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#site-nav li a::after &#123;</span><br><span class="line">  content: &#39; &#39;;</span><br><span class="line">  background: #bbb;</span><br><span class="line">  width: 6px;</span><br><span class="line">  height: 6px;</span><br><span class="line">  border-radius: 50%;</span><br><span class="line">  margin: 0 10px 0 0;</span><br><span class="line">  min-width: 6px;</span><br><span class="line">  min-height: 6px;</span><br><span class="line">  max-height: 6px;</span><br><span class="line">  max-width: 6px;</span><br><span class="line">  display: block;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我提取了基本结构和css，demo是能够正常显示小圆点的，但是自己的Vue却不能正常显示，后来发现是display写成块级元素用的flex了，改成inline-flex就能正常显示了，但是在调整宽度的时候，就发现了上面的问题，它又不正常显示了，实在解决不了了，就用padding处理了。</p><p>参考资料： <a href="https://github.com/qianguyihao/Web/blob/master/02-CSS%E5%9F%BA%E7%A1%80/10-CSS3%E9%80%89%E6%8B%A9%E5%99%A8%E8%AF%A6%E8%A7%A3.md" target="_blank" rel="noopener">千古壹号</a></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在ArchLinux通过串口调试VMware虚拟机中的deepin</title>
      <link href="/2019/12/26/use-serial-port-debug-deepin-on-archlinux/"/>
      <url>/2019/12/26/use-serial-port-debug-deepin-on-archlinux/</url>
      
        <content type="html"><![CDATA[<p>电脑主板上的接口：进行串行传输的接口，它一次只能传输1Bit。串行端口可以用于连接外置调制解调器、绘图仪或串行打印机。它也可以控制台连接的方式连接网络设备，例如路由器和交换机，主要用来配置它们。消费性电子已经由USB取代串列接口；但在非消费性用途，如网络设备等，串列接口仍是主要的传输控制方式。</p><a id="more"></a><p>首先给虚拟机分配一个串口设备，选择Settings-&gt;Add-&gt;Serial Port。分配好串口设备以后，我们需要选择一个串口设备的调试方式，一个是将输出转向一个文件，或者是通过socket。</p><p>如果只是查看方式，选择outpu file即可。如果需要调试，则可以通过socket方式来进行。</p><p>socket方式需要给一个固定的路径分配/tmp/<socket>，我调试的时候给出的是/tmp/vhost，From选择Server，To选择An Application。From的意思是信息从哪里来，信息是虚拟机里的系统发出的，所以这里选择的是Server，如果是反向操作，需要选择Client。To也是有两个选项，第一个是An Virtual Machine，第二个是An Application。用于把消息发送给另外的虚拟机，或者是宿主机的一个应用程序。</p><p>安装minicom包，用于进行调试，minicom这个东西，不是太好用，退出方式是先按Ctrl+A，然后按q，有时候还不一定管用，不知道是没接受到，还是按错了。</p><p>先minicom -s 进行初始化，选择<code>Serial port setup</code>，按A编辑<code>Serial Device</code>，这里需要注意一下，通过socket进行调试，需要使用<code>unix#</code>前缀，然后加上在虚拟机里写的路径 <code>unix#/tmp/vhost</code>。然后保存，选择Exit，退出以后其实重启minicom，就进入minicom的调试界面了，然后此时开启虚拟机，给内核添加一个console=ttyS0的参数，就看到minicom显示输出的信息了，还可以交互。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[    3.855725] [drm:vmw_fb_setcolreg [vmwgfx]] *ERROR* Bad regno 254.</span><br><span class="line">[    3.857125] [drm:vmw_fb_setcolreg [vmwgfx]] *ERROR* Bad regno 255.</span><br><span class="line">deepin Login:</span><br><span class="line"></span><br><span class="line">CTRL-A Z for help | unix-socket | NOR | Minicom 2.7.1 | VT102 | Offline | unix#&#x2F;tmp&#x2F;vhost</span><br></pre></td></tr></table></figure><p>此时就可以交互了，用法和tty一样，最后一行是minicom的输出，可以看到CTRL-A Z可以看help，minicom的版本，和访问的串口socket。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用标准库std::sort函数进行排序</title>
      <link href="/2019/12/26/cpp-sort/"/>
      <url>/2019/12/26/cpp-sort/</url>
      
        <content type="html"><![CDATA[<p>std的sort方法接受两个迭代器begin和end。通过迭代器来抽象元素的访问，隐藏内部实现。</p><a id="more"></a><p>这是一个简单的例子:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::list&lt;int&gt; list &#123;</span><br><span class="line">    0,</span><br><span class="line">    4,</span><br><span class="line">    2,</span><br><span class="line">    1,</span><br><span class="line">    3,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::sort(list.begin(), list.end());</span><br></pre></td></tr></table></figure><p>结果就是list被排序了，至于使用了什么排序算法，我们并不需要关心。实际上标准库会通过元素的数量来决定使用什么算法，基于Introspective Sorting(内省式排序)。<br>它是一种混合式的排序算法：</p><ul><li><p>在数据量很大时采用正常的快速排序，此时效率为O(logN)。</p></li><li><p>一旦分段后的数据量小于某个阈值，就改用插入排序，因为此时这个分段是基本有序的，这时效率可达O(N)。</p></li><li><p>在递归过程中，如果递归层次过深，分割行为有恶化倾向时，它能够自动侦测出来，使用堆排序来处理，在此情况下，使其效率维持在堆排序的O(N logN)，但这又比一开始使用堆排序好。</p></li></ul><p>默认情况下排序是升序排序，既结果从小到大，我们可以通过使用std::equal_to<T>、std::not_equal_to<T>、std::greater<T>、std::less<T>、std::greater_equal<T>和std::less_equal<T>来控制排序。</p><p>以上是通过标准库内置的一些方式来控制排序，且适用于元素已实现了自定义比较(Compare)的要求。</p><p>比较 (Compare) 是一些标准库设施针对用户提供的函数对象类型所期待的一组要求。</p><p>对满足比较 (Compare) 的类型的对象运用函数调用操作的返回值，当按语境转换成 bool 时，若此类型所引入的严格弱序关系中，该调用的第一实参先于第二实参，则生成 true，否则生成 false。</p><p>与任何二元谓词 (BinaryPredicate) 相同，不允许该表达式的求值通过解引用的迭代器调用非 const 函数。</p><p>用人话来说就是，Compare必须提供出对比结果。</p><p>看一个例子:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Test &#123;</span><br><span class="line">    int i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::list&lt;Test&gt; list &#123;</span><br><span class="line">    new Test(2),</span><br><span class="line">    new Test(1),</span><br><span class="line">    new Test(4),</span><br><span class="line">    new Test(3),</span><br><span class="line">    new Test(5),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::sort(list.begin(), list.end(), [&#x3D;] (const Test&amp; test1, const Test&amp; test2) -&gt; bool &#123;</span><br><span class="line">    return test1.i &lt; test2.i;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个例子提供了一个Compare，通过lambda来提供自定义的对比函数，返回值必须是bool，否则将不满足对比函数的要求。</p><p>通过以上三种方式可以看出，标准库的sort函数可以很方便的为使用者提供标准对比和自定义对比。如果元素自己已实现operator&lt;，则只需要使用标准库内置的对比函数即可，但是大部分情况其实并不会涉及到元素的排序，仅在临时情况下需要列表有序，所以我个人倾向于通过lambda提供Compare函数来完成列表的排序。</p><p><a href="https://zh.cppreference.com/w/cpp/algorithm/sort" target="_blank" rel="noopener">std::sort</a><br><a href="http://feihu.me/blog/2014/sgi-std-sort/" target="_blank" rel="noopener">知无涯之std::sort源码剖析</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>记录一个坑爹的usb网卡</title>
      <link href="/2019/12/09/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AA%E5%9D%91%E7%88%B9%E7%9A%84usb%E7%BD%91%E5%8D%A1/"/>
      <url>/2019/12/09/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AA%E5%9D%91%E7%88%B9%E7%9A%84usb%E7%BD%91%E5%8D%A1/</url>
      
        <content type="html"><![CDATA[<p>网卡型号是Realtek RTL8811CU/RTL8821CU USB Wi-Fi adapter，买来是为了让黑苹果上网的，windows下也会自动下载和安装驱动，但是linux比较难受，内核不提供这样的驱动，只能去官方拿源码搞，今天在arch上打算装一下驱动，结果遇到了很多问题。</p><p>wiki上推荐的8821应该使用rtl88xxau-aircrack-dkms-git，但是我安装以后压根不能用，一点变化都没有，而且modprobe也没有作者给出的88XXau，无奈只得放弃。</p><p>继续谷歌之，在<a href="https://forum.mxlinux.org/viewtopic.php?f=107&t=50579" target="_blank" rel="noopener">https://forum.mxlinux.org/viewtopic.php?f=107&amp;t=50579</a>看到了别人给的方案，然后果断clone并make,然后就因为没有适配5.x的内核编译失败，这可不行，翻了一下issue，看到作者在<a href="https://github.com/whitebatman2/rtl8821CU/issues/33" target="_blank" rel="noopener">https://github.com/whitebatman2/rtl8821CU/issues/33</a>提到了一个<a href="https://github.com/whitebatman2/rtl8821CU/issues/23" target="_blank" rel="noopener">#23</a>，这标题写的够可以，<code>Newer version 5.4.1 (Support Linux versions from 4.4.x up to 5.4.x) </code>，赶紧搞起，去源地址clone和make,成功使用上了驱动，按照作者提到的安装<code>usb_modeswitch</code>，并切换usb模式，我成功的使用上了这个usb网卡。</p><blockquote><p>吐槽一下，开发环境还是linux下舒服，仓库的包安装一下就可以开发了，windows下要自己写路径，mac下brew限制太死，一些库安装以后还要自己手动做些处理，一不小心就把shell的环境变量搞不行了，或者压根不能正常工作。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用github actions自动部署hexo文章到html仓库</title>
      <link href="/2019/12/09/use-github-actions-to-depoly-hexo/"/>
      <url>/2019/12/09/use-github-actions-to-depoly-hexo/</url>
      
        <content type="html"><![CDATA[<p>请先允许我大喊一声：微软牛逼！</p><p>本文没有啥含金量，就是简单的说一下如何部署github-actions来自动生成hexo的public，并且再推送到html仓库的。</p><p>我的博客仓库一共分为两个，blog仓库是私有的，需要通过我的私钥才能访问，html仓库是公开的，hexo生成的静态内容会被上传到这里。</p><p>首先在package.json中添加一些命令，方便我们一键编译和提交:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;build&quot;: &quot;hexo clean &amp;&amp; hexo g&quot;,</span><br><span class="line">  &quot;deploy&quot;: &quot;yarn run build &amp;&amp; hexo d&quot;,</span><br><span class="line">  &quot;backup&quot;: &quot;hexo b&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为CI环境需要提交代码到仓库，所以申请一个个人用的token，访问<a href="https://github.com/settings/tokens" target="_blank" rel="noopener">https://github.com/settings/tokens</a>创建一个新的，勾选上<code>repo</code>，生成完token以后，修改一下<code>_config.yml</code>中对deploy仓库的url，格式固定为<code>https://x-access-token:你的token@github.com/你的名字/仓库名.git</code>,例如我这里是<code>https://x-access-token:xxxxxxxxxx@github.com/justforlxz/html.git</code>。</p><p>然后新家一个github actions，选择nodejs环境，我们只需要修改最后一个步骤，执行我们自己的命令即可。</p><ul><li>设置git的用户名和邮箱地址</li><li>npm install -g yarn</li><li>yarn run deploy</li></ul><p>如果你还有一些其他步骤，可以自行扩展，比如我就有主题相关的操作，具体的内容如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- name: npm install, build, and deploy</span><br><span class="line">  run: |</span><br><span class="line">    git config --global user.email &quot;justforlxz@gmail.com&quot;</span><br><span class="line">    git config --global user.name &quot;justforlxz&quot;</span><br><span class="line">    git submodule update --init</span><br><span class="line">    cd themes&#x2F;next</span><br><span class="line">    git checkout dev</span><br><span class="line">    cd ..&#x2F;..&#x2F;</span><br><span class="line">    npm install -g yarn</span><br><span class="line">    yarn</span><br><span class="line">    yarn run deploy</span><br></pre></td></tr></table></figure><p>然后就可以愉快的自动部署了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue父子组件传值 —— props &amp; $emit</title>
      <link href="/2019/12/08/vue-component-props/"/>
      <url>/2019/12/08/vue-component-props/</url>
      
        <content type="html"><![CDATA[<p>Vue的父子组件传值比较有意思，父组件通过属性绑定，把自身的值和子组件的一个属性绑定起来，子组件通过props属性接收，该属性类型为数组，是Vue对象中比较少有的类型，data、computer、methods等方法都是对象的形式，props则是数组的形式。父组件通过v-on来监听子组件发出的事件来接收子组件的调用。在这里我是理解成子组件发送信号来通知上层，毕竟调用的是this.$emit来做到的。</p><a id="more"></a><p>我们假设子组件名为<hello>，我们通过v-bind来绑定一个值给它。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;#app&quot;&gt;</span><br><span class="line">        &#x2F;&#x2F; 通过v-bind绑定父子组件的属性</span><br><span class="line">        &lt;hello v-bind:messageFromParent&#x3D;&quot;message&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line">import Hello from &#39;.&#x2F;Hello.vue&#39;;</span><br><span class="line">export default Vue.extend(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: &quot;this message from parent&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        &quot;hello&quot;: Hello</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>子组件hello.vue通过props属性接收，内容是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &#123;&#123; messageFromParent &#125;&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line">export default Vue.extend(&#123;</span><br><span class="line">    &#x2F;&#x2F; 通过props数组接收</span><br><span class="line">    props: [ &quot;messageFromParent&quot; ]</span><br><span class="line">&#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>这里有个需要注意的地方，父组件给子组件的数据是单向的，虽然子组件也可以修改父组件传入的数据，但是会产生一个错误，并打印在终端里。</p><p>那么我们怎么才能修改父组件的值呢？答案是<code>this.$emit</code>。</p><p>我们给子组件绑定上v-on，来监听子组件的事件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;#app&quot;&gt;</span><br><span class="line">        &#x2F;&#x2F; 通过v-bind绑定父子组件的属性，通过v-on监听子组件的属性变化</span><br><span class="line">        &lt;hello v-bind:messageFromParent&#x3D;&quot;message&quot; v-on:changeParentData&#x3D;&quot;changeData&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line">import Hello from &#39;.&#x2F;Hello.vue&#39;;</span><br><span class="line">export default Vue.extend(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: &quot;this message from parent&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        &quot;hello&quot;: Hello</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        changeData: function(data: string) &#123;</span><br><span class="line">            message &#x3D; data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>子组件只需要发送出修改即可：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;button v-on:click&#x3D;&quot;change&quot;&gt;修改父组件数据&lt;&#x2F;button&gt;</span><br><span class="line">        &#123;&#123; messageFromParent &#125;&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line">export default Vue.extend(&#123;</span><br><span class="line">    &#x2F;&#x2F; 通过props数组接收</span><br><span class="line">    props: [ &quot;messageFromParent&quot; ],</span><br><span class="line">    methods: &#123;</span><br><span class="line">        change: function() &#123;</span><br><span class="line">            &#x2F;&#x2F; 调用this.$emit方法第一个参数是事件的名称，后面全部都是参数。</span><br><span class="line">            &#x2F;&#x2F; this.$emit方法其实是自定义了一个事件，通过这种方式来完成子组件向父组件传递消息。</span><br><span class="line">            this.$emit(&quot;changeParentData&quot;, &quot;change data by child&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>以上就是Vue父子组件传值的一种常用方法，适用于相邻组件的，如果隔代了，那么这种方式就不好用了，中间路过的组件都需要转发这个事件，处理这种情况就需要使用<code>provide/ inject</code>了，不过那就是另一篇文章啦。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>添加Vue动画</title>
      <link href="/2019/12/08/vue-transitions/"/>
      <url>/2019/12/08/vue-transitions/</url>
      
        <content type="html"><![CDATA[<p>以前一直搞不懂动画是怎么做的，它怎么这么神奇，写了一点看不懂的代码，就实现了非常丰富的效果，现在做了三年Qt开发，接触到了Qt的动画类，明白了动画是怎么一会儿事，现在来看当初的css动画代码，也明白了它是如何工作的了。本文会介绍一下Vue提供的组件过渡动画模块——transitions。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Vue在插入、更新和移除DOM元素时，提供了多种不同方式的应用过渡效果。包含以下工具：</p><ul><li>在css过渡和动画中自动应用class</li><li>可以配合第三方动画css类，例如Animae.css</li><li>提供钩子函数来使JS操作DOM元素</li><li>可以配合使用第三方JavaScript动画库，例如Velocity.js</li></ul><h2 id="单元素-组件过渡"><a href="#单元素-组件过渡" class="headerlink" title="单元素/组件过渡"></a>单元素/组件过渡</h2><p>Vue提供了 <code>transitions</code> 的封装组件，在下面的情况中，可以给任意元素或组件添加进入和离开的过渡效果。</p><ul><li>条件渲染 (使用 <code>v-show</code>)</li><li>按需渲染 (使用 <code>v-if</code>)</li><li>动态节点</li><li>组件根元素</li></ul><p>这是一个基本的例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;button v-on:click&#x3D;&quot;show &#x3D; !show&quot;&gt;</span><br><span class="line">    Toggle</span><br><span class="line">    &lt;&#x2F;button&gt;</span><br><span class="line">    &lt;transitions name&#x3D;&quot;fade&quot;&gt;</span><br><span class="line">        &lt;p v-if&#x3D;&quot;show&quot;&gt; hello! &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;transitions&gt;</span><br><span class="line">&lt;div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: &quot;#app&quot;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        show: false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在head中添加style：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.fade-enter-active,</span><br><span class="line">.fade-leave-active &#123;</span><br><span class="line">  transition: opacity .5s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.fade-enter,</span><br><span class="line">.fade-leave-to &#123;</span><br><span class="line">  opacity: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有三点需要注意一下，需要动画的元素需要使用transitions节包裹起来，transitions需要一个name，css中需要使用固定的拼写来应用动画，入场动画和离场动画的状态是一致的，所以写在了一组里。</p><p>当插入和删除包含在 <code>transitions</code> 组件中的元素时，Vue会做以下的事情：</p><ul><li>自动嗅探组件是否应用了css的过渡或动画，如果有，则在恰当的实际添加/删除css类名。</li><li>如果 <code>transitions</code> 组件提供了钩子函数，Vue会在恰当的时机调用钩子函数。</li><li>如果没有找到css过渡和动画，也没有找到钩子函数，则DOM的操作(插入和删除)在下一帧中立即执行。(注意是指浏览器的逐帧动画，而不是Vue的nextTick机制)</li></ul><h3 id="过渡的类名"><a href="#过渡的类名" class="headerlink" title="过渡的类名"></a>过渡的类名</h3><p>Vue的过渡动画一共有6个状态：</p><ol><li><code>v-enter</code>: 定义进入过渡的开始状态，在元素被插入之前生效，待元素插入以后被移除。</li><li><code>v-enter-active</code>: 定义进入过渡生效时的状态，在整个进入过渡的阶段中应用，在元素插入之前生效，在过渡/动画完成后被移除。这个类可以定义过渡时间、延迟和动画曲线。</li><li><code>v-enter-to</code>: <strong>在2.1.8版本及以上</strong> 定义进入过渡的结束状态，在元素被插入的下一帧生效(与此同时 <code>v-enter</code> 被移除)，在过渡/动画完成后移除。</li><li><code>v-leave</code>: 定义离开过渡的开始状态，在离开过渡被触发时立即生效，下一帧被移除。</li><li><code>v-leave-active</code>: 定义离开过渡生效时的状态，在整个离开过渡的阶段中应用，在离开过渡触发时立即生效，在过渡/动画完成后立即被移除。这个类可以定义离开过渡的过程时间、延迟和动画曲线。</li><li><code>v-leave-to</code>: <strong>在2.1。8版本及以上</strong> 定义离开过渡的结束状态，在离开过渡被触发之后的下一帧被移除(与此同时<code>v-leave</code>也被删除)<br>，在过渡/动画完成之后移除。</li></ol><p><img src="https://cn.vuejs.org/images/transition.png" alt="transitions"></p><p>可以看出一共两组动画，进入和离开的active。并且分别有两个状态，enter和enter-to，这6个状态控制了入场动画和离场动画。(吐槽一下Qt的动画系统，定义一个QAnimation只能做半场动画，想做到Vue这样的要定义两组，或者反向播放)</p><p>对于那些正在过渡中切换的类名来说，如果使用了没有<code>name</code>属性的<code>transition</code>，Vue会使用v-当做默认前缀。为了避免多组动画冲突，我个人建议每一个<code>transition</code>组件都提供name属性。</p><h3 id="JavaScript钩子函数"><a href="#JavaScript钩子函数" class="headerlink" title="JavaScript钩子函数"></a>JavaScript钩子函数</h3><p><code>transition</code>也提供了钩子函数，使我们可以通过JavaScript来控制DOM元素，一共也包含了8个函数：</p><ol><li>beforeEnter</li><li>enter</li><li>afterEnter</li><li>enterCancelled</li><li>beforeLeave</li><li>leave</li><li>afterLeave</li><li>leaveCancelled</li></ol><p>和css上要求的命名保持一致，只是增加了两个取消的接口，当动画被取消的时候被调用。</p><p>这些钩子函数可以结合CSS <code>transition/animations</code> 使用，也可以单独使用。</p><blockquote><p>当只使用JavaScript过渡的时候，必须在 <strong>enter</strong> 和 <strong>leave</strong> 显式调用<code>done()</code>进行回调，否则他们将被同步调用，过渡会立即完成。</p></blockquote><blockquote><p>推荐对于仅使用JavaScript过渡的元素添加<code>v-bind:css=&quot;false&quot;</code>，Vue会跳过CSS的检测，这也可以避免过渡过程中css的影响。</p></blockquote><h2 id="列表元素的过渡"><a href="#列表元素的过渡" class="headerlink" title="列表元素的过渡"></a>列表元素的过渡</h2><p>以上我分享的都是单元素/组件的过渡，那么问题来了，列表这种通过v-for创建的元素该如何增加过渡效果呢？</p><p>Vue提供了<code>&lt;transition-group&gt;</code>组件，在深入了解之前，需要先介绍一下这个组件的一些特点：</p><ul><li>不同于<code>&lt;transition&gt;</code>，<code>&lt;transition-group&gt;</code>会创建一个真实的DOM元素，默认是<span>，可以通过tag属性切换为其他元素。</li><li>过渡模式不再可用，因为我们不再相互切换特有的元素</li><li>内部元素总是需要提供唯一的key值来进行区分</li><li>CSS过渡将会应用在内部的元素中，而不是这个组/容器本身</li></ul><h3 id="列表的进入-离开过渡"><a href="#列表的进入-离开过渡" class="headerlink" title="列表的进入/离开过渡"></a>列表的进入/离开过渡</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">&lt;button v-on:click&#x3D;&quot;add&quot;&gt;add&lt;&#x2F;button&gt;</span><br><span class="line">&lt;button v-on:click&#x3D;&quot;remove&quot;&gt;remove&lt;&#x2F;button&gt;</span><br><span class="line">&lt;transition-group name&#x3D;&quot;group&quot; tag&#x3D;&quot;ul&quot;&gt;</span><br><span class="line">&lt;li v-for&#x3D;&quot;item in items&quot; v-bind:key&#x3D;&quot;item&quot;&gt;</span><br><span class="line">  &#123;&#123; item &#125;&#125;</span><br><span class="line">&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;transition-group&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">el: &quot;#app&quot;,</span><br><span class="line">data: &#123;</span><br><span class="line">items: [1,2,3]</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">  add() &#123;</span><br><span class="line">  this.items.push(0)</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.group-enter,</span><br><span class="line">.group-leave-to &#123;</span><br><span class="line">  opacity: 0;</span><br><span class="line">  transform: translateY(10px)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.group-enter-active,</span><br><span class="line">.group-leave-active &#123;</span><br><span class="line">  transition: all 1s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码在<a href="https://jsfiddle.net/justforlxz/9denwmor/20/" target="_blank" rel="noopener">这里，点击访问</a>，只实现了添加元素的过渡效果。</p><p>希望本文可以帮助你理解Vue是如何处理过渡动画，本文是基于官网的知识和demo所编写的，本文只写了一部分我觉得需要掌握的基本功能，Vue的transition组件还有很多功能等待你的挖掘，<a href="https://cn.vuejs.org/v2/guide/transitions.html" target="_blank" rel="noopener">点击前往Vue官网文档</a></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用webpack-dev-server来监听项目变化</title>
      <link href="/2019/11/25/%E4%BD%BF%E7%94%A8webpack-dev-server%E6%9D%A5%E7%9B%91%E5%90%AC%E9%A1%B9%E7%9B%AE%E5%8F%98%E5%8C%96/"/>
      <url>/2019/11/25/%E4%BD%BF%E7%94%A8webpack-dev-server%E6%9D%A5%E7%9B%91%E5%90%AC%E9%A1%B9%E7%9B%AE%E5%8F%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>webpack的出现方便了前端开发者，使开发和部署分成了两部分，开发者可以正常根据工程化的要求进行开发，部署时通过webpack实现代码的裁剪和优化。</p><p>本次就介绍一个webpack的功能 <code>webpack-dev-server</code></p><p>将webpack与提供实时重载的开发服务器一起使用。这仅应用于开发。<br>它在后台使用了webpack-dev-middleware，它提供了对Webpack资产的快速内存访问。</p><a id="more"></a><p>webpack-dev-server提供了一个小型的express的http服务器，这个http服务器和client使用了websocket通讯协议，原始文件作出改动后，webpack-dev-server会实时的编译，但是最后的编译的文件并没有输出到目标文件夹。</p><p><strong>注意：启动webpack-dev-server后，在目标文件夹中是看不到编译后的文件的,编译后的文件都保存到了内存当中来加速访问。</strong></p><h2 id="启用webpack-dev-server"><a href="#启用webpack-dev-server" class="headerlink" title="启用webpack-dev-server"></a>启用webpack-dev-server</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -D webpack-dev-server</span><br></pre></td></tr></table></figure><p>在webpack.config.js中添加devServer对象：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: path.join(__dirname, &#39;dist&#39;),</span><br><span class="line">    compress: true, &#x2F;&#x2F; 开启压缩</span><br><span class="line">    port: 9000 &#x2F;&#x2F; 指定运行的端口</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后通过<code>npx webpack-dev-server</code>启动，终端上会输出一些信息，一般我们会增加一些参数来使输出更加好看:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-dev-server --devtool eval-source-map --progress --colors --hot --inline</span><br></pre></td></tr></table></figure><p>上面的命令增加一个开发工具 <code>eval-source-map</code>，开启了progress进度显示，开启了colors颜色，hot热更新和inline更新模式。上面的参数也可以添加到devServer的属性中。</p><p>终端输出的内容如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10% building 1&#x2F;1 modules 0 activeℹ ｢wds｣: Project is running at http:&#x2F;&#x2F;localhost:9000&#x2F;</span><br><span class="line">ℹ ｢wds｣: webpack output is served from &#x2F;dist&#x2F;</span><br><span class="line">ℹ ｢wds｣: Content not from webpack is served from &#x2F;home&#x2F;justforlxz&#x2F;Projects&#x2F;VueBlog&#x2F;dist</span><br><span class="line">ℹ ｢wdm｣: Hash: ff9005d9f6ffafd11cd4</span><br><span class="line">Version: webpack 4.41.0</span><br><span class="line">Time: 2938ms</span><br><span class="line">Built at: 11&#x2F;25&#x2F;2019 6:03:50 PM</span><br><span class="line">  Asset      Size  Chunks             Chunk Names</span><br><span class="line">main.js  2.09 MiB    main  [emitted]  main</span><br><span class="line">Entrypoint main &#x3D; main.js</span><br><span class="line">[0] multi (webpack)-dev-server&#x2F;client?http:&#x2F;&#x2F;localhost:9000 (webpack)&#x2F;hot&#x2F;dev-server.js .&#x2F;src&#x2F;main.ts 52 bytes &#123;main&#125; [built]</span><br></pre></td></tr></table></figure><p>我们就可以通过localhost:9000来访问我们的应用了。</p><p>需要注意的是，由于我们经常把内容输出到dist目录，但是webpack运行是在项目目录的，访问webpack生成在dist目录的main.js时，需要写上相对于webpack的目录，例如dist/main.js。否则会找不到文件。</p><p>如果遇到问题，导航到 /webpack-dev-server 路径，可以显示出文件的服务位置。 例如，<a href="http://localhost:9000/webpack-dev-server%E3%80%82" target="_blank" rel="noopener">http://localhost:9000/webpack-dev-server。</a></p><h2 id="配置webpack"><a href="#配置webpack" class="headerlink" title="配置webpack"></a>配置webpack</h2><p>webpack-dev-server支持在服务内部调用中间件对数据进行处理。</p><h3 id="devServer-before"><a href="#devServer-before" class="headerlink" title="devServer.before"></a>devServer.before</h3><p><code>function (app, server)</code></p><p>在服务内部的所有其他中间件之前， 提供执行自定义中间件的功能。 这可以用来配置自定义处理程序，例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    before: function(app, server) &#123;</span><br><span class="line">      app.get(&#39;&#x2F;some&#x2F;path&#39;, function(req, res) &#123;</span><br><span class="line">        res.json(&#123; custom: &#39;response&#39; &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="devServer-after"><a href="#devServer-after" class="headerlink" title="devServer.after"></a>devServer.after</h3><p>同devServer.before，在服务内部的所有中间件之后，提供执行自定义中间件的功能。</p><h3 id="devServer-allowedHosts"><a href="#devServer-allowedHosts" class="headerlink" title="devServer.allowedHosts"></a>devServer.allowedHosts</h3><p>允许添加白名单服务，允许一些开发服务器访问。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    allowedHosts: [</span><br><span class="line">      &#39;host.com&#39;,</span><br><span class="line">      &#39;subdomain.host.com&#39;,</span><br><span class="line">      &#39;subdomain2.host.com&#39;,</span><br><span class="line">      &#39;host2.com&#39;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>模仿 django 的 ALLOWED_HOSTS，以 . 开头的值可以用作子域通配符。.host.com 将会匹配 host.com, <a href="http://www.host.com/" target="_blank" rel="noopener">www.host.com</a> 和 host.com 的任何其他子域名。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    &#x2F;&#x2F; 这实现了与第一个示例相同的效果，</span><br><span class="line">    &#x2F;&#x2F; 如果新的子域名需要访问 dev server，</span><br><span class="line">    &#x2F;&#x2F; 则无需更新您的配置</span><br><span class="line">    allowedHosts: [</span><br><span class="line">      &#39;.host.com&#39;,</span><br><span class="line">      &#39;host2.com&#39;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="devServer-clientLogLevel"><a href="#devServer-clientLogLevel" class="headerlink" title="devServer.clientLogLevel"></a>devServer.clientLogLevel</h3><p><code>string: &#39;none&#39; | &#39;info&#39; | &#39;error&#39; | &#39;warning&#39;</code></p><p>当使用内联模式(inline mode)时，会在开发工具(DevTools)的控制台(console)显示消息，例如：在重新加载之前，在一个错误之前，或者 模块热替换(Hot Module Replacement) 启用时。默认值是 info。</p><p>devServer.clientLogLevel 可能会显得很繁琐，你可以通过将其设置为 ‘none’ 来关闭 log。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    clientLogLevel: &#39;none&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="devServer-color-只用于命令行工具-CLI"><a href="#devServer-color-只用于命令行工具-CLI" class="headerlink" title="devServer.color  - 只用于命令行工具(CLI)"></a>devServer.color  - 只用于命令行工具(CLI)</h3><p>只在终端下启用，启用/禁用控制台的彩色输出。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-dev-server --color</span><br></pre></td></tr></table></figure><h3 id="devServer-compress"><a href="#devServer-compress" class="headerlink" title="devServer.compress"></a>devServer.compress</h3><p><code>boolean</code></p><p>一切服务都开启gzip压缩。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    compress: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="devServer-contentBase"><a href="#devServer-contentBase" class="headerlink" title="devServer.contentBase"></a>devServer.contentBase</h3><p><code>boolean: false string [string] number</code></p><p>告诉服务器从哪个目录中提供内容。只有在你想要提供静态文件时才需要。devServer.publicPath 将用于确定应该从哪里提供 bundle，并且此选项优先。</p><p>默认情况下，将使用当前工作目录作为提供内容的目录。将其设置为 false 以禁用 contentBase。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: path.join(__dirname, &#39;public&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可以从多个目录提供内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: [path.join(__dirname, &#39;public&#39;), path.join(__dirname, &#39;assets&#39;)]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="devServer-disableHostCheck"><a href="#devServer-disableHostCheck" class="headerlink" title="devServer.disableHostCheck"></a>devServer.disableHostCheck</h3><p><code>boolean</code></p><p>设置为 true 时，此选项绕过主机检查。不建议这样做，因为不检查主机的应用程序容易受到 DNS 重新连接攻击。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    disableHostCheck: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="devServer-filename"><a href="#devServer-filename" class="headerlink" title="devServer.filename"></a>devServer.filename</h3><p><code>string</code></p><p>在 lazy mode(惰性模式) 中，此选项可减少编译。 默认在 lazy mode(惰性模式)，每个请求结果都会产生全新的编译。使用 filename，可以只在某个文件被请求时编译。</p><p>如果 output.filename 设置为 ‘bundle.js’ ，devServer.filename 用法如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;bundle.js&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    lazy: true,</span><br><span class="line">    filename: &#39;bundle.js&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在只有在请求了bundle.js时，才会去编译bundle。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>webpack的功能确实很强大，可以针对代码进行各种操作，最终生成出可以适应各种场景的代码，使开发和部署彻底分离开来，开发者可以更加专注项目。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给Archlinux开启BFQ和MuQSS</title>
      <link href="/2019/10/24/%E7%BB%99Archlinux%E5%BC%80%E5%90%AFBFQ%E5%92%8CMuQSS/"/>
      <url>/2019/10/24/%E7%BB%99Archlinux%E5%BC%80%E5%90%AFBFQ%E5%92%8CMuQSS/</url>
      
        <content type="html"><![CDATA[<p>最近在Arch上更新系统的时候，总是遇到图形完全卡住的情况，今天上午突然想起来自己曾经设置了使用noop的IO调度，猜测是因为这个。然后本着不折腾不舒服的原则，打算使用ck内核上MuQSS的进程调度和BFQ的IO调度。</p><a id="more"></a><p>ck内核并没有在arch的仓库，但是aur有linux-ck的包，安装一下就可以了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yay -S linux-ck linux-ck-headers</span><br></pre></td></tr></table></figure><p>编译需要一些时间，在我的破本子i7-8550U编译了一顿过桥米线的时间，然后成功使用了ck内核。</p><h3 id="开启MuQSS"><a href="#开启MuQSS" class="headerlink" title="开启MuQSS"></a>开启MuQSS</h3><p>ck内核默认使用的就是MuQSS调度，并不需要修改什么，开机即可。</p><h3 id="开启BFQ"><a href="#开启BFQ" class="headerlink" title="开启BFQ"></a>开启BFQ</h3><p>开启BFQ需要一些手动设置。分为两步：</p><ol><li>修改grub，给内核提供新的参数</li><li>使用udev开启动态调整</li></ol><p><strong>修改grub</strong></p><p>编辑<code>/etc/default/grub</code>中<code>GRUB_CMDLINE_LINUX_DEFAULT</code>，增加一行内容:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX_DEFAULT&#x3D;&quot;quiet scsi_mod.use_blk_mq&#x3D;1&quot;</span><br></pre></td></tr></table></figure><p>然后更新grub配置文件:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo grub-mkconfig -o &#x2F;boot&#x2F;grub&#x2F;grub.cfg</span><br></pre></td></tr></table></figure><p><strong>创建udev规则</strong></p><p>创建并编辑<code>/etc/udev/rules.d/60-scheduler.rules</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># set deadline scheduler for non-rotating disks</span><br><span class="line">ACTION&#x3D;&#x3D;&quot;add|change&quot;, KERNEL&#x3D;&#x3D;&quot;sd[a-z]&quot;, TEST!&#x3D;&quot;queue&#x2F;rotational&quot;, ATTR&#123;queue&#x2F;scheduler&#125;&#x3D;&quot;deadline&quot;</span><br><span class="line">ACTION&#x3D;&#x3D;&quot;add|change&quot;, KERNEL&#x3D;&#x3D;&quot;sd[a-z]&quot;, ATTR&#123;queue&#x2F;rotational&#125;&#x3D;&#x3D;&quot;0&quot;, ATTR&#123;queue&#x2F;scheduler&#125;&#x3D;&quot;bfq&quot;</span><br><span class="line"></span><br><span class="line"># set cfq scheduler for rotating disks</span><br><span class="line">ACTION&#x3D;&#x3D;&quot;add|change&quot;, KERNEL&#x3D;&#x3D;&quot;sd[a-z]&quot;, ATTR&#123;queue&#x2F;rotational&#125;&#x3D;&#x3D;&quot;1&quot;, ATTR&#123;queue&#x2F;scheduler&#125;&#x3D;&quot;bfq&quot;</span><br><span class="line">ACTION&#x3D;&#x3D;&quot;add|change&quot;, KERNEL&#x3D;&#x3D;&quot;nvme[0-9]n1&quot;, ATTR&#123;queue&#x2F;rotational&#125;&#x3D;&#x3D;&quot;0&quot;, ATTR&#123;queue&#x2F;scheduler&#125;&#x3D;&quot;bfq&quot;</span><br></pre></td></tr></table></figure><p>上面的配置是给固态硬盘使用deadline，给机械盘使用bfq，给nvme盘bfq。</p><p>本着电脑只有ssd，所以天不怕地不怕的原则，我选择全部使用bfq。</p><p>然后重启电脑，查看所有硬盘的调度器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># justforlxz @ archlinux in ~ [13:29:04]</span><br><span class="line">$ cat &#x2F;sys&#x2F;block&#x2F;*&#x2F;queue&#x2F;scheduler</span><br><span class="line">mq-deadline kyber [bfq] none</span><br><span class="line">mq-deadline kyber [bfq] none</span><br></pre></td></tr></table></figure><p>通过dmesg查看MuQSS是否开启：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo dmesg | grep -i scheduler</span><br><span class="line">Alias tip: _ dmesg | grep -i scheduler</span><br><span class="line">[    0.295872] rcu: RCU calculated value of scheduler-enlistment delay is 10 jiffies.</span><br><span class="line">[    1.223982] io scheduler mq-deadline registered</span><br><span class="line">[    1.223984] io scheduler kyber registered</span><br><span class="line">[    1.224038] io scheduler bfq registered</span><br><span class="line">[    1.586191] MuQSS CPU scheduler v0.193 by Con Kolivas.</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MuQSS是BFS(脑残调度器)的进化版，主要是改进了BFS的O(n)复杂度，BFS适用于桌面环境用户，可以提供较好的进程切换和延迟。<br>BFQ是针对硬盘的IO调度，它通过预先分配一定的IO吞吐量来合理安排每个进程的IO操作。我需要用几天来感受一下MuQSS和CFQ的好处。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用webpack打包Vue和TypeScript</title>
      <link href="/2019/10/22/%E4%BD%BF%E7%94%A8webpack%E6%89%93%E5%8C%85Vue%E5%92%8CTypeScript/"/>
      <url>/2019/10/22/%E4%BD%BF%E7%94%A8webpack%E6%89%93%E5%8C%85Vue%E5%92%8CTypeScript/</url>
      
        <content type="html"><![CDATA[<p>本文将会介绍如何通过Webpack将基于TypeScript的Vue项目进行打包。</p><a id="more"></a><h2 id="webpack基础配置"><a href="#webpack基础配置" class="headerlink" title="webpack基础配置"></a>webpack基础配置</h2><p>首先创建一个基本的webpack.config.js文件:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require( &#39;path&#39; );</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: &quot;.&#x2F;src&#x2F;index.ts&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve( __dirname, &#39;dist&#39; ),</span><br><span class="line">        publicPath: &#39;&#x2F;dist&#x2F;&#39;,</span><br><span class="line">        filename: &#39;[name].js&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: &#39;inline-source-map&#39;,</span><br><span class="line">    mode: &#39;development&#39;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时webpack只能将src/index.ts文件直接输出为index.js，我们需要添加typescript的loader，进行typescript的转换。</p><p>将以下代码加入rules节:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: &#x2F;\.ts?$&#x2F;,</span><br><span class="line">    loader: &#39;ts-loader&#39;,</span><br><span class="line">    exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>通过ts-loader进行ts文件的转换，我们还需要创建typescript的一个配置文件。</p><h2 id="添加typescript支持"><a href="#添加typescript支持" class="headerlink" title="添加typescript支持"></a>添加typescript支持</h2><p>创建tsconfig.json</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;outDir&quot;: &quot;.&#x2F;dist&#x2F;&quot;,</span><br><span class="line">        &quot;sourceMap&quot;: true,</span><br><span class="line">        &quot;strict&quot;: true,</span><br><span class="line">        &quot;module&quot;: &quot;commonjs&quot;,</span><br><span class="line">        &quot;moduleResolution&quot;: &quot;node&quot;,</span><br><span class="line">        &quot;target&quot;: &quot;es5&quot;,</span><br><span class="line">        &quot;skipLibCheck&quot;: true,</span><br><span class="line">        &quot;esModuleInterop&quot;: true,</span><br><span class="line">        &quot;experimentalDecorators&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;include&quot;: [</span><br><span class="line">        &quot;.&#x2F;src&#x2F;**&#x2F;*&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要在webpack的配置中添加ts文件，在resolve节中添加:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extensions: [ &#39;.ts&#39;, &#39;.js&#39; ],</span><br></pre></td></tr></table></figure><p>我们指定ts转换出的js代码是es5的。</p><p>这个时候我们运行webpack，将会看到正常的转换输出。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hash: c3a0ae2c47032de12eec</span><br><span class="line">Version: webpack 4.41.0</span><br><span class="line">Time: 1880ms</span><br><span class="line">Built at: 10&#x2F;22&#x2F;2019 3:40:59 PM</span><br><span class="line">   Asset      Size  Chunks             Chunk Names</span><br><span class="line">index.js  11.8 KiB   index  [emitted]  index</span><br><span class="line">Entrypoint index &#x3D; index.js</span><br><span class="line">[.&#x2F;src&#x2F;index.ts] 269 bytes &#123;index&#125; [built]</span><br></pre></td></tr></table></figure><p>入口文件就是index.ts了，之后我们就正常的在index.ts中写我们的代码，webpack就会查找所有的依赖，并打包输出到index.js中。</p><h2 id="添加Vue单文件的支持"><a href="#添加Vue单文件的支持" class="headerlink" title="添加Vue单文件的支持"></a>添加Vue单文件的支持</h2><p>Vue单文件组件(SFC)规范是指在一个文件中，提供html、css和script代码，三者包含在顶级语言块 <code>&lt;template&gt;</code>、<code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code><br> 中，还允许添加可选的自定义块。</p><p>这是一个简单的vue单文件例子:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;example&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &#39;Hello world!&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.example &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;custom1&gt;</span><br><span class="line">  This could be e.g. documentation for the component.</span><br><span class="line">&lt;&#x2F;custom1&gt;</span><br></pre></td></tr></table></figure><p>我们通过vue-loader来解析该文件，提取每一个语言块，如有需要，会传递给其他loader进行处理，最后组装为一个ES Module。</p><p>我们在webpack的rules节中添加vue-loader:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: &#x2F;\.vue$&#x2F;,</span><br><span class="line">  loader: &#39;vue-loader&#39;,</span><br><span class="line">  options: &#123;</span><br><span class="line">    loaders: &#123;</span><br><span class="line">      &#x2F;&#x2F; Since sass-loader (weirdly) has SCSS as its default parse mode, we map</span><br><span class="line">      &#x2F;&#x2F; the &quot;scss&quot; and &quot;sass&quot; values for the lang attribute to the right configs here.</span><br><span class="line">      &#x2F;&#x2F; other preprocessors should work out of the box, no loader config like this necessary.</span><br><span class="line">      &#39;scss&#39;: &#39;vue-style-loader!css-loader!sass-loader&#39;,</span><br><span class="line">      &#39;sass&#39;: &#39;vue-style-loader!css-loader!sass-loader?indentedSyntax&#39;,</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; other vue-loader options go here</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="如果vue是typescript代码？"><a href="#如果vue是typescript代码？" class="headerlink" title="如果vue是typescript代码？"></a>如果vue是typescript代码？</h2><p>其实这很简单，ts-loader有一个appendTsSuffixTo的功能，可以给某个文件增加.ts的后缀，从而识别这个文件为ts文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: &#x2F;\.tsx?$&#x2F;,</span><br><span class="line">  loader: &#39;ts-loader&#39;,</span><br><span class="line">  exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">  options: &#123;</span><br><span class="line">    appendTsSuffixTo: [&#x2F;\.vue$&#x2F;],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>我们还需要在项目中添加一个vue-shim.d.ts来让ts正确的识别vue。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare module &#39;*.vue&#39; &#123;</span><br><span class="line">  import Vue from &#39;vue&#39;</span><br><span class="line">  export default Vue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要在webpack的resolve节追加vue的后缀:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  extensions: [ &#39;.tsx&#39;, &#39;.ts&#39;, &#39;.js&#39; , &#39;.vue&#39;],</span><br><span class="line">  alias: &#123;</span><br><span class="line">    &#39;vue&#39;: &#39;vue&#x2F;dist&#x2F;vue.js&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>vue-loader现在需要手动处理一下插件，在webpack.config.js的头部导入vue-loader，并在plugins节创建对象。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; VueLoaderPlugin &#125; &#x3D; require(&#39;vue-loader&#39;)</span><br><span class="line"></span><br><span class="line">.......</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  new VueLoaderPlugin()</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>否则将不能正确工作。</p><p>此时已经完成了webpack+vue+typescript的全部工作。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hash: 320d4ed3f55f52872694</span><br><span class="line">Version: webpack 4.41.0</span><br><span class="line">Time: 2494ms</span><br><span class="line">Built at: 10&#x2F;22&#x2F;2019 4:00:50 PM</span><br><span class="line">      Asset       Size    Chunks             Chunk Names</span><br><span class="line">  bundle.js   1.12 MiB    bundle  [emitted]  bundle</span><br><span class="line">electron.js   12.2 KiB  electron  [emitted]  electron</span><br><span class="line"> index.html  194 bytes            [emitted]</span><br><span class="line">Entrypoint bundle &#x3D; bundle.js</span><br><span class="line">Entrypoint electron &#x3D; electron.js</span><br><span class="line">[.&#x2F;node_modules&#x2F;css-loader&#x2F;dist&#x2F;cjs.js!.&#x2F;node_modules&#x2F;vue-loader&#x2F;lib&#x2F;loaders&#x2F;stylePostLoader.js!.&#x2F;node_modules&#x2F;sass-loader&#x2F;dist&#x2F;cjs.js!.&#x2F;node_modules&#x2F;vue-loader&#x2F;lib&#x2F;index.js?!.&#x2F;src&#x2F;app.vue?vue&amp;type&#x3D;style&amp;index&#x3D;0&amp;id&#x3D;5ef48958&amp;rel&#x3D;stylesheet%2Fscss&amp;lang&#x3D;scss&amp;scoped&#x3D;true&amp;] .&#x2F;node_modules&#x2F;css-loader&#x2F;dist&#x2F;cjs.js!.&#x2F;node_modules&#x2F;vue-loader&#x2F;lib&#x2F;loaders&#x2F;stylePostLoader.js!.&#x2F;node_modules&#x2F;sass-loader&#x2F;dist&#x2F;cjs.js!.&#x2F;node_modules&#x2F;vue-loader&#x2F;lib??vue-loader-options!.&#x2F;src&#x2F;app.vue?vue&amp;type&#x3D;style&amp;index&#x3D;0&amp;id&#x3D;5ef48958&amp;rel&#x3D;stylesheet%2Fscss&amp;lang&#x3D;scss&amp;scoped&#x3D;true&amp; 542 bytes &#123;bundle&#125; [built]</span><br><span class="line">[.&#x2F;node_modules&#x2F;ts-loader&#x2F;index.js?!.&#x2F;node_modules&#x2F;vue-loader&#x2F;lib&#x2F;index.js?!.&#x2F;src&#x2F;Components&#x2F;About.vue?vue&amp;type&#x3D;script&amp;lang&#x3D;ts&amp;] .&#x2F;node_modules&#x2F;ts-loader??ref--1!.&#x2F;node_modules&#x2F;vue-loader&#x2F;lib??vue-loader-options!.&#x2F;src&#x2F;Components&#x2F;About.vue?vue&amp;type&#x3D;script&amp;lang&#x3D;ts&amp; 305 bytes &#123;bundle&#125; [built]</span><br><span class="line">[.&#x2F;node_modules&#x2F;vue-loader&#x2F;lib&#x2F;loaders&#x2F;templateLoader.js?!.&#x2F;node_modules&#x2F;vue-loader&#x2F;lib&#x2F;index.js?!.&#x2F;src&#x2F;Components&#x2F;About.vue?vue&amp;type&#x3D;template&amp;id&#x3D;aa9c95a6&amp;] .&#x2F;node_modules&#x2F;vue-loader&#x2F;lib&#x2F;loaders&#x2F;templateLoader.js??vue-loader-options!.&#x2F;node_modules&#x2F;vue-loader&#x2F;lib??vue-loader-options!.&#x2F;src&#x2F;Components&#x2F;About.vue?vue&amp;type&#x3D;template&amp;id&#x3D;aa9c95a6&amp; 235 bytes &#123;bundle&#125; [built]</span><br><span class="line">[.&#x2F;node_modules&#x2F;vue-loader&#x2F;lib&#x2F;loaders&#x2F;templateLoader.js?!.&#x2F;node_modules&#x2F;vue-loader&#x2F;lib&#x2F;index.js?!.&#x2F;src&#x2F;app.vue?vue&amp;type&#x3D;template&amp;id&#x3D;5ef48958&amp;scoped&#x3D;true&amp;] .&#x2F;node_modules&#x2F;vue-loader&#x2F;lib&#x2F;loaders&#x2F;templateLoader.js??vue-loader-options!.&#x2F;node_modules&#x2F;vue-loader&#x2F;lib??vue-loader-options!.&#x2F;src&#x2F;app.vue?vue&amp;type&#x3D;template&amp;id&#x3D;5ef48958&amp;scoped&#x3D;true&amp; 589 bytes &#123;bundle&#125; [built]</span><br><span class="line">[.&#x2F;node_modules&#x2F;vue-style-loader&#x2F;index.js!.&#x2F;node_modules&#x2F;css-loader&#x2F;dist&#x2F;cjs.js!.&#x2F;node_modules&#x2F;vue-loader&#x2F;lib&#x2F;loaders&#x2F;stylePostLoader.js!.&#x2F;node_modules&#x2F;sass-loader&#x2F;dist&#x2F;cjs.js!.&#x2F;node_modules&#x2F;vue-loader&#x2F;lib&#x2F;index.js?!.&#x2F;src&#x2F;app.vue?vue&amp;type&#x3D;style&amp;index&#x3D;0&amp;id&#x3D;5ef48958&amp;rel&#x3D;stylesheet%2Fscss&amp;lang&#x3D;scss&amp;scoped&#x3D;true&amp;] .&#x2F;node_modules&#x2F;vue-style-loader!.&#x2F;node_modules&#x2F;css-loader&#x2F;dist&#x2F;cjs.js!.&#x2F;node_modules&#x2F;vue-loader&#x2F;lib&#x2F;loaders&#x2F;stylePostLoader.js!.&#x2F;node_modules&#x2F;sass-loader&#x2F;dist&#x2F;cjs.js!.&#x2F;node_modules&#x2F;vue-loader&#x2F;lib??vue-loader-options!.&#x2F;src&#x2F;app.vue?vue&amp;type&#x3D;style&amp;index&#x3D;0&amp;id&#x3D;5ef48958&amp;rel&#x3D;stylesheet%2Fscss&amp;lang&#x3D;scss&amp;scoped&#x3D;true&amp; 1.64 KiB &#123;bundle&#125; [built]</span><br><span class="line">[.&#x2F;src&#x2F;Components&#x2F;About.vue] 1.06 KiB &#123;bundle&#125; [built]</span><br><span class="line">[.&#x2F;src&#x2F;Components&#x2F;About.vue?vue&amp;type&#x3D;script&amp;lang&#x3D;ts&amp;] 350 bytes &#123;bundle&#125; [built]</span><br><span class="line">[.&#x2F;src&#x2F;Components&#x2F;About.vue?vue&amp;type&#x3D;template&amp;id&#x3D;aa9c95a6&amp;] 203 bytes &#123;bundle&#125; [built]</span><br><span class="line">[.&#x2F;src&#x2F;app.vue] 1.08 KiB &#123;bundle&#125; [built]</span><br><span class="line">[.&#x2F;src&#x2F;app.vue?vue&amp;type&#x3D;style&amp;index&#x3D;0&amp;id&#x3D;5ef48958&amp;rel&#x3D;stylesheet%2Fscss&amp;lang&#x3D;scss&amp;scoped&#x3D;true&amp;] 716 bytes &#123;bundle&#125; [built]</span><br><span class="line">[.&#x2F;src&#x2F;app.vue?vue&amp;type&#x3D;template&amp;id&#x3D;5ef48958&amp;scoped&#x3D;true&amp;] 207 bytes &#123;bundle&#125; [built]</span><br><span class="line">[.&#x2F;src&#x2F;entry.ts] 538 bytes &#123;bundle&#125; [built]</span><br><span class="line">[.&#x2F;src&#x2F;main.ts] 1.11 KiB &#123;electron&#125; [built]</span><br><span class="line">[.&#x2F;src&#x2F;route.ts] 1.35 KiB &#123;bundle&#125; [built]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Webpack </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack入门</title>
      <link href="/2019/10/14/webpack%E5%85%A5%E9%97%A8/"/>
      <url>/2019/10/14/webpack%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>现在前端开发不像以前一样，只需要写html、css和javascript文件就可以了。现代前端开发讲究工程化。</p><p><strong>什么是工程化？</strong></p><p>工程化即系统化、模块化、规范化的一个过程。</p><p><strong>为什么要工程化？</strong></p><p>工程化是让开发、测试和维护都变得更加可靠和提高效率的方式。</p><ol><li>制定规范</li><li>版本管理</li><li>单元测试</li><li>自动化</li></ol><p>通过制定流程的方式，规范了开发和测试的流程，让工作有章可循，方便团队协作。</p><a id="more"></a><p>最初的网页开发，是写好几份的javascript代码和css文件，手动在html中引入的。这样不适合多人协作开发，一旦开发人员多了，不可避免的会造成文件和命名冲突。<br>为了避免这些事情的发生，javascript增加了模块的概念。</p><p>有好的事情出现，就会有坏的事情发生。</p><p>过多的模块导致js文件下载很慢，而且有冗余，为了避免这件事情影响用户体验，webpack横空出世了。</p><p>webpack是一个现代javascript的静态模块打包器。它会递归的构建出依赖图，并根据依赖图来输出应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p><p>webpack有四个核心概念:</p><ul><li>入口(entry)</li><li>输出(output)</li><li>loader</li><li>插件</li></ul><p>入口决定了webpack要从哪个文件开始构建依赖图。</p><p>看一个简单的例子:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: &#39;.&#x2F;src&#x2F;index.js&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output则决定了webpack会在哪里输出生成的bundles，以及如何命名这些bundles。输出目录默认为 <code>./dist/</code> 。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &#39;dist&#39;),</span><br><span class="line">        filename: &#39;bundle.js&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loader可以让webpack打包非javascript文件，loader可以将所有类型的文件转换为webpack可以识别的有效模块，然后利用webpack的打包能力，对他们进行处理。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &#39;dist&#39;),</span><br><span class="line">        filename: &#39;bundle.js&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: &#123;</span><br><span class="line">            test: &#x2F;\.css$&#x2F;,</span><br><span class="line">            use: &#39;css-loader&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rules中的意思是，当require()/impot中被解析为.css的路径时，先使用css-loader转换一下。</p><p>我们可以开发新的loader去加载不同的文件，最终都通过webpack来打包到一起。</p><p>loader用于转换某些类型的模块，插件则工作的更加广泛。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。</p><p>想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;); &#x2F;&#x2F; 通过 npm 安装</span><br><span class="line">const webpack &#x3D; require(&#39;webpack&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &#39;dist&#39;),</span><br><span class="line">        filename: &#39;bundle.js&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: &#123;</span><br><span class="line">            test: &#x2F;\.css$&#x2F;,</span><br><span class="line">            use: &#39;css-loader&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new HtmlWebpackPlugin(&#123;template: &#39;.&#x2F;src&#x2F;index.html&#39;&#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过webpack，我们可以将整个项目都打包为一个文件进行分发，而且还可以进行优化。webpack的出现，将前端的开发和发布彻底的分离开，开发人员可以以各种方式进行开发，通过webpack打包以后输出部署需要的文件。</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wsl2的使用体验</title>
      <link href="/2019/06/16/wsl2%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/"/>
      <url>/2019/06/16/wsl2%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>wsl2已经是虚拟机平台了。</p><a id="more"></a><p>需要Windows版本在18917及以上，先开启虚拟机平台才能继续，在管理员权限的powershell中执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform</span><br></pre></td></tr></table></figure><p>对已安装的wsl1进行转换</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wsl --set-version &lt;Distro&gt; 2</span><br></pre></td></tr></table></figure><p>Distro可以通过 <code>wsl --list</code> 查看。</p><p>转换需要点时间，完成以后就可以浪起来了。</p><p>wsl2新增了一些参数：</p><ul><li><code>wsl --set-version &lt;Distro&gt; &lt;Version&gt;</code></li></ul><p>可以设置某个wsl的版本，1是旧版，2是新版。</p><ul><li><code>wsl --set-default-version &lt;Version&gt;</code></li></ul><p>设置默认的wsl版本，推荐设置一下。</p><ul><li><code>wsl --shutdown</code></li></ul><p>出于某些目的，比如已经完成了任务，不再需要wsl工作在后台，可以手动关闭。</p><ul><li><code>wsl --list --quiet</code></li></ul><p>仅列出分发名称，此命令对于脚本编写很有用，因为它只会输出您已安装的发行版的名称，而不显示其他信息，如默认发行版，版本等。</p><ul><li><code>wsl --list --verbose</code></li></ul><p>显示有关所有分发的详细信息。此命令列出每个发行版的名称，发行版所处的状态以及正在运行的版本。它还显示哪些分发是默认的星号。</p><p>当一切准备就绪，我就安装了docker，测试一波。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install docker-ce</span><br></pre></td></tr></table></figure><p>添加用户到docker组。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service docker --full-restart</span><br></pre></td></tr></table></figure><p>已经可以跑docker了，我们来做个测试，请出万能的hello world！</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull hello-world</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --rm hello-world</span><br></pre></td></tr></table></figure><p>然后就看到了想要的结果，hello world成功的跑起来了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https:&#x2F;&#x2F;hub.docker.com&#x2F;</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https:&#x2F;&#x2F;docs.docker.com&#x2F;get-started&#x2F;</span><br></pre></td></tr></table></figure><p>总的来说，因为wsl2改成虚拟机方案了，不过wsl2的启动速度还是挺快的，微软也努力让wsl2和wsl1之间在使用上没有差异。目前微软还没有完成wsl2的网络部分，wsl2和宿主机之间还需要使用专门的ip进行访问，等微软完成wsl2的localhost网络以后，就可以像以前一样直接跑一些网站或者需要端口的服务了。</p><img src="/2019/06/16/wsl2%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/Snipaste_2019-06-16_21-52-42.png" class="" title="网络截图"><p>来一张合照</p><img src="/2019/06/16/wsl2%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/Snipaste_2019-06-16_21-49-15.png" class="" title="合照"><p><a href="https://devblogs.microsoft.com/commandline/wsl-2-is-now-available-in-windows-insiders/" target="_blank" rel="noopener">点我查看wsl2的发布说明</a></p><p><a href="https://docs.microsoft.com/en-us/windows/wsl/wsl2-install" target="_blank" rel="noopener">点我查看如何安装wsl2</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入坑typescript了</title>
      <link href="/2019/06/15/%E5%85%A5%E5%9D%91typescript%E4%BA%86/"/>
      <url>/2019/06/15/%E5%85%A5%E5%9D%91typescript%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p>今天算是正式入坑 typescript 了，基于 vue 写了第一个函数，用来做一个文字效果。</p><p>演示效果：</p><img src="/2019/06/15/%E5%85%A5%E5%9D%91typescript%E4%BA%86/%E6%B7%B1%E5%BA%A6%E5%BD%95%E5%B1%8F_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190615202044.gif" class=""><a id="more"></a><p>整体思路听简单的，就是用定时器和延时器来做，通过定时器来间隔的处理文本，延时器来延后所有的方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TextHandle &#123;</span><br><span class="line">    private allDuration: number &#x3D; 0;</span><br><span class="line">    public appendText(text: string) : void &#123;</span><br><span class="line">        setTimeout(() &#x3D; &gt;&#123;</span><br><span class="line">            const LeftMessage &#x3D; document.getElementById(&#39;LeftMessage&#39;);</span><br><span class="line">            if (LeftMessage &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            let index: number &#x3D; 0;</span><br><span class="line">            const MessageText: string &#x3D; LeftMessage.innerText;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; tslint:disable-next-line:only-arrow-functions</span><br><span class="line">            const interval &#x3D; setInterval(function() &#123;</span><br><span class="line">                if ((LeftMessage &#x3D;&#x3D;&#x3D; null) || (index++ &#x3D;&#x3D;&#x3D; text.length + 1)) &#123;</span><br><span class="line">                    return clearInterval(interval);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                LeftMessage.innerText &#x3D; MessageText + text.substring(0, index);</span><br><span class="line">            &#125;,</span><br><span class="line">            300);</span><br><span class="line">        &#125;,</span><br><span class="line">        this.AllDuration);</span><br><span class="line">        this.AllDuration +&#x3D; text.length * 300 + 100;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>typescript确实挺不错的，平时都在写静态语言，如C++，所以当我开始学动态语言的时候，就会觉得水土不服，现在<br>通过typescript就可以让我继续使用静态语言的开发方式来写web，而且代码更容易理解。</p>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake CTests for dde-control-center</title>
      <link href="/2019/05/23/CMake-CTests-for-dde-control-center/"/>
      <url>/2019/05/23/CMake-CTests-for-dde-control-center/</url>
      
        <content type="html"><![CDATA[<p>什么是单元测试?</p><blockquote><p>在计算机编程中，单元测试又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。</p></blockquote><p>单元测试存在的意义在于，如果程序发生了异常情况，比如接收了错误的值，从而导致结果不正确，当修正程序中的错误后，为了避免再次遇到这个问题，需要对出问题的值和函数/功能进行一次测试，确保结果符合预期。</p><p>单元测试很重要，如果是新项目，请一定要刚开始就规划好单元测试。</p><p>为什么说单元测试很重要呢？因为单元测试的目的是隔离其他单元，并证明当前单元是正确的。这需要开发者在设计程序的时候就要考虑很多，合理的设计和规划项目。当未来重构项目的时候，可以局部重构来优化项目，而不是从零重写。</p><p>本文没有详细说明Qt的单元测试是如何编写的，编写Qt的单元测试放在以后再写(<del>咕咕咕</del>)。</p><a id="more"></a><p>写这篇文章是因为最近在给控制中心写单元测试，控制中心的模块都是MVC的，本身就做好了大方向的隔离，每个函数也基本是拆分出来的最小功能，可以单独拿出来测试。控制中心目前存在一个问题，Worker类是从DBus上接收数据，处理完成后放入Model中，如果测试Worker类，需要做很多和DBus相关的处理，比较麻烦，所以最开始我先把重心放在了创建Tests和测试一个基本的转换函数的功能，验证单元测试的流程。</p><blockquote><p><a href="https://github.com/linuxdeepin/dde-control-center/pull/171" target="_blank" rel="noopener">控制中心单元测试PR</a></p></blockquote><p>控制中心项目使用的CMake作为项目构建工具，所以用到了CTests，控制中心使用的Qt进行的开发，Qt也提供了自己的单元测试，我两个都做了支持。</p><p>在顶层的CMakeLists.txt中添加CTests的支持：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启用CTest检查</span><br><span class="line">include(Dart)</span><br><span class="line"></span><br><span class="line"># 启用CTest</span><br><span class="line">include(CTest)</span><br></pre></td></tr></table></figure><p>这两行内容需要在顶层CMakeLists.txt中添加，不然不会生效。</p><p>在子项目中创建一个dcc_test.h，用来写单元测试的类。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef DCC_TEST_H</span><br><span class="line">#define DCC_TEST_H</span><br><span class="line"></span><br><span class="line">#include &lt;QMap&gt;</span><br><span class="line">#include &lt;QString&gt;</span><br><span class="line">#include &lt;QTest&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;modules&#x2F;display&#x2F;displaywidget.h&quot;</span><br><span class="line"></span><br><span class="line">namespace Tests &#123;</span><br><span class="line"></span><br><span class="line">class Tests : public QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">private Q_SLOTS:</span><br><span class="line">    void testSliderValue_data()</span><br><span class="line">    &#123;</span><br><span class="line">        QTest::addColumn&lt;float&gt;(&quot;value&quot;);</span><br><span class="line">        QTest::addColumn&lt;int&gt;(&quot;result&quot;);</span><br><span class="line"></span><br><span class="line">        QMap&lt;float, int&gt; testMap&#123; &#123; 1.0, 1 &#125;,  &#123; 1.25, 2 &#125;, &#123; 1.5, 3 &#125;,</span><br><span class="line">                                  &#123; 1.75, 4 &#125;, &#123; 2.0, 5 &#125;,  &#123; 2.25, 6 &#125;,</span><br><span class="line">                                  &#123; 2.5, 7 &#125;,  &#123; 2.75, 8 &#125;, &#123; 3.0, 9 &#125; &#125;;</span><br><span class="line"></span><br><span class="line">        for (auto it &#x3D; testMap.constBegin(); it !&#x3D; testMap.constEnd(); ++it) &#123;</span><br><span class="line">            QTest::newRow(&quot;converToSlider&quot;) &lt;&lt; it.key() &lt;&lt; it.value();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void testSliderValue()</span><br><span class="line">    &#123;</span><br><span class="line">        QFETCH(float, value);</span><br><span class="line">        QFETCH(int, result);</span><br><span class="line"></span><br><span class="line">        using namespace dcc::display;</span><br><span class="line"></span><br><span class="line">        QCOMPARE(DisplayWidget::convertToSlider(value), result);</span><br><span class="line">        QCOMPARE(DisplayWidget::convertToScale(result), value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  &#x2F;&#x2F; namespace Tests</span><br><span class="line"></span><br><span class="line">QTEST_MAIN(Tests::Tests)</span><br><span class="line">#endif  &#x2F;&#x2F; !DCC_TEST_H</span><br></pre></td></tr></table></figure><p>在子项目的CMakeLists.txt中添加一个二进制，用来当作单元测试程序。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这个宏是Dart提供的，用来判断是否开启CTest</span><br><span class="line">if(BUILD_TESTING)</span><br><span class="line">find_package(Qt5 COMPONENTS</span><br><span class="line">    Test</span><br><span class="line">REQUIRED)</span><br><span class="line"></span><br><span class="line">set(Qt_LIBS</span><br><span class="line">    $&#123;Qt_LIBS&#125;</span><br><span class="line">    Qt5::Test</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">set(TEST_SRCS</span><br><span class="line">tests&#x2F;dcc_test.h</span><br><span class="line">$&#123;DISPLAY_FILES&#125;</span><br><span class="line">$&#123;WIDGETS_FILES&#125;</span><br><span class="line">$&#123;MODULE_FILES&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 添加一个叫unit-test的二进制</span><br><span class="line">add_executable(unit-test</span><br><span class="line">$&#123;TEST_SRCS&#125;</span><br><span class="line">$&#123;PROJECT_BINARY_DIR&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">target_include_directories(unit-test PUBLIC</span><br><span class="line">$&#123;TEST_SRCS&#125;</span><br><span class="line">$&#123;PROJECT_BINARY_DIR&#125;</span><br><span class="line">$&#123;DFrameworkDBus_INCLUDE_DIRS&#125;</span><br><span class="line">$&#123;QGSettings_INCLUDE_DIRS&#125;</span><br><span class="line">$&#123;Qt5Gui_PRIVATE_INCLUDE_DIRS&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">target_link_libraries(unit-test PRIVATE</span><br><span class="line">$&#123;Qt_LIBS&#125;</span><br><span class="line">$&#123;DFrameworkDBus_LIBRARIES&#125;</span><br><span class="line">$&#123;QGSettings_LIBRARIES&#125;</span><br><span class="line">$&#123;DtkWidget_LIBRARIES&#125;</span><br><span class="line">$&#123;XCB_EWMH_LIBRARIES&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>到这里，直接编译启动unit-test就可以使用Qt的单元测试了，但是加上CTest的支持只需要一行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add_test(ctest unit-test)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure><p>使用ctest -j6 -C Debug -T test –output-on-failure跑CTest，得到执行结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ctest]    Site: xiaomi-air</span><br><span class="line">[ctest]    Build name: Linux-c++</span><br><span class="line">[ctest] Test project &#x2F;home&#x2F;justforlxz&#x2F;Projects&#x2F;Deepin&#x2F;dde-control-center&#x2F;build</span><br><span class="line">[ctest]     Start 1: ctest</span><br><span class="line">[ctest] 1&#x2F;1 Test #1: ctest ............................   Passed    0.05 sec</span><br><span class="line">[ctest]</span><br><span class="line">[ctest] 100% tests passed, 0 tests failed out of 1</span><br><span class="line">[ctest]</span><br><span class="line">[ctest] Total Test time (real) &#x3D;   0.06 sec</span><br><span class="line">[ctest] CTest finished with return code 0</span><br></pre></td></tr></table></figure><p>如果是跑unit-test二进制，则会得到Qt打印的相关信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">********* Start testing of Tests::Tests *********</span><br><span class="line">Config: Using QtTest library 5.12.3, Qt 5.12.3 (x86_64-little_endian-lp64 shared (dynamic) release build; by GCC 8.3.0)</span><br><span class="line">PASS   : Tests::Tests::initTestCase()</span><br><span class="line">PASS   : Tests::Tests::testSliderValue(converToSlider)</span><br><span class="line">PASS   : Tests::Tests::testSliderValue(converToSlider)</span><br><span class="line">PASS   : Tests::Tests::testSliderValue(converToSlider)</span><br><span class="line">PASS   : Tests::Tests::testSliderValue(converToSlider)</span><br><span class="line">PASS   : Tests::Tests::testSliderValue(converToSlider)</span><br><span class="line">PASS   : Tests::Tests::testSliderValue(converToSlider)</span><br><span class="line">PASS   : Tests::Tests::testSliderValue(converToSlider)</span><br><span class="line">PASS   : Tests::Tests::testSliderValue(converToSlider)</span><br><span class="line">PASS   : Tests::Tests::testSliderValue(converToSlider)</span><br><span class="line">PASS   : Tests::Tests::cleanupTestCase()</span><br><span class="line">Totals: 11 passed, 0 failed, 0 skipped, 0 blacklisted, 0ms</span><br><span class="line">********* Finished testing of Tests::Tests *********</span><br></pre></td></tr></table></figure><p>对比CTest和Qt的单元测试，Qt会告诉你详细的函数调用和执行过程，CTest更注重结果，不过在Qtcreator的单元测试面板中，会看到更好的输出。</p><p>说到底，CTest支持启动了一个带有单元测试的程序，而程序自己使用了Qt提供的单元测试类进行测试。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在Deepin上使用LNMP</title>
      <link href="/2019/02/21/how-to-use-LNMP-on-deepin/"/>
      <url>/2019/02/21/how-to-use-LNMP-on-deepin/</url>
      
        <content type="html"><![CDATA[<p>为了节省读者的时间，我先简述一下阅读这篇文章需要了解的知识。</p><p>这篇文章将基于Docker来构建nginx、php和mysql来搭建LNMP环境，和其他教程有所不同的是，需要有一定的Docker基础。</p><a id="more"></a><p>Docker是一个不错的工具，使我们不需要虚拟机那样的庞然大物就可以轻松的隔离运行的程序，这要感谢Linux的资源分离机制，避免启动一个虚拟机造成了大量资源浪费。</p><p>首先需要在Deepin上安装Docker，添加Docker的deb仓库，并安装docker-ce。</p><p>创建文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nano &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;docker.list</span><br></pre></td></tr></table></figure><p>写入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb [arch&#x3D;amd64] https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;debian jessie edge</span><br></pre></td></tr></table></figure><p>刷新一下仓库就可以安装了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install docker-ce docker-compose</span><br></pre></td></tr></table></figure><p>安装完成后重启一下系统，准备工作就算完成了一半了。</p><p>在家目录创建一个Projects目录，当做我们LNMP的工作目录，创建一个名叫<em>docker-compose.yaml</em>的文件，这是docker-compose的配置文件，我们通过docker-compose这个工具来管理我们的Docker容器。</p><p>所有的镜像均采用最新版本，nginx(1.15.8)，php(7.3.2)，mysql(8.0.15)，如有需要，自行选择不同版本的镜像。</p><p>注意PHP7已经不支持mysql扩展，使用内置的MySQLnd。</p><p>写入以下配置文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &#39;3&#39;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  nginx:</span><br><span class="line">    # 设置容器名字</span><br><span class="line">    container_name: &quot;nginx&quot;</span><br><span class="line">    # 采用最新的nginx</span><br><span class="line">    image: nginx:latest</span><br><span class="line">    # 绑定80端口</span><br><span class="line">    ports:</span><br><span class="line">        - &quot;80:80&quot;</span><br><span class="line">    # 添加php容器的依赖</span><br><span class="line">    depends_on:</span><br><span class="line">        - &quot;php&quot;</span><br><span class="line">    # 绑定数据目录</span><br><span class="line">    volumes:</span><br><span class="line">        - &quot;.&#x2F;volumes&#x2F;nginx&#x2F;conf.d:&#x2F;etc&#x2F;nginx&#x2F;conf.d&quot;</span><br><span class="line">        - &quot;.&#x2F;volumes&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&quot;</span><br><span class="line">    restart: always</span><br><span class="line"></span><br><span class="line">  php:</span><br><span class="line">    # 设置容器名字</span><br><span class="line">    container_name: &quot;php&quot;</span><br><span class="line">    # 采用最新的php</span><br><span class="line">    image: php:fpm</span><br><span class="line">    # 绑定端口</span><br><span class="line">    ports:</span><br><span class="line">        - &quot;9000:9000&quot;</span><br><span class="line">    # 绑定数据目录</span><br><span class="line">    volumes:</span><br><span class="line">        - &quot;.&#x2F;volumes&#x2F;html:&#x2F;var&#x2F;www&#x2F;html&quot;</span><br><span class="line">    restart: always</span><br><span class="line"></span><br><span class="line">  mysql:</span><br><span class="line">    # 设置容器名字</span><br><span class="line">    container_name: &quot;mysql&quot;</span><br><span class="line">    # 采用最新的mysql</span><br><span class="line">    image: mysql:latest</span><br><span class="line">    # 绑定端口</span><br><span class="line">    ports:</span><br><span class="line">        - &quot;3306:3306&quot;</span><br><span class="line">    # 设置环境变量</span><br><span class="line">    environment:</span><br><span class="line">        - MYSQL_ROOT_PASSWORD&#x3D;(自己设置密码)</span><br><span class="line">    # 绑定数据目录</span><br><span class="line">    volumes:</span><br><span class="line">        - &quot;.&#x2F;volumes&#x2F;mysql:&#x2F;var&#x2F;lib&#x2F;mysql&quot;</span><br><span class="line">    restart: always</span><br></pre></td></tr></table></figure><p>创建nginx的配置文件，编辑 <em>./volumes/nginx/conf.d/nginx.conf</em> ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">        index  index.html index.htm index.php;</span><br><span class="line">    &#125;</span><br><span class="line">    error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">    location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">    &#125;</span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        fastcgi_pass   php:9000;</span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME &#x2F;var&#x2F;www&#x2F;html&#x2F;$fastcgi_script_name;</span><br><span class="line">        include        fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建php测试文件，编辑 <em>./volumes/html/index.php</em> :</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">phpinfo();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>启动docker，第一次需要拉取一下镜像:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up --build -d</span><br></pre></td></tr></table></figure><p>等全部结束以后，就可以访问localhost看到php的信息了。</p><p>通过Docker的方法来使用LNMP，不污染宿主机环境，不会再因为各种依赖问题而搞坏系统，这恰恰是新手容易犯的错误，使用Docker，方便你我。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> LNMP </tag>
            
            <tag> Deepin </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决用了xposed后淘宝闪退</title>
      <link href="/2019/01/23/fuck-taobao/"/>
      <url>/2019/01/23/fuck-taobao/</url>
      
        <content type="html"><![CDATA[<p>反正都用xposed了，肯定也有root权限。<br>删除/data/data/com.taobao.taobao/files/bundleBaseline/里的文件，然后设置该目录为500。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用swapfile来休眠</title>
      <link href="/2018/12/12/hibernate-for-swapfile/"/>
      <url>/2018/12/12/hibernate-for-swapfile/</url>
      
        <content type="html"><![CDATA[<p>最近deepin要添加休眠功能，但是之前测试的通过swapfile来休眠失败了，所以对正在使用swap分区的用户提供休眠功能。但是昨天我在askubuntu上看到有人发了在ubuntu下通过swapfile休眠的方案，今天试了一下，效果良好，觉得可以考虑给deepin也加上这样的功能。</p><a id="more"></a><p>原文链接: <a href="https://askubuntu.com/questions/6769/hibernate-and-resume-from-a-swap-file" target="_blank" rel="noopener">Hibernate and resume from a swap file</a></p><p>具体步骤是通过uswsusp这个包来做的，uswsusp是一组用户空间工具，用于Linux系统上的休眠(挂起到磁盘)和挂起(挂起到RAM或待机)。详细内容可以在ArchWiki上参考。<a href="https://wiki.archlinux.org/index.php/Uswsusp" target="_blank" rel="noopener">点这里</a></p><p>先创建一个和内存同等大小的swapfile，为了确保休眠成功，不能小于内存的容量。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo fallocate -l 16g &#x2F;swapfile # 我的机子是16G，具体自己修改</span><br><span class="line">sudo chmod 600 &#x2F;swapfile</span><br><span class="line">sudo mkswap &#x2F;swapfile</span><br><span class="line">sudo swapon &#x2F;swapfile</span><br><span class="line">echo &#39;&#x2F;swapfile swap swap defaults 0 0&#39; | sudo tee -a &#x2F;etc&#x2F;fstab</span><br></pre></td></tr></table></figure><p>安装用户空间软休眠(Userspace Software Suspend)包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install uswsusp</span><br></pre></td></tr></table></figure><p>创建需要的配置文件，只需要创建文件即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo touch &#x2F;etc&#x2F;uswsusp.conf</span><br><span class="line">sudo dpkg-reconfigure -pmedium uswsusp</span><br></pre></td></tr></table></figure><p>这时候终端会提醒是否继续，选择Yes，然后会要求你创建一个密码，设置一个密码继续即可。</p><p>此时就可以测试一下功能了，不过我是跳过这个步骤了(比较喜欢作死)。</p><p>修改systemd的hibernate服务，使用uswsusp来代替systemd的功能。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl edit systemd-hibernate.service</span><br></pre></td></tr></table></figure><p>写入以下内容:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">ExecStart&#x3D;</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;sbin&#x2F;s2disk</span><br><span class="line">ExecStartPost&#x3D;&#x2F;bin&#x2F;run-parts -a post &#x2F;lib&#x2F;systemd&#x2F;system-sleep</span><br></pre></td></tr></table></figure><p>这时候可以使用systemd的命令来测试的，我表示工作的非常正常。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl hibernate</span><br></pre></td></tr></table></figure><p>执行以后可以看到屏幕上会打印当前保存的进度，然后设备就关机了，此时再开机，等待一会儿以后就看到了背景是我漂亮老婆的锁屏，解锁以后看到工作区还是执行命令前的，一切ok。</p><p>参考以下内容:</p><blockquote><p><a href="https://askubuntu.com/questions/6769/hibernate-and-resume-from-a-swap-file" target="_blank" rel="noopener">https://askubuntu.com/questions/6769/hibernate-and-resume-from-a-swap-file</a></p></blockquote><blockquote><p><a href="https://wiki.archlinux.org/index.php/Uswsusp" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Uswsusp</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++快速排序</title>
      <link href="/2018/11/11/quick-sort-for-cpp/"/>
      <url>/2018/11/11/quick-sort-for-cpp/</url>
      
        <content type="html"><![CDATA[<p>快速排序是基于分治思想的排序算法，通过这种策略把列表分为两个子列，重复该过程。是由东尼·霍尔提出，在平均状况下，排序N个数据要O(nlogn)次比较，在最坏情况下则需要O(n^2)，但退化成冒泡的情况比较少见，快速排序比其他排序算法通常情况是最佳的，因为内部使用的循环在很多平台都有优化。</p><a id="more"></a><p>快速排序的步骤很简单：</p><ul><li>选择一个基准</li><li>遍历列表，将小于基准的放在列表左边，大于基准的放在列表右边</li><li>递归这个操作</li></ul><p>在维基百科上的这张图可以很直观的展示快速排序的过程。</p><img src="/2018/11/11/quick-sort-for-cpp/Sorting-quicksort-anim.gif" class="" title="quicksort"><p>代码实现:</p><p>首先需要一个返回基准的函数，该函数负责从指定的范围中挑选一个位置作为基准，并对范围内列表进行排序，并返回基准所在的位置。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Division</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> base = a[left]; <span class="comment">// 取第一个数为基准</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &gt; base) &#123;</span><br><span class="line">            <span class="comment">// 从右向左找第一个比基准小的元素</span></span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">        a[left] = a[right]; <span class="comment">// 交换位置，把小元素放在左侧</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt; base) &#123;</span><br><span class="line">            <span class="comment">// 从左向右找第一个比基准大的元素</span></span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        a[right] = a[left]; <span class="comment">// 交换位置，把大元素放在右侧</span></span><br><span class="line">    &#125;</span><br><span class="line">    a[left] = base;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Division函数只做了最简单的事，找一个基准，并交换左右的元素，使列表左侧均小于基准元素，使右侧均大于基准元素，接下来需要一个函数，使列表趋向最小，直至列表元素剩一(这里我感觉其实有点极限的思想)。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void quick_sort(int a[], int left, int right) &#123;</span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">        int index &#x3D; Division(a, left, right); &#x2F;&#x2F;对列表进行分割</span><br><span class="line">        quick_sort(a, left, i -1); &#x2F;&#x2F;对左侧进行排序</span><br><span class="line">        quick_sort(a, i + 1, right); &#x2F;&#x2F;对右侧进行排序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配合上方的gif，就可以很清楚的了解快速排序是如何使用分治法来排序的，通过将大任务拆分成小任务，最终达成完整的排序.</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Program </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Google日历安排工作任务</title>
      <link href="/2018/11/09/use-google-calendar-to-finishe-work/"/>
      <url>/2018/11/09/use-google-calendar-to-finishe-work/</url>
      
        <content type="html"><![CDATA[<p>目前我们正在尝试把工作的分配和讨论放在github上进行，这样可以使我们的用户和开发者更容易接触到我们，可以提bug和对需求进行讨。</p><p>但是使用起来还是有些不便，比如使用tower进行任务分配的时候，可以方便的移动一个任务到某个分类，或者指派一个时间。但是github上是基于issue的，并不是为了做这种事来设计的，所以需求上有一些出入。但是<a href="https://github.com/hualet" target="_blank" rel="noopener">@hualet</a>大佬根据github的api写了一个bot来做一点微小的事，当一个issue的assignees只剩QA的同事时，issue会被bot移动到测试栏中，只剩一个开发同事时(基本上是负责该任务的开发者)，会被移动到开发栏中。</p><p>但是因为不能做到比如今天、明天、下周等时间的显示，所以任务只能通过每天开会来口头告知时间，但是这并不妨碍我进行自己的任务时间安排。请出世界第一的神器(日历)。</p><a id="more"></a><p>我选择使用谷歌日历，<del>才不是因为它有网页还有安卓客户端【哼</del></p><p>谷歌日历上支持新建三种类型，分别是活动、提醒和任务。活动是开始时间明确，但是结束时间未知的类型，适合用作对时间不严格的情况。提醒则是在活动的基础上添加了提供功能，在活动即将开始时发送通知提醒。任务则是熟悉的ToDoList，适合用来分配今天一定要做，但是时间未知的事。</p><p>我添加了每天的开会提醒，再开完会以后，我会把身上的新任务创建成task，然后再添加大概的活动来确定一下要完成的task。把今天没有时间做的task移动到明天，留在当天的task尽量要当天完成，可以得到今天的任务列表和延期列表，让我对要做的事有完整的控制。</p><p>谷歌日历的日视图和周视图会显示一条线，告诉你现在的时间，应该进行什么活动了。</p><img src="/2018/11/09/use-google-calendar-to-finishe-work/activity.png" class="" title="activity"><img src="/2018/11/09/use-google-calendar-to-finishe-work/task.png" class="" title="task"><img src="/2018/11/09/use-google-calendar-to-finishe-work/week.png" class="" title="week"><p>在手机上需要使用两个app，Google calendar和Google task，活动和提醒需要calendar，task则需要单独使用一个app，只有网页上才是整合的。</p><img src="/2018/11/09/use-google-calendar-to-finishe-work/android-calendar.png" class="" title="android-calendar"><img src="/2018/11/09/use-google-calendar-to-finishe-work/android-task.png" class="" title="android-task"><img src="/2018/11/09/use-google-calendar-to-finishe-work/day.png" class="" title="day"><p>因为我也是才开始用日历来分配任务的时间，所以记录的内容并不多，我也在摸索如何使用这些功能，但是我觉得使用日历来记录和管理时间是非常不错的一件事，我可以通过看某天的活动来回忆当天所做的事，也可以根据记录的内容来分析自己在某些任务上使用了多少的时间。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>把博客转移到coding</title>
      <link href="/2018/11/09/hexo%20page%20move%20to%20coding/"/>
      <url>/2018/11/09/hexo%20page%20move%20to%20coding/</url>
      
        <content type="html"><![CDATA[<p>上周末折腾黑果子的时候，不小心被果子坑爹的磁盘管理坑了，整个home被直接改成HFS+了，本来是打算分配一个空闲分区出来的，当我新建分区以后，从空间分区开始到home，分区全部都变成HFS+了，但是… 空闲分区新建失败，提示我磁盘空间不足，我就重启进deepin打算直接新建一个算了，然后就GG几率了。在windows下看到home已经成果子的文件系统了，然后我用arch的安装盘看了一下，已经无法重新挂载了(成功GG)，然后数据就都没了。</p><p>还好我的数据在公司还有一份，私钥也都在，经过一星期的努力复制，大部分数据都恢复了，不过topbar的新功能代码是彻底没了，周五晚上太自信了，没有提交到gayhub上(猛叹气)。</p><p>我们现在正在尝试把日常工作转向github的project和看板，每天早上开一下晨会，简单分配一下任务，开完会以后我会把自己的任务写在谷歌日历和task上，然后安排一下任务的先后顺序，我准备把自己的一些做法写到博客上，但是home已经不在了，所以我要先恢复我的博客，刚好国内有人说我博客访问的很慢，我打算国内解析到coding，国外解析到github。</p><a id="more"></a><p>首先，创建新的博客目录，用来拉取旧的数据。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir blog &amp;&amp; cd blog</span><br></pre></td></tr></table></figure><p>初始化git目录。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>添加远程仓库。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin 你的博客git地址</span><br></pre></td></tr></table></figure><p>取回origin的backup分支，和本地master合并。因为hexo-git-backup插件只支持master，但是coding只支持master部署page服务，所以需要使用其他分支。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull origin backup:master</span><br></pre></td></tr></table></figure><p>拉取了代码以后，我们需要做点其他设置，首先设置上游分支。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream-to&#x3D;origin&#x2F;backup master</span><br></pre></td></tr></table></figure><p>设置git的默认push策略，可以参考<a href="http://thekaiway.com/2013/07/30/config-your-git-push-strategy/" target="_blank" rel="noopener">thekaiway</a>的文章。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config push.default upstream</span><br></pre></td></tr></table></figure><p>然后添加coding的git地址。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add coding 你的git地址</span><br></pre></td></tr></table></figure><p>之后就正常使用了，通过npm安装hexo，再安装需要的插件，最后完成了在一台新电脑上恢复hexo博客。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>智能指针</title>
      <link href="/2018/08/29/cpp-smart-pointer/"/>
      <url>/2018/08/29/cpp-smart-pointer/</url>
      
        <content type="html"><![CDATA[<p>其实一直都对智能指针的应用场景不清楚，项目中也很少用到，今天在 <a href="https://zccrs.com/" target="_blank" rel="noopener">@zccrs</a> 大佬的帮助下，大概理解了智能指针的作用和应用场景。</p><a id="more"></a><h1 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h1><p>智能指针依赖一种叫引用计数的手段来协助管理对象指针，通过引用计数为0时删除对象指针来完成内存的释放，本质上是通过栈对象来管理堆对象的一种方法。</p><h2 id="传统做法"><a href="#传统做法" class="headerlink" title="传统做法"></a>传统做法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test() &#123;</span><br><span class="line">    Test* t &#x3D; new Test;</span><br><span class="line">    ...</span><br><span class="line">    if (...) &#123;</span><br><span class="line">        throw exception();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当出现异常时，delete将不会被执行到，t也就泄露了。虽然我们可以在异常那里把delete给加上，但是在较为大型的项目中，如果对代码进行review来排查这种错误，将会是非常麻烦的一件事，所以为了避免内存泄漏，发明了基于引用技术的智能指针。</p><h2 id="智能指针做法"><a href="#智能指针做法" class="headerlink" title="智能指针做法"></a>智能指针做法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test() &#123;</span><br><span class="line">    std::unique_ptr&lt;Test&gt; t(new Test);</span><br><span class="line">    ...</span><br><span class="line">    if (...) &#123;</span><br><span class="line">        throw exception();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不关心std::unique_ptr是什么，这段代码无意是糟糕的，new出来的Test对象根本没有地方被删除，内存泄露了。</p><p>但是不必担心，指针已经由std::unique_ptr来管理了，根本不会发生内存泄漏，对象将在离开函数作用域以后被删除。</p><p>这就是智能指针的方便之处。</p><h1 id="智能指针的基本实现"><a href="#智能指针的基本实现" class="headerlink" title="智能指针的基本实现"></a>智能指针的基本实现</h1><p>智能指针都通过模板编程来实现，模板是C++的另一大功能，可以使我们更关心实现而不需要关心具体的对象，通过更加抽象的方式来编写程序。</p><p>智能指针有两层，里层用来保存对象的指针和引用计数，外层用来调用里层来控制引用计数。</p><p>里层的辅助类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class P_ptr &#123;</span><br><span class="line">    private:</span><br><span class="line">        friend class Pointer&lt;T&gt;;</span><br><span class="line">        P_ptr(T t)</span><br><span class="line">        : pointer(t)</span><br><span class="line">        , count(1)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uint count;</span><br><span class="line">        T pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外层的控制类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Pointer &#123;</span><br><span class="line">    public:</span><br><span class="line">        Pointer(T t)</span><br><span class="line">        : m_ptr(new P_ptr(t))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pointer(const Pointer &amp;pointer)</span><br><span class="line">        : m_ptr(pointer.m_ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            ++m_ptr-&gt;count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pointer&amp; operator&#x3D;(const Pointer &amp;pointer) &#123;</span><br><span class="line">            ++pointer-&gt;count;</span><br><span class="line">            if (--m_ptr-&gt;count &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 应对自赋值</span><br><span class="line">                delete m_ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            m_ptr &#x3D; pointer-&gt;m_ptr;</span><br><span class="line">            return *this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~Pointer() &#123;</span><br><span class="line">            if (--m_ptr-&gt;count &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                delete m_ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    private:</span><br><span class="line">        P_ptr m_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过重写控制类的拷贝构造函数和赋值运算符重载来更新引用计数。</p><p>使用实例</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test() &#123;</span><br><span class="line">    Pointer&lt;Test&gt; t(new Test); &#x2F;&#x2F; 引用计数目前是1</span><br><span class="line">    Pointer&lt;Test&gt; t1 &#x3D; t; &#x2F;&#x2F; t的引用计数是2，t1的引用计数也是2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 离开作用域，t被删除，引用计数是1. t1被删除，引用计数为0，Test被删除，内存没有泄露。</span><br></pre></td></tr></table></figure><p>这样我们就有一个简单的智能指针了，不过他还存在一些问题，比如循环引用导致内存泄漏，没有-&gt;和*的操作运算符等。所以我们需要更强大的智能指针来帮助我们。</p><h1 id="几种智能指针的介绍"><a href="#几种智能指针的介绍" class="headerlink" title="几种智能指针的介绍"></a>几种智能指针的介绍</h1><p>标准库提供了几个针对不同方面使用的智能指针，以满足我们的需求。</p><ul><li>unique_ptr<blockquote><p>只允许一个所有者，除非确信你需要共享该指针，则应该使用<code>shared_ptr</code>。可以转移到新的所有者，但是不会复制和共享。</p></blockquote></li><li>shared_ptr<blockquote><p>采用引用计数的智能指针，如果你想将一个原始指针分配给多个所有者，请使用该智能指针，直到<code>shared_ptr</code>所有者超出了范围或放弃所有权，才会删除原始指针，大小为两个指针，一个用于对象，一个用于引用计数。</p></blockquote></li><li>weak_ptr<blockquote><p>结合<code>shared_ptr</code>使用的特殊智能指针，提供一个或多个<code>shared_ptr</code>实例所拥有的对象的访问，但是不会增加引用计数。如果你想观察某个对象，但是不需要保持活动状态，则可以使用该智能指针。在某些情况下，需要断开<code>shared_ptr</code>实例间的循环引用。</p></blockquote></li></ul><h1 id="如何正确的选择智能指针"><a href="#如何正确的选择智能指针" class="headerlink" title="如何正确的选择智能指针"></a>如何正确的选择智能指针</h1><p>智能指针只需要区分需不需要共享使用，如果外部需要使用这个对象，使用<code>shared_ptr</code>，否则就使用unique_ptr进行独占使用。</p><h1 id="陷阱和坑"><a href="#陷阱和坑" class="headerlink" title="陷阱和坑"></a>陷阱和坑</h1><ul><li>不要使用相同的内置指针来初始化多个智能指针</li><li>不要主动回收智能指针内原始指针的内存</li><li>不要使用智能指针的get来初始化或者reset另一个智能指针</li><li>智能指针管理的资源只会默认删除new分配的内存，如果不是new分配的，则需要使用删除器</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卷积神经网络简述</title>
      <link href="/2018/07/14/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E8%BF%B0/"/>
      <url>/2018/07/14/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>前言： 我太菜了… 本来想着写个小例子，结果写到一半发现自己其实根本不会，我还是撸C++去吧。</p><p>卷积神经网络(Convolutional Neural Network)是一种前馈神经网络。它的人工神经元可以响应一部分覆盖范围内的周围单元，对于大型图像处理有出色的表现。</p><p>卷积神经网络由一个或多个卷积层和顶端的全连通层组成，同时也包含关联权重和池化层。这一结构可以使得卷积神经网络能够利用输入数据的二维结构。与其他深度学习结构相比，卷积神经网络在图像和声音上能够给出更好的结果，这一模型也可以用反向传播算法进行训练。相比较于其他神经网络、前馈神经网络，卷积神经网络需要考虑的参数更少，使之成为一种颇具吸引力的深度学习结构。</p><a id="more"></a><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><p>卷积神经网络中每层卷积层由若干卷积单元构成。每个卷积单元的参数都可以由反向传播算法来调整。卷积运算的目的是提取输入的不同特征，第一层卷积可能只提取非常小的特征，更多层的网络只能从低级特征中提取更复杂的特征。</p><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>运行时激活神经网络中某一部分神经元，将激活信息向后传入下一层神经网络。神经网络之所以能解决非线性问题，如语音和图像，本质上就是激活函数加入了非线性的因素，弥补了线性模型的表达力，把“激活的神经元的特征”通过函数保留并映射到下一层。</p><p>因为神经网络的数学基础是处处可微，所以选取的激活函数要能保证数据输入与输出也是可微的，介绍四种函数：</p><ul><li>sigmoid</li></ul><img src="/2018/07/14/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E8%BF%B0/sigmoid.svg" class="" title="sigmoid"><img src="/2018/07/14/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E8%BF%B0/sigmoid.png" class="" title="sigmoid"><p>sigmoid函数是传统神经网络中最常用的激活函数之一，它的优点在于，它的输出映射在(0, 1)内，单调连续，非常适合作为输出层，并且求导比较容易，缺点也比较明显，因为软饱和性，一旦落入饱和区，f’(x)就会变得接近0，很容易产生阶梯消失。</p><ul><li>tanh</li></ul><img src="/2018/07/14/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E8%BF%B0/tanh.jpg" class=""><img src="/2018/07/14/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E8%BF%B0/TanhReal.gif" class=""><p>tanh函数也具有软饱和性，因为它的输出以0为中心，收敛速度比sigmoid要快，但是仍然无法解决梯度消失问题。</p><ul><li>relu</li></ul><img src="/2018/07/14/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E8%BF%B0/relu.svg" class=""><img src="/2018/07/14/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E8%BF%B0/relu.png" class=""><p>relu是目前最受欢迎的激活函数，softplus可以看做是relu的平滑版本。使用线性整流（Rectified Linear Units, ReLU）f(x)=max(0,x)作为这一层神经的激励函数（Activation function）。它可以增强判定函数和整个神经网络的非线性特性，而本身并不会改变卷积层。</p><ul><li>dropout</li></ul><p>一个神经元将以概率决定是否要被抑制，被抑制的神经元会被暂时认为不属于网络，但是它的权重将会被保留。</p><h3 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h3><p>池化是卷积神经网络中另外一个非常重要的概念。它实际上是形式的降采样。有多种不同形式的非线性池化函数，而其中“最大池化”是最为常见的。它是将输入的图像划分为若干个矩形区域，对每个子区域输出最大值。直觉上，这种机制能够有效地原因在于，在发现一个特征之后，它的精确位置远不及它和其他特征的相对位置的关系重要。池化层会不断地减小数据的空间大小，因此参数的数量和计算量也会下降，这在一定程度上也控制了过拟合。通常来说，CNN的卷积层之间都会周期性地插入池化层。</p><p>池化层通常会分别作用于每个输入的特征并减小其大小。目前最常用形式的池化层是每隔2个元素从图像划分出2x2的区块，然后对每个区块中的4个数取最大值。这将会减少75%的数据量。</p><p>除了最大池化之外，池化层也可以使用其他池化函数，例如“平均池化”甚至“L2-范数池化”等。过去，平均池化的使用曾经较为广泛，但是最近由于最大池化在实践中的表现更好，平均池化已经不太常用。</p><p>由于池化层过快地减少了数据的大小，目前文献中的趋势是使用较小的池化滤镜，甚至不再使用池化层。</p><h3 id="损失函数层"><a href="#损失函数层" class="headerlink" title="损失函数层"></a>损失函数层</h3><p>损失函数层用于决定训练过程如何来“惩罚”网络的预测结果和真实结果之间的差异，它通常是网络的最后一层。各种不同的损失函数适用于不同类型的任务。例如，Softmax交叉熵损失函数常常被用于在K个类别中选出一个，而Sigmoid交叉熵损失函数常常用于多个独立的二分类问题。欧几里德损失函数常常用于结果取值范围为任意实数的问题。</p>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习笔记</title>
      <link href="/2018/07/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/07/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>机器学习，顾名思义当然是用机器来学习。本文完。</p><a id="more"></a><p>上面的话是开玩笑，各位客官不要走…</p><h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a><strong>人工智能</strong></h2><p>人工智能其实不算新名词，在人类历史的长河中，就有过很多关于技艺高超的工匠制造人造人，并赋予智慧。现代的人工智能则始于古典哲学家用机械符号的观点来解释人类思考过程的尝试。</p><p>20世纪50年代，人类信心满满的开始了人工智能的征途，但是这趟旅程并不平坦，1973年美英两国政府停止了没有明确目标的人工智能项目的研究。七年后又受到日本政府研究规划的刺激，又恢复了拨款，但是在80年代末再次停止了拨款。人工智能的研究就这样在跌宕起伏中不断的前进。</p><p>时光荏苒，人类进入了21世纪，这次人工智能领域终于迎来了新的人生，计算机已经得到了充足的发展，计算能力与日俱增，曾经因为计算能力不足导致无法研究的项目和算法也可以得到重新的验证，当然除了计算能力提升带来的提升，更多的是幕后的工作者不断的改进和完善各种算法，对不同的课题进行长期深度的研究。</p><p>人工智能再次进入大众视野是2016年，来自Google公司的AlphaGo成功击败了韩国选手李世石，成为第一个在围棋上战胜人类的人工智能，立下了里程碑。在AlphaGo进行比赛前，人类还自信的认为机器无法在围棋赢得胜利(<del>人类疯狂的奶自己…</del>)。</p><p>AlphaGo采用了蒙特卡洛树搜索和两个深度神经网络结合的办法，蒙特卡洛树搜索是基于某种决策过程的启发式搜索算法，两个深度神经网络一个以估值网络来评估大量的选点，一个则以走棋网络来选择落子，在这种设计下，系统可以结合树搜索来长远推断，就像人脑一样评估落点，提高下棋能力。</p><h2 id="人工智能、机器学习和深度学习的区别"><a href="#人工智能、机器学习和深度学习的区别" class="headerlink" title="人工智能、机器学习和深度学习的区别"></a><strong>人工智能、机器学习和深度学习的区别</strong></h2><p>我也对这三个名词产生过疑问，其实很简单：</p><ul><li>人工智能： 人工实现的智能</li><li>机器学习： 一种人工智能的实现方法</li><li>深度学习： 一种机器学习的实现方法</li></ul><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>机器学习是人工智能的一个分支，人工智能的研究历史中有一条以“推理”为重点，到以“知识”为重点，再到以“学习”为重点的自然、清晰的脉络。显然机器学习是是实现人工智能的一条途径，即以机器学习为手段解决人工智能中的问题。</p><p>机器学习在近30多年已发展为一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、计算复杂性理论等多门学科。机器学习理论主要是设计和分析一些让计算机可以自动“学习”的算法。机器学习算法是一类从数据中自动分析获得规律，并利用规律对未知数据进行预测的算法。因为学习算法中涉及了大量的统计学理论，机器学习与推断统计学联系尤为密切，也被称为统计学习理论。算法设计方面，机器学习理论关注可以实现的，行之有效的学习算法。很多推论问题属于无程序可循难度，所以部分的机器学习研究是开发容易处理的近似算法。</p><h3 id="机器学习的应用"><a href="#机器学习的应用" class="headerlink" title="机器学习的应用"></a>机器学习的应用</h3><p>机器学习已广泛应用于数据挖掘、计算机视觉、自然语言处理、生物特征识别、搜索引擎、医学诊断、检测信用卡欺诈、证券市场分析、DNA序列测序、语音和手写识别、战略游戏和机器人等领域。</p><h3 id="机器学习的定义"><a href="#机器学习的定义" class="headerlink" title="机器学习的定义"></a>机器学习的定义</h3><p>机器学习有下面几种定义：</p><ul><li>机器学习是一门人工智能的科学，该领域的主要研究对象是人工智能，特别是如何在经验学习- 中改善具体算法的性能。</li><li>机器学习是对能通过经验自动改进的计算机算法的研究。</li><li>机器学习是用数据或以往的经验，以此优化计算机程序的性能标准。</li></ul><h3 id="机器学习的分类"><a href="#机器学习的分类" class="headerlink" title="机器学习的分类"></a>机器学习的分类</h3><p>机器学习可以大概分为以下几类：</p><ul><li>监督学习：从给定的训练数据集中学习出一个函数，当新的数据到来时，可以根据这个函数预测结果。监督学习的训练集要求是包括输入和输出，也可以说是特征和目标。训练集中的目标是由人标注的。常见的监督学习算法包括回归分析和统计分类。</li><li>半监督学习： 介于监督学习与无监督学习之间。</li><li>无监督学习： 与监督学习相比，训练集没有人为标注的结果。常见的无监督学习算法有生成对抗网络（GAN）、聚类。</li><li>强化学习： 通过观察来学习做成如何的动作。每个动作都会对环境有所影响，学习对象根据观察到的周围环境的反馈来做出判断。</li></ul><p>监督学习和无监督学习的差别在于训练数据是否人为标记，他们都有训练集，都有输入输出。</p><h3 id="机器学习的算法"><a href="#机器学习的算法" class="headerlink" title="机器学习的算法"></a>机器学习的算法</h3><p>具体的机器学习算法有：</p><ul><li>构造间隔理论分布：聚类分析和模式识别<ul><li>人工神经网络</li><li>决策树</li><li>感知器</li><li>支持向量机</li><li>集成学习AdaBoost</li><li>降维与度量学习</li><li>聚类</li><li>贝叶斯分类器</li></ul></li><li>构造条件概率：回归分析和统计分类<ul><li>高斯过程回归</li><li>线性判别分析</li><li>最近邻居法</li><li>径向基函数核</li></ul></li><li>通过再生模型构造概率密度函数：<ul><li>最大期望算法</li><li>概率图模型：包括贝叶斯网和Markov随机场</li><li>Generative Topographic Mapping</li></ul></li><li>近似推断技术：<ul><li>马尔可夫链</li><li>蒙特卡罗方法</li><li>变分法</li></ul></li><li>最优化：大多数以上方法，直接或者间接使用最优化算法。</li></ul><h2 id="人工神经网络"><a href="#人工神经网络" class="headerlink" title="人工神经网络"></a>人工神经网络</h2><p>在机器学习中，目前应用最广泛的是人工神经网络(Artificial Neural Network，ANN)，简称神经网络。是一种模仿生物神经网络的结构和功能的数学模型或计算模型，用于对函数进行估计和近似。神经网络由大量的人工神经元连结进行计算。大多数情况下人工神经网络能在外界信息的基础上改变内部结构，是一种自适应系统，通俗叫具备学习能力。</p><h3 id="人工神经网络的组成"><a href="#人工神经网络的组成" class="headerlink" title="人工神经网络的组成"></a>人工神经网络的组成</h3><p>现代神经网络是一种非线性统计行数据建模工具，典型的神经网络具有以下三个部分：</p><ul><li>结构(Architecture): 指定了网络中的变量和它们的拓扑关系。例如，神经网络中的变量可以是神经元连接的权重（weights）和神经元的激励值（activities of the neurons）。</li><li>激励函数(Activity Rule): 大部分神经网络具有一个短时间尺度的动力学规则，来定义神经元如何根据其他神经元的活动来改变自己的激励值。一般激励值依赖于网络中的权重(即该网络中的参数)。</li><li>学习规则(Learning Rule): 学习规则指定了网络中的权重如何随着时间推进而调整。这一般被看做是一种长时间尺度的动力学规则。一般情况下，学习规则依赖于神经元的激励值。它也可能依赖于监督者提供的目标值和当前权重的值。例如，用于手写识别的一个神经网络，有一组输入神经元。输入神经元会被输入图像的数据所激发。在激励值被加权并通过一个函数（由网络的设计者确定）后，这些神经元的激励值被传递到其他神经元。这个过程不断重复，直到输出神经元被激发。最后，输出神经元的激励值决定了识别出来的是哪个字母。</li></ul><hr><p>在这里我推荐观看3Blue1Brown的三期视频。</p><p><a href="https://www.bilibili.com/video/av15532370" target="_blank" rel="noopener">深度学习之神经网络的结构 Part 1 ver 2.0</a></p><p><a href="https://www.bilibili.com/video/av16144388/" target="_blank" rel="noopener">深度学习之梯度下降法 Part 2 ver 0.9 beta</a></p><p><a href="https://www.bilibili.com/video/av16577449/" target="_blank" rel="noopener">深度学习之反向传播算法 上/下 Part 3 ver 0.9 beta</a></p><hr><h3 id="人工神经网络的基础"><a href="#人工神经网络的基础" class="headerlink" title="人工神经网络的基础"></a>人工神经网络的基础</h3><p>神经网络的构筑理念是受到生物（人或其他动物）神经网络功能的运作启发而产生的。人工神经网络通常是通过一个基于数学统计学类型的学习方法（Learning Method）得以优化，所以人工神经网络也是数学统计学方法的一种实际应用，通过统计学的标准数学方法我们能够得到大量的可以用函数来表达的局部结构空间，另一方面在人工智能学的人工感知领域，我们通过数学统计学的应用可以来做人工感知方面的决定问题（也就是说通过统计学的方法，人工神经网络能够类似人一样具有简单的决定能力和简单的判断能力），这种方法比起正式的逻辑学推理演算更具有优势。</p><p>和其他机器学习方法一样，神经网络已经被用于解决各种各样的问题，例如机器视觉和语音识别。这些问题都是很难被传统基于规则的编程所解决的。</p><p>对人类中枢神经系统的观察启发了人工神经网络这个概念。在人工神经网络中，简单的人工节点，称作神经元（neurons），连接在一起形成一个类似生物神经网络的网状结构。</p><p>人工神经网络目前没有一个统一的正式定义。不过，具有下列特点的统计模型可以被称作是“神经化”的：具有一组可以被调节的权重，换言之，被学习算法调节的数值参数，并且<br>可以估计输入数据的非线性函数关系<br>这些可调节的权重可以被看做神经元之间的连接强度。<br>人工神经网络与生物神经网络的相似之处在于，它可以集体地、并行地计算函数的各个部分，而不需要描述每一个单元的特定任务。神经网络这个词一般指统计学、认知心理学和人工智能领域使用的模型，而控制中央神经系统的神经网络属于理论神经科学和计算神经科学。</p><p>在神经网络的现代软件实现中，被生物学启发的那种方法已经很大程度上被抛弃了，取而代之的是基于统计学和信号处理的更加实用的方法。在一些软件系统中，神经网络或者神经网络的一部分（例如人工神经元）是大型系统中的一个部分。这些系统结合了适应性的和非适应性的元素。虽然这种系统使用的这种更加普遍的方法更适宜解决现实中的问题，但是这和传统的连接主义人工智能已经没有什么关联了。不过它们还有一些共同点：非线性、分布式、并行化，局部性计算以及适应性。从历史的角度讲，神经网络模型的应用标志着二十世纪八十年代后期从高度符号化的人工智能（以用条件规则表达知识的专家系统为代表）向低符号化的机器学习（以用动力系统的参数表达知识为代表）的转变。</p><p>神经网络在早期的进展非常缓慢，第一个问题是基本感知器无法解决异或问题，第二个问题是计算机没有足够的能力处理大型神经网络所需要的计算时间,直到计算机具备更强的计算能力前，神经网络的进展都一直很缓慢。</p><h3 id="反向传播算法的出现"><a href="#反向传播算法的出现" class="headerlink" title="反向传播算法的出现"></a>反向传播算法的出现</h3><p>后来出现了关键的的进展: 在1975年由Paul Werbos提出的反向传播算法。该算法解决了异或的问题，还能更普遍的训练多层神经网络。反向传播算法在3Blue1Brown的第二期视频中有讲解,视频中采用了通俗易懂的方式来介绍反向传播算法是如何调整神经元的。</p><p>神经网络的又一个关键进展是显卡性能的提升。大家都知道CPU偏向于控制而非计算，这就造成早期处理训练神经网络的代价非常大，使用CPU来训练神经网络的速度非常慢，而现代图形处理器有强大的并行处理能力和可编程流水线，令流处理器也可以处理非图形数据。特别是在面对单指令流多数据流（SIMD）且数据处理的运算量远大于数据调度和传输的需要时，通用图形处理器在性能上大大超越了传统的中央处理器应用程序。现在我们可以轻易的使用Nvidia的CUDA方案或者OpenCL来编写代码，并使用显卡来进行计算。</p><h3 id="多层前馈网络"><a href="#多层前馈网络" class="headerlink" title="多层前馈网络"></a>多层前馈网络</h3><p>一种常见的多层结构的前馈网络（Multilayer Feedforward Network）由三部分组成：</p><ul><li>输入层: 众多神经元接受大量非线性的信息，输入的信息被称为输入向量。</li><li>隐含层: 是输入层和输出层之间众多神经元和链接组成的各个层面。隐含层可以有一层或多层。隐含层的节点（神经元）数目不定，但数目越多神经网络的非线性越显著，从而神经网络的强健性（robustness）（控制系统在一定结构、大小等的参数摄动下，维持某些性能的特性）更显著。习惯上会选输入节点1.2至1.5倍的节点。</li><li>输出层: 在神经元链接中传输、分析、权衡，形成输出结果。输出的信息称为输出向量。</li></ul><p>这种网络一般称为感知器（对单隐藏层）或多层感知器（对多隐藏层），神经网络的类型已经演变出很多种，这种分层的结构也并不是对所有的神经网络都适用。</p><h3 id="理论性质"><a href="#理论性质" class="headerlink" title="理论性质"></a>理论性质</h3><h4 id="计算能力"><a href="#计算能力" class="headerlink" title="计算能力"></a>计算能力</h4><p>多层感知器（MLP）是一个通用的函数逼近器，由Cybenko定理证明。然而，证明不是由所要求的神经元数量或权重来推断的。Hava Siegelmann和Eduardo D. Sontag的工作证明了，一个具有有理数权重值的特定递归结构（与全精度实数权重值相对应）相当于一个具有有限数量的神经元和标准的线性关系的通用图灵机。他们进一步表明，使用无理数权重值会产生一个超图灵机。</p><p>####　容量</p><p>人工神经网络模型有一个属性，称为“容量”，这大致相当于他们模拟任何函数的能力。它与网络中可以存储的信息量有关，也与复杂性有关。</p><h4 id="收敛性"><a href="#收敛性" class="headerlink" title="收敛性"></a>收敛性</h4><p>模型并不总是收敛到唯一解，因为它取决于一些因素。首先，函数可能存在许多局部极小值，这取决于成本函数和模型。其次，在远离局部最小值时，优化方法可能无法保证收敛。第三，对大量的数据或参数，一些方法变得不切实际。在一般情况下，我们发现，理论保证的收敛不能成为实际应用的一个可靠的指南。</p><h4 id="综合统计"><a href="#综合统计" class="headerlink" title="综合统计"></a>综合统计</h4><p>在目标是创建一个普遍系统的应用程序中，过度训练的问题出现了。这出现在回旋或过度具体的系统中当网络的容量大大超过所需的自由参数。为了避免这个问题，有两个方向：第一个是使用交叉验证和类似的技术来检查过度训练的存在和选择最佳参数如最小化泛化误差。二是使用某种形式的正规化。这是一个在概率化（贝叶斯）框架里出现的概念，其中的正则化可以通过为简单模型选择一个较大的先验概率模型进行；而且在统计学习理论中，其目的是最大限度地减少了两个数量：“风险”和“结构风险”，相当于误差在训练集和由于过度拟合造成的预测误差。</p><h3 id="一个小例子"><a href="#一个小例子" class="headerlink" title="一个小例子"></a>一个小例子</h3><p>现在作为深度学习入门的是手写数字识别，3Blue1Brown的三期视频就是基于此。</p><p>通过神经网络来学习如何识别手写数字，本质上就是人类通过算法来分解图像的信息，比如数字9，它可以认为是竖线和圆的组合，输出层是9，则隐含层需要处理竖线和圆，输入层输入的是手写9的全部像素，隐含层就是神经网络的核心，它需要只要竖线和圆又是由什么组成，最后一步步的分解为一个像素，再通过反向传播算法来训练和调节隐含层中的偏置和权值，最后整个网络就可以学习到正确的识别手写数字。</p><p>深度学习就是通过人工神经网络来告诉计算机结果是如何产生的，以及如何通过结果来调整网络结构，达到预测和处理未标记的信息。</p>]]></content>
      
      
      <categories>
          
          <category> Deepin Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deepin Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C plus plus Iterator 笔记</title>
      <link href="/2018/07/09/C-plus-plus-Iterator-%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/07/09/C-plus-plus-Iterator-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>本文记录了咱对迭代器的一些理解</p><p>C++ 标准库提供了三种类型组件:</p><ul><li>容器</li><li>迭代器</li><li>算法</li></ul><p>容器是指存储某种类型的结构，容器有两种:</p><ul><li>顺序容器 (vector、list和string等，是元素的有序集合。)</li><li>关联容器 (set、map等，是包含查找元素的键值。 )</li></ul><p>遍历容器的方式之一就是迭代器，迭代器是一种泛型指针，普通指针指向一块内存，迭代器指向容器中的一个位置。STL的每个模板容器中，都定义了一组对应的迭代器类，使用迭代器和算法，就可以访问容器中特定位置的元素，而无需关心元素的类型。</p><p>每种容器都定义了一对begin和end的函数，用于返回迭代器。如果容器中有元素的话，begin返回的迭代器指向第一个元素。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">list</span>.begin();</span><br></pre></td></tr></table></figure><p>上述语句把it初始化为由list的begin返回的迭代器，如果list不为空，it将指向该元素list[0]。</p><p>由end操作返回的迭代器指向list的末端元素的下一个，通常指超出末端迭代器(off-the-end-iterator)，表明指向一个不存在的元素，如果容器为空，begin返回的迭代器将和end相同，在使用中，可以通过判断end来检查是否处理完容器种所有的元素。</p><p>迭代器类型定义了一些操作来获取迭代器所指向的元素，并允许程序员将迭代器从一个元素移动到另一个元素。</p><p>遍历列表：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = <span class="built_in">list</span>.constBegin(); it != <span class="built_in">list</span>.constEnd(); ++it) &#123;</span><br><span class="line">    <span class="comment">// 通过迭代器访问元素需要解引用。</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">std</span>::sort(<span class="built_in">list</span>.begin(), <span class="built_in">list</span>.end(), [=] (<span class="keyword">int</span> _i1, <span class="keyword">int</span> _i2) &#123;</span><br><span class="line">    <span class="keyword">return</span> _i1 &lt; _i2;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的示例代码是对一个int类型的list进行排序，</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在DeepinLinux下使用nVidia CUDA</title>
      <link href="/2018/06/28/%E5%9C%A8DeepinLinux%E4%B8%8B%E4%BD%BF%E7%94%A8nVidia-CUDA/"/>
      <url>/2018/06/28/%E5%9C%A8DeepinLinux%E4%B8%8B%E4%BD%BF%E7%94%A8nVidia-CUDA/</url>
      
        <content type="html"><![CDATA[<p>CUDA（Compute Unified Device Architecture，统一计算架构）是由NVIDIA所推出的一种集成技术，是该公司对于GPGPU的正式名称。通过这个技术，用户可利用NVIDIA的GeForce 8以后的GPU和较新的Quadro GPU进行计算。亦是首次可以利用GPU作为C-编译器的开发环境。NVIDIA营销的时候，往往将编译器与架构混合推广，造成混乱。实际上，CUDA可以兼容OpenCL或者自家的C-编译器。无论是CUDA C-语言或是OpenCL，指令最终都会被驱动程序转换成PTX代码，交由显示核心计算。</p><p>在论坛上看到有些用户希望在deepin下使用CUDA，但是他们采取的做法往往是手动下载nvidia的二进制文件，直接进行安装。</p><p>但是这样会破坏一部分的glx链接，导致卸载的时候无法彻底恢复，结果就是系统因为卸载nvidia驱动而废掉，所以我推荐使用包管理器的方式安装nvidia驱动和cuda相关的东西，尽量不要手动修改。</p><a id="more"></a><p>需要安装的很少，只有五个包，不过会依赖很多nvidia的库，总量还是有一些的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install nvidia-cuda-toolkit nvidia-profiler nvidia-visual-profiler nvidia-cuda-doc nvidia-cuda-dev</span><br></pre></td></tr></table></figure><p>nvcc是cuda的编译器，它目前只支持g++5，所以还需要安装g++5。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install g++-5</span><br></pre></td></tr></table></figure><p>然后，重启一下计算机。</p><p><a href="https://bingliu221.gitbooks.io/learn-cuda-the-simple-way/content/chapter2.html/" target="_blank" rel="noopener">这里有个小栗子，可以用来测试cuda是否能够成功编译和运行</a></p><p><strong>将以下代码保存为 main.cu</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">__global__ void vector_add(const int *a, const int *b, int *c) &#123;</span><br><span class="line">    *c &#x3D; *a + *b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    const int a &#x3D; 2, b &#x3D; 5;</span><br><span class="line">    int c &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    int *dev_a, *dev_b, *dev_c;</span><br><span class="line"></span><br><span class="line">    cudaMalloc((void **)&amp;dev_a, sizeof(int));</span><br><span class="line">    cudaMalloc((void **)&amp;dev_b, sizeof(int));</span><br><span class="line">    cudaMalloc((void **)&amp;dev_c, sizeof(int));</span><br><span class="line"></span><br><span class="line">    cudaMemcpy(dev_a, &amp;a, sizeof(int), cudaMemcpyHostToDevice);</span><br><span class="line">    cudaMemcpy(dev_b, &amp;b, sizeof(int), cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">    vector_add&lt;&lt;&lt;1, 1&gt;&gt;&gt;(dev_a, dev_b, dev_c);</span><br><span class="line"></span><br><span class="line">    cudaMemcpy(&amp;c, dev_c, sizeof(int), cudaMemcpyDeviceToHost);</span><br><span class="line"></span><br><span class="line">    printf(&quot;%d + %d &#x3D; %d, Is that right?\n&quot;, a, b, c);</span><br><span class="line"></span><br><span class="line">    cudaFree(dev_a);</span><br><span class="line">    cudaFree(dev_b);</span><br><span class="line">    cudaFree(dev_c);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvcc main.cu</span><br></pre></td></tr></table></figure><p>运行:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;a.out</span><br></pre></td></tr></table></figure><p>如果一切顺利，在编译的时候就不会有报错，不过在我的环境下nvcc会有架构被弃用的警告，本着只要不error就算没事的原则，我们无视这条警告即可。</p><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 + 5 &#x3D; 0, Is that right?</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> nVidia Cuda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>deepin待机后键盘和触摸板无法使用的解决方法</title>
      <link href="/2018/06/25/deepin%E5%BE%85%E6%9C%BA%E5%90%8E%E9%94%AE%E7%9B%98%E5%92%8C%E8%A7%A6%E6%91%B8%E6%9D%BF%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2018/06/25/deepin%E5%BE%85%E6%9C%BA%E5%90%8E%E9%94%AE%E7%9B%98%E5%92%8C%E8%A7%A6%E6%91%B8%E6%9D%BF%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>笔记本一直使用的bumblebee来省电，毕竟我也不想笔记本的电只够从一张桌子移动到另一张桌子，但是今天在调待机唤醒后dde-dock崩溃的问题，我需要切换到私有驱动下，因为笔记本使用bumblebee需要使用acpi的参数，否则会见图形就死。</p><a id="more"></a><p>一切准备就绪以后，我开始调试dde-dock，通过codedump已经知道崩溃在wifi列表为空时访问了first节点，但是当我开始测试修复的代码时，发生了很意外的事情，恢复待机以后键盘和触摸板无法使用了。</p><p>虽然之前我也偶尔会用用私有驱动，但是还没遇到过无法键盘和触摸板无法使用的情况。想到论坛好像也有人报了类似的问题，恢复待机以后无wifi和外置键盘无法使用，刚好可以趁这个机会调试一下。</p><p>/var/log/Xorg.0.log里看到了大量的synaptics错误，然后该模块被卸载，键盘则是没看到什么信息。</p><p>尝试重新modprobe synaptics模块，但是失败了，然后在/etc/modprobe.d/nvidia.conf里看到了几行配置。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># These aliases are defined in *all* nvidia modules.</span><br><span class="line"># Duplicating them here sets higher precedence and ensures the selected</span><br><span class="line"># module gets loaded instead of a random first match if more than one</span><br><span class="line"># version is installed. See #798207.</span><br><span class="line">#aliaspci:v000010DEd00000E00sv*sd*bc04sc80i00*nvidia</span><br><span class="line">#aliaspci:v000010DEd00000AA3sv*sd*bc0Bsc40i00*nvidia</span><br><span class="line">#aliaspci:v000010DEd*sv*sd*bc03sc02i00*nvidia</span><br><span class="line">#aliaspci:v000010DEd*sv*sd*bc03sc00i00*nvidia</span><br></pre></td></tr></table></figure><p>似乎是通配出错了，匹配到了键盘和触摸板，然后就无法使用了。刚好deepin 15.6升级了nvidia驱动，所以是现在才会出这个问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dreamscene插件开发&lt;等待填坑&gt;</title>
      <link href="/2018/06/05/dreamscene%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
      <url>/2018/06/05/dreamscene%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>本篇会介绍一下deepin-dreamscene的插件机制。</p><a id="more"></a>]]></content>
      
      
      
        <tags>
            
            <tag> Linux 填坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dock插件开发&lt;等待填坑&gt;</title>
      <link href="/2018/05/23/Dock%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
      <url>/2018/05/23/Dock%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>从零构建 dde-dock 的插件<br>本教程将展示一个简单的 dde-dock 插件的开发过程，插件开发者可跟随此步骤为 dde-dock 创造出更多具有丰富功能的插件。</p><a id="more"></a><p>在本教程中，将创建一个可以实时显示用户家目录(~/)使用情况的小工具。</p><p>插件的工作原理<br>dde-dock 插件本质是一个按 Qt 插件标准所开发的共享库文件(so)。通过 dde-dock 预定的规范与提供的接口，共同完成 dde-dock 的功能扩展。</p><p>准备环境<br>插件的开发环境可以是任意的，只要是符合 Qt 插件规范及 dde-dock 插件规范的共享库文件，都可以被当作 dde-dock 插件载入。下面以 Qt + qmake 为例进行说明：</p><p>安装依赖<br>以 Deepin 15.5.1 环境为基础，至少先安装如下的包：</p><ul><li>dde-dock-dev</li><li>qt5-qmake</li><li>qtbase5-dev-tools</li><li>libqt5core5a</li><li>libqt5widgets5</li><li>pkg-config</li></ul><p>基本的项目结构<br>创建必需的项目目录与文件<br>插件名称叫做home_monitor，所以创建以下的目录结构：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">home_monitor</span><br><span class="line">├── home_monitor.json</span><br><span class="line">├── homemonitorplugin.cpp</span><br><span class="line">├── homemonitorplugin.h</span><br><span class="line">└── home_monitor.pro</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux的PAM是什么</title>
      <link href="/2018/04/01/Linux%E7%9A%84PAM%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2018/04/01/Linux%E7%9A%84PAM%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>本文会基础的介绍一下PAM是什么，让你能够回答PAM是什么、PAM有什么用、如何根据需求自己开发PAM模块。</p><h3 id="PAM是什么"><a href="#PAM是什么" class="headerlink" title="PAM是什么"></a>PAM是什么</h3><p>PAM即可插拔认证模块。它提供了一个所有服务的中心验证机制，适用于普通登录、ssh登录等需要进行身份认证的系统中。</p><a id="more"></a><h3 id="为什么使用PAM"><a href="#为什么使用PAM" class="headerlink" title="为什么使用PAM"></a>为什么使用PAM</h3><p>为了安全起见，计算机只能给通过授权的用户进行使用，在创建用户时，密码会被加密保存在/etc/passwd中,在用户登录时，重新计算密码，然后在/etc/passwd中进行对比。</p><p>除了上面这种，还有其他方式的验证，比如现在经常使用的指纹认证，其核心思想都是检查内容是否匹配。但是这些方案都有一些通病，那就是需要随着应用程序一起编译来使用，如果认证系统有问题，或者更新了算法，就需要重新编译才能使用。</p><blockquote><p>鉴于以上原因，人们开始寻找一种更佳的替代方案：一方面，将鉴别功能从应用中独立出来，单独进行模块化设计，实现和维护；另一方面，为这些鉴别模块建立标准 API，以便各应用程序能方便的使用它们提供的各种功能；同时，鉴别机制对其上层用户（包括应用程序和最终用户）是透明的。</p></blockquote><h3 id="PAM是如何工作的"><a href="#PAM是如何工作的" class="headerlink" title="PAM是如何工作的"></a>PAM是如何工作的</h3><img src="/2018/04/01/Linux%E7%9A%84PAM%E6%98%AF%E4%BB%80%E4%B9%88/PAM%E7%BB%93%E6%9E%84.png" class=""><p>PAM采用了分层的模块式开发，提供了四种类型的模块:</p><ul><li>认证管理</li><li>账号管理</li><li>会话管理</li><li>口令管理</li></ul><p>这四个接口就可以满足用户的认证和管理。一个模块可以同时属于多种类型，只需实现对应的函数就可以。</p><p>目前PAM的实现有以下三种：</p><blockquote><ol><li>Linux-PAM: Linux-PAM 涵盖了本文中讨论的所有 PAM。在任何一个 Linux 平台中的 PAM 的主要结构都类似于 Linux-PAM 版本。</li><li>OpenPAM: OpenPAM 是由 NAI 实验室的 Dag-Erling Smorgrav 开发的另一个 PAM 实现，属于 DARPA-CHATS 研究项目。由于它是开源的，因此它主要由 FreeBSD、NetBSD 及应用程序（加上 Mac OS X）使用。</li><li>Java™ PAM 或 JPam: PAM 主要是支持 Linux 和 UNIX 的标准验证模块。JPam 将 Java 部分与普通 PAM 联系了起来。JPam 允许基于 Java 的应用程序使用 PAM 模块或工具（如 auth、account、passwd、session 等）。它提供了 JAAS 和直接 API，并且支持大多数 Unix OS 和架构。</li></ol></blockquote><p>虽然有不同的PAM实现，但是主要功能都是类似的，完成用户的验证。</p><p>想要了解更多，可查看IBM的文档库。<br><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-pam/index.html" target="_blank" rel="noopener">深入 Linux PAM 体系结构</a></p><h3 id="如何自己开发PAM模块"><a href="#如何自己开发PAM模块" class="headerlink" title="如何自己开发PAM模块"></a>如何自己开发PAM模块</h3><p>PAM模块使用一个pam_handle类型的结构当做句柄，也是唯一一个PAM和程序进行通信的结构。</p><p>首先在编写的服务模块的源程序里要包含下列头文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;security&#x2F;pam_modules.h&gt;</span><br></pre></td></tr></table></figure><p>PAM模块是一个个的so动态库。PAM会通过dlopen来装载这些so。四个模块分别需要实现对应的方法，PAM会根据配置文件来调用这些方法。</p><p>每个PAM模块的认证程序都以pam_start开始，以pam_end结束。PAM还提供了pam_get_item和pam_set_item共享有关认证会话的某些公共信息，例如用户名、服务名和密码。应用程序在调用了pam_start以后可以用这些APIs来改变状态信息。实际工作的函数有6个：</p><table><thead><tr><th>模块类型</th><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>认证管理</td><td>PAM_EXTERN int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv)</td><td>认证用户</td></tr><tr><td>认证管理</td><td>PAM_EXTERN int pam_sm_setcred(pam_handle_t *pamh, int flags, int argc, const char **argv)</td><td>设置用户证书</td></tr><tr><td>账号管理</td><td>PAM_EXTERN int pam_sm_acct_mgmt(pam_handle_t *pamh, int flags, int argc, const char **argv)</td><td>账号管理</td></tr><tr><td>会话管理</td><td>PAM_EXTERN int pam_sm_open_session(pam_handle_t *pamh, int flags, int argc, const char **argv)</td><td>打开会话</td></tr><tr><td>会话管理</td><td>PAM_EXTERN int pam_sm_close_session(pam_handle_t *pamh, int flags, int argc, const char **argv)</td><td>关闭会话</td></tr><tr><td>口令管理</td><td>PAM_EXTERN int pam_sm_chauthtok(pam_handle_t *pamh, int flags, int argc, const char **argv)</td><td>设置口令</td></tr></tbody></table><p>同一个模块可以同时支持不同的类型，可以一个模块全部实现这些方法，也可以实现部分。PAM自带的pam_unix.so就是支持四种类型。</p><p>在函数内进行详细的操作，最后返回结果，即可完成整个验证流程。</p><h3 id="配置PAM"><a href="#配置PAM" class="headerlink" title="配置PAM"></a>配置PAM</h3><p>PAM的配置通常在/etc/pam.d/下。</p><p>模块将按照在配置文件中列出的顺序被调用，这取决于每个条目允许的 Control_flag 的值。Control_flag 值包括：</p><blockquote><p>Required：堆栈中的所有 Required 模块必须看作一个成功的结果。如果一个或多个 Required 模块失败，则实现堆栈中的所有 Required 模块，但是将返回第一个错误。</p><p>Sufficient：如果标记为 sufficient 的模块成功并且先前没有 Required 或 sufficient 模块失败，则忽略堆栈中的所有其余模块并返回成功。</p><p>Optional：如果堆栈中没有一个模块是 required 并且没有任何一个 sufficient 模块成功，则服务/应用程序至少要有一个 optional 模块成功。</p></blockquote><h3 id="在程序中使用PAM进行验证"><a href="#在程序中使用PAM进行验证" class="headerlink" title="在程序中使用PAM进行验证"></a>在程序中使用PAM进行验证</h3><ol><li>开发PAM验证模块</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;security&#x2F;pam_appl.h&gt;</span><br><span class="line">#include &lt;security&#x2F;pam_modules.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 只实现账户认证</span><br><span class="line">PAM_EXTERN int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc,</span><br><span class="line">                                   const char **argv) &#123;</span><br><span class="line">  char *username;</span><br><span class="line">  char password[256];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;得到用户名</span><br><span class="line">  pam_get_user(pamh, &amp;username, &quot;Username: &quot;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 得到密码</span><br><span class="line">  printf(&quot;Password: &quot;);</span><br><span class="line">  gets(password);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 测试判断，如果用户名和密码不相等，就认证失败</span><br><span class="line">  if (strcmp(username, password) !&#x3D; 0) &#123;</span><br><span class="line">    return PAM_AUTH_ERR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printf(&quot;Password is: %s\n&quot;, password);</span><br><span class="line">  return PAM_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -fPIC -fno-stack-protector -c pam_test_mod.c</span><br><span class="line">sudo ld -x --shared -o &#x2F;lib&#x2F;security&#x2F;pam_test_mod.so pam_test_mod.o</span><br></pre></td></tr></table></figure><p>还需要修改pam的配置，来加载这个so。编辑/etc/pam.d/common-auth</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auth [success&#x3D;1 default&#x3D;ignore] pam_test_mod.so</span><br></pre></td></tr></table></figure><p>这里的success的值需要根据实际情况来调整，必须是所有里面的最大值。</p><ol start="2"><li>使用模块进行验证</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; PAM必须的两个头文件</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;security&#x2F;pam_appl.h&gt;</span><br><span class="line">#include &lt;security&#x2F;pam_misc.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">extern int misc_conv(int num_msg, const struct pam_message **msgm,</span><br><span class="line">                     struct pam_response **response, void *appdata_ptr) &#123;</span><br><span class="line"></span><br><span class="line">  return PAM_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const struct pam_conv conv &#x3D; &#123;misc_conv, NULL&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">  &#x2F;&#x2F; 初始化</span><br><span class="line">  pam_handle_t *pamh &#x3D; NULL;</span><br><span class="line">  int retval;</span><br><span class="line">  const char *username &#x3D; argv[1];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 初始化PAM 设置common-auth为验证配置</span><br><span class="line">  if ((pam_start(&quot;common-auth&quot;, username, &amp;conv, &amp;pamh)) !&#x3D; PAM_SUCCESS) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; &#x2F;&#x2F;认证用户</span><br><span class="line">  retval &#x3D; pam_authenticate(pamh, 0);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; (retval &#x3D;&#x3D; PAM_SUCCESS ? &quot;SUCCESS\n&quot; : &quot;Failed\n&quot;) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; &#x2F;&#x2F; 结束PAM</span><br><span class="line">  if (pam_end(pamh, retval) !&#x3D; PAM_SUCCESS) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;check_user: failed to release authenticator\n&quot; &lt;&lt; endl;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return retval &#x3D;&#x3D; PAM_SUCCESS ? 0 : 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译测试一下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ -o pam_test pam_test.cc -lpam -lpam_misc</span><br><span class="line">sudo .&#x2F;pam_test $USER</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;pam_test test       </span><br><span class="line">Password: test</span><br><span class="line">Password is: test</span><br><span class="line">SUCCESS</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>基于PAM认证体系，我们可以根据自己的需求任意的扩展linux账户，linux下的pbis-open，就是基于PAM扩展出来的一个AD域登录模块，它提供了一个pam_lsass.so的文件，来进行账户的验证。我们也可以自己设计一套认证流程，只需要满足上面的接口要求就可以。</p><blockquote><p>提供机制，而非策略</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重构dde-session-ui</title>
      <link href="/2018/03/11/%E9%87%8D%E6%9E%84dde-session-ui/"/>
      <url>/2018/03/11/%E9%87%8D%E6%9E%84dde-session-ui/</url>
      
        <content type="html"><![CDATA[<p>dde-session-ui里面包含了很多项目，是一个集合，但是其中的代码缺少合理的维护，以至于已经到了必须重构才能继续开发和维护，在支持AD域登录的时候，如果强制加上功能，代码会变得更加糟糕，所以和石博文一块重构了其中非常重要的UserWidget。</p><a id="more"></a><h2 id="重构前的设计"><a href="#重构前的设计" class="headerlink" title="重构前的设计"></a>重构前的设计</h2><p>重构前的dde-lock和lightdm-deepin-greeter是非常混乱的，处理逻辑都混杂在一块，虽然能看出有基本的结构，但是整体并未解耦。</p><h2 id="重构后的设计"><a href="#重构后的设计" class="headerlink" title="重构后的设计"></a>重构后的设计</h2><ul><li>基于User类的处理</li><li>UserWidget负责提供对用户的处理，暴露出基本的currentUser和LogindUsers。</li><li>Lock和Greeter的Manager从UserWidget、SessionWidget中获取用户和用户的会话。</li><li>Manager只负责控件的位置和用户的验证。</li><li>背景修改为Manager提供模糊的壁纸，FullBackground只提供绘制。</li></ul><p>重构以后用了大概原代码的1/3，启动速度也快了，感觉世界充满了美好… 就是重构历程太辛苦…</p><p>本次也发现了很多自身的问题，基础并没有学好，很多地方都可以使用更好的处理方式【就是管不住这手…】</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用DTK开发</title>
      <link href="/2018/01/12/%E4%BD%BF%E7%94%A8DTK%E5%BC%80%E5%8F%91/"/>
      <url>/2018/01/12/%E4%BD%BF%E7%94%A8DTK%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p><strong>在阅读本篇文章之前，你需要掌握基本的Qt/C++开发知识。</strong></p><a id="more"></a><blockquote><p><strong>注意：本篇文章基于Deepin平台，其他平台请自行补充依赖关系。</strong></p></blockquote><p>先安装DTK的依赖关系。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install libdtkwidget2 libdtkcore2</span><br></pre></td></tr></table></figure><p>新建Qt项目，编辑pro文件，添加项目依赖。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONFIG +&#x3D; c++14 link_pkgconfig</span><br><span class="line">PKGCONFIG +&#x3D; dtkwidget</span><br></pre></td></tr></table></figure><p>DTK目前有两个组件，一个是提供库功能的core，一个是提供控件的widget。</p><p>修改main.cpp,删除QApplication的相关内容，改为DApplication。</p><blockquote><p>注意： 使用DTK的组件，需要使用DTK的宏,根据使用的文件来选择对应的宏。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DWIDGET_USE_NAMESPACE</span><br><span class="line">DCORE_USE_NAMESPACE</span><br></pre></td></tr></table></figure><p>DTK使用了deepin自己的qt插件，需要在DApplication前调用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DApplication::loadDXcbPlugin();</span><br><span class="line">DApplication app(argc, argv);</span><br></pre></td></tr></table></figure><p>DApplication中提供了很多方法来设置程序的各种信息，具体请看头文件的定义。</p><p>主窗口由DMainWindow提供，新建类，然后添加DMainWindow的头文件和DTKWIDGET的宏。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;DMainWindow&gt;</span><br><span class="line"></span><br><span class="line">DWIDGET_USE_NAMESPACE</span><br></pre></td></tr></table></figure><p>然后修改继承关系，改为继承DMainWindow。DMainWindow提供了一些我们封装的方法。目前为止，该程序的界面已经符合Deepin程序的风格了，我们封装了一些其他控件，使其样式符合我们的风格，如果要在其他Qt程序中使用，也是同样的步骤，载入Qt插件，添加对应的头文件和DTK的宏。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux DTK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决IntelliJ IDEA界面瞎眼</title>
      <link href="/2017/12/25/%E8%A7%A3%E5%86%B3IntelliJ-IDEA%E7%95%8C%E9%9D%A2%E7%9E%8E%E7%9C%BC/"/>
      <url>/2017/12/25/%E8%A7%A3%E5%86%B3IntelliJ-IDEA%E7%95%8C%E9%9D%A2%E7%9E%8E%E7%9C%BC/</url>
      
        <content type="html"><![CDATA[<p>今天在逛深度论坛的时候，无意间看到了有个回复，是处理IEDA字体很挫的，试了一下，效果非常棒。</p><p>我之前也试了些网上的办法，都没有解决，字体挫的根本看不了，被逼无奈跑到windows下写MOD了。</p><a id="more"></a><p><a href="https://bbs.deepin.org/forum.php?mod=redirect&goto=findpost&ptid=150634&pid=418410&fromuid=13250" target="_blank" rel="noopener">原文链接</a></p><p>在/etc/profile.d/新建一个文件，用来设置java的环境变量:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;profile.d&#x2F;z999__java_options.sh</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">opts&#x3D;&quot; -Dswing.aatext&#x3D;true  -Dawt.useSystemAAFontSettings&#x3D;lcd -Djava.net.useSystemProxies&#x3D;true &quot;</span><br><span class="line">export _JAVA_OPTIONS&#x3D;&quot;&#96;echo $&#123;_JAVA_OPTIONS&#125; |sed -Ee &#39;s&#x2F;-Dawt.useSystemAAFontSettings&#x3D;\w+&#x2F;&#x2F;ig&#39;&#96; $opts&quot;</span><br></pre></td></tr></table></figure><p>然后注销再登录，就可以看到效果了。</p><p>其实这个解决办法在arch的wiki上有，只不过似乎是我写错了吧，反正是没生效，按照这种方法是可以的，就这么用吧。非常感觉@ihipop。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修复Archlinux的Grub</title>
      <link href="/2017/12/18/%E4%BF%AE%E5%A4%8DArchlinux%E7%9A%84Grub/"/>
      <url>/2017/12/18/%E4%BF%AE%E5%A4%8DArchlinux%E7%9A%84Grub/</url>
      
        <content type="html"><![CDATA[<p>又双叒叕不知道怎么搞的，就把arch的grub给弄坏了，但是在重新安装grub的时候，提示了这么一个错误:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Could not prepare Boot variable: No space left on device</span><br></pre></td></tr></table></figure><p>诶不对啊，boot分区还有800M呢，怎么这么快没空间了，根目录也有52G呢，于是谷歌了一把，找到了解决办法.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm &#x2F;sys&#x2F;firmware&#x2F;efi&#x2F;efivars&#x2F;dump-*</span><br></pre></td></tr></table></figure><blockquote><p>新式 efivarfs (EFI VARiable FileSystem) 接口 (CONFIG_EFIVAR_FS) - 由位于 /sys/firmware/efi/efivars 的 efivarfs 内核模块挂载使用 - 老式 sysfs-efivars 接口的替代品，不限制变量数据大小，支持 UEFI Secure Boot 变量并被上游推荐使用。在3.8版的内核中引入，新的 efivarfs 模块在3.10版内核中从旧的 efivars 内核模块中分离。</p></blockquote><p>删掉dump文件，就可以正常安装了【有点迷，不应该啊。</p><p>参考资料 : <a href="https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">Unified_Extensible_Firmware_Interface</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决NVIDIA重新启动以后系统冻结</title>
      <link href="/2017/09/01/%E8%A7%A3%E5%86%B3NVIDIA%E9%87%8D%E6%96%B0%E5%90%AF%E5%8A%A8%E4%BB%A5%E5%90%8E%E7%B3%BB%E7%BB%9F%E5%86%BB%E7%BB%93/"/>
      <url>/2017/09/01/%E8%A7%A3%E5%86%B3NVIDIA%E9%87%8D%E6%96%B0%E5%90%AF%E5%8A%A8%E4%BB%A5%E5%90%8E%E7%B3%BB%E7%BB%9F%E5%86%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>分期买了一台神舟 Z6-kp5s1，配置还不错，够用三年了，但是在linux下使用bumblebee的时候，发生了问题，折腾了好久，现在把解决方法写出来。</p><a id="more"></a><p>先说一下问题吧，正常安装bumblebee、bbswitch和nvidia驱动，重新启动系统以后，系统出现冻结，没有任何的输入输出，没有任何日志产生。问题似乎是固件错误，详情查看<a href="https://github.com/Bumblebee-Project/Bumblebee/issues/764" target="_blank" rel="noopener">讨论</a>和Linux的bug<a href="https://bugzilla.kernel.org/show_bug.cgi?id=156341" target="_blank" rel="noopener">讨论</a>。</p><p>解决方法是看的<a href="https://witiko.github.io/Optimus-on-Linux/" target="_blank" rel="noopener">Witiko</a>的博客，通过给内核传递参数来防止系统出现冻结。修改/etc/default/grub,在文件底部追加以下内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Bumblebee 3.2.1 fix (see https:&#x2F;&#x2F;github.com&#x2F;Bumblebee-Project&#x2F;Bumblebee&#x2F;issues&#x2F;764)</span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT&#x3D;&quot;$GRUB_CMDLINE_LINUX_DEFAULT &quot;&#39;acpi_osi&#x3D;! acpi_osi&#x3D;&quot;Windows 2009&quot;&#39;</span><br></pre></td></tr></table></figure><p>如果不放心，请先禁用登录管理器，防止开机就出现冻结，然后尝试手动启动登录管理器。在tty登录，然后执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl start display-manager.service</span><br></pre></td></tr></table></figure><p>如果一切正常，你将会看到图形，并且lspci -v中能看到nvidia已经被禁用，然后使用提供的测试方法进行测试，可以看到nvidia被启用，关闭测试成功，nvidia被禁用。</p><p>提供一下我关闭nvidia以后的使用和续航时间吧。亮度调节为50%，cpu设置为powersave，运行了一下程序：</p><ul><li>telegram</li><li>chrome</li><li>dde-file-manager</li><li>vs code</li><li>meow</li><li>若干ss client</li><li>还有一大堆乱七八糟的服务，懒得写了</li></ul><p>从14:35开始断电测试，到17:17还有23%的电量。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的代理折腾方案</title>
      <link href="/2017/08/31/%E6%88%91%E7%9A%84%E4%BB%A3%E7%90%86%E6%8A%98%E8%85%BE%E6%96%B9%E6%A1%88/"/>
      <url>/2017/08/31/%E6%88%91%E7%9A%84%E4%BB%A3%E7%90%86%E6%8A%98%E8%85%BE%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>最近在准备做新的代理设置界面，然后想到自己也改改代理的配置，好方便的用在新的设置上。</p><a id="more"></a><p>我以前的旧方案是：</p><p>privoxy –&gt; nginx –&gt; 多个ss客户端 ==== 多个ss服务端</p><p>privoxy用来将socks转成http，nginx是用来多个ss负载均衡。</p><p>这个方案虽然有点麻烦，但是用起来还是很吼的。</p><p>但是我们改了控制中心对代理的设置，在程序前面加上了proxychains。<br>刚好可以和我的privoxy在作用上冲突了。但是其实还有一些其他问题，我是比较懒的人，跳过大陆ip和局域网对我来说是有很大帮助的，这样我就可以设置一个全局代理，而不需要给每个程序单独设置。</p><p>以前肥猫给我介绍过一些方法，当初我弄的时候，还是太图样，总是不能好好的稳定工作，所以暂时放弃了全局代理的方案。provixy其实是可以做这样的事，但是好麻烦，要自己添加很多规则，gfwlist是可以转成它支持的action，但是自己再添加的话，很麻烦。【而我是根比较懒的竹子</p><p>今天把provixy给撤下来了，换上以前用的meow，是用go写的，作用也是转成http，但是它支持的方案比较多，可以直接添加ss，也可以正向代理。当初不用它的原因是我想随机使用一个代理，当时电信和我过不去，一个端口用久了，就封我一天，害得我早上到公司了，先远程到服务器改端口，后来又觉得麻烦，直接开了5个端口，每天改本机，再后来就想随机使用了…  【还有次把我的ssh端口封了一天…</p><p>现在的话，就是变成了这个结构：</p><p>meow –&gt; nginx –&gt; 多个ss客户端 ==== 多个ss服务端</p><p>nginx还是代替meow做负载均衡，meow的工作就变成了转成http代理和黑白名单。</p><p>虽然不需要新的控制中心的代理方案，现在这套就工作的很好了，但是没有它，我就不会再折腾新的【笑哭</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发topbar中的技术问题</title>
      <link href="/2017/08/23/%E5%BC%80%E5%8F%91topbar%E4%B8%AD%E7%9A%84%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/"/>
      <url>/2017/08/23/%E5%BC%80%E5%8F%91topbar%E4%B8%AD%E7%9A%84%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>这里记录了开发topbar中遇到的坑和一些问题。</p><a id="more"></a><p>使用Qt提供的qxcb方法注册阴影为dock类型，反而处于DESKTOP和NORMAL之间。其实当初并不是想设置为DOCK类型的，因为这样阴影也会在窗口上方，我希望的是阴影在普通程序下方，在桌面上方。今天曹哥来讲窗管的一些坑，讲到窗管是如何控制窗口的，我的阴影其实是被Qt注册成_NET_WM_STATE_BELOW了。<br><a href="https://specifications.freedesktop.org/wm-spec/1.3/ar01s05.html" target="_blank" rel="noopener">这里可以看到一些type的介绍</a>。</p><p>在_NET_WM_STATE中一共有这么几个类型：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_NET_WM_STATE_MODAL, ATOM</span><br><span class="line">_NET_WM_STATE_STICKY, ATOM</span><br><span class="line">_NET_WM_STATE_MAXIMIZED_VERT, ATOM</span><br><span class="line">_NET_WM_STATE_MAXIMIZED_HORZ, ATOM</span><br><span class="line">_NET_WM_STATE_SHADED, ATOM</span><br><span class="line">_NET_WM_STATE_SKIP_TASKBAR, ATOM</span><br><span class="line">_NET_WM_STATE_SKIP_PAGER, ATOM</span><br><span class="line">_NET_WM_STATE_HIDDEN, ATOM</span><br><span class="line">_NET_WM_STATE_FULLSCREEN, ATOM</span><br><span class="line">_NET_WM_STATE_ABOVE, ATOM</span><br><span class="line">_NET_WM_STATE_BELOW, ATOM</span><br><span class="line">_NET_WM_STATE_DEMANDS_ATTENTION, ATOM</span><br></pre></td></tr></table></figure><p>如果程序被注册成_NET_WM_STATE_BELOW，则会被放置在DESKTOP之上的一层。不是很清楚Qt是出于什么策略，才把我的阴影注册为这个状态，反而是刚好满足了我的需求。</p><p>这要多谢曹哥了，我才终于明白了为什么会这样，以及以后如何正确的设置type。</p><img src="/2017/08/23/%E5%BC%80%E5%8F%91topbar%E4%B8%AD%E7%9A%84%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/DeepinScreenshot_%E6%A1%8C%E9%9D%A2_20170823201608.png" class="" title="DESKTOP1"><img src="/2017/08/23/%E5%BC%80%E5%8F%91topbar%E4%B8%AD%E7%9A%84%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/DeepinScreenshot_%E6%A1%8C%E9%9D%A2_20170823201641.png" class="" title="DESKTOP2">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TKL主题优化 -&lt;转&gt;</title>
      <link href="/2017/08/20/TKL%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96-%E8%BD%AC/"/>
      <url>/2017/08/20/TKL%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96-%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<p><a href="http://suninuni.com/2015/09/30/frontend/hexo/hexo-config/" target="_blank" rel="noopener">http://suninuni.com/2015/09/30/frontend/hexo/hexo-config/</a></p><p>这个主题确实挺好的，我也魔改了一部分来达成自己的目的，添加tags是看的这篇文章。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>debug了两天，只删了一行代码</title>
      <link href="/2017/08/16/debug%E4%BA%86%E4%B8%A4%E5%A4%A9%EF%BC%8C%E5%8F%AA%E5%88%A0%E4%BA%86%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/"/>
      <url>/2017/08/16/debug%E4%BA%86%E4%B8%A4%E5%A4%A9%EF%BC%8C%E5%8F%AA%E5%88%A0%E4%BA%86%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>前言： 项目一定要留一些文档！！ 修bug前一定要知道所有的流程！！！</p><a id="more"></a><p>这两天一直在修一个用户切换的bug，众所周知，deepin的多用户切换一直都不是正常工作的，确切来说是压根没有正常工作，还好用户不是经常切换，不然早就收到一大波的报告了。</p><p>dde-session-ui项目中包含了以下软件：</p><ul><li>dde-lock</li><li>dde-shutdown</li><li>dde-osd</li><li>lightdm-deepin-greeter</li><li>dde-switchtogreeter</li><li>dde-suspend-dialog</li><li>dde-warning-dialog</li><li>dde-welcome</li><li>dde-wm-chooser</li><li>dde-lowpower</li><li>dde-offline-upgrader</li></ul><p>大部分项目根据名字就可以知道是做什么的，这是一个软件组的集合。<br>而dde-lock和lightdm-deepin-greeter二者有大量重复的功能和代码，这是它俩的工作性质决定的。</p><blockquote><p>lightdm-deepin-greeter: display-manager启动的实体，登录的界面是它负责的。</p></blockquote><blockquote><p>dde-lock： 用户层面的屏幕锁定，基于我们的设计，和lightdm-deepin-greeter是大致相同的布局。</p></blockquote><p>而且都包含了用户密码的验证，用户的切换，但是二者工作的层面是不同的，为了方便切换，就有了dde-switchtogreeter，用来协调二者的工作，只需要提供用户名就可以切换。</p><p>然而，虽然这样的想法是很好的，可是当初并没有人写文档，随着人员的变动，现在公司应该没有一个人是比较完整了解整个的工作流程了，用户切换的bug也就这样被留下来了。</p><p>上次修复用户切换的问题，是发现登录以后lightdm-deepin-greeter没有退出，由于不是很清楚linux的登录流程，再加上代码中有不工作的退出代码，当时就改好了退出的问题，这样就引入了第二个问题，而这个问题，就导致了两天三个人在一直查找问题所在。</p><p>这次的问题是发现一直切换greeter，会导致Xorg一直在开新的display，这就很奇怪了，正常来说是不会一直创建才对。</p><p>最开始以为是dde-switchtogreeter的问题，毕竟切换是它在做，dde-switchtogreeter是单文件的c代码，代码没有任何的说明，真的是为切换而生，我从main函数开始自己走了好几遍的流程，一边看着d-feet的数据来验证，然而只发现了一个小问题，整个代码是没啥问题的。</p><p>最后在后端大佬的帮助下，知道了display-manager会自己退掉greeter，不需要自己退，然后我就想起来了以前改的地方，赶紧把退出代码删掉，重新编译，问题得到了解决。</p><p>如果我知道display-manager的工作流程，也许这个问题就不会拖两天了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>正常的流程在界面上却是bug</title>
      <link href="/2017/08/15/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9C%A8%E7%95%8C%E9%9D%A2%E4%B8%8A%E5%8D%B4%E6%98%AFbug/"/>
      <url>/2017/08/15/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9C%A8%E7%95%8C%E9%9D%A2%E4%B8%8A%E5%8D%B4%E6%98%AFbug/</url>
      
        <content type="html"><![CDATA[<p>排查了一天，最后终于确认了流程，知道了问题所在，不得不说，dde-session-ui这个项目太需要一个文档了，要把工作流程写的非常详细才可以。</p><a id="more"></a><p>上午收到了一条新任务，是龙芯上新安装的系统需要输入两次密码才可以登录，没有错误提示。近期并没有什么太大的改动，无非是给龙芯也用上了简单重构过的dde-session-ui，怎么会导致这样的问题。</p><p>由于是新安装的系统才会发生，而且是现象一旦发生，就无法重现，这让我头有点大，怎么会有这样的神奇的事情，而且日志中很正常，没有收到message导致密码框被清空。我提交了一个添加了更多日志的，然后重装的龙芯的系统(龙芯重装一次要半个小时)，等重装完了，切换到tty去安装这个包，然后重启lightdm，让我输入密码回车以后，密码消失，我赶紧去看日志，但是日志中并没有我的输出，回车以后肯定会有的一行输出也没有(内心OS：What the fuck is that？)</p><p>我又回去看验证的流程，并没有发现有什么不对的地方，而且是近期才有的，我在自己电脑上使用了龙芯的编译参数，打了一个deb包，并没有发生和龙芯一样的情况（这里并不需要，既然是新安装的系统才会发生，在旧系统上是无法重现的）。</p><p>再然后我暂时没有管这个，先去修其他bug了。忙完以后，我去问了一下其他大佬，大佬给我提了几条让我去看看，是不是起了两个lightdm-deepin-greeter进程，确认一下使用的二进制是不是你加了log的。（然后我又重装龙芯了），之后确认了是我的二进制，也没有起两个进程。但是ps中有两行输出，我以为是起了两个，就让后端大佬看了一下，后端大佬告诉我说一个是shell的进程，一个是本体，还是只有一个进程存在的。我彻底懵逼了，然后后端大佬告诉我，是不是greeter进程写入什么了，之后的验证中内容已经存在，所以就不会重现了。</p><p>其实这个我也想过，但是没考虑太深，greeter并没有操作文件，但是大佬这么一说，我想到有一些dbus的调用，是有写入文件的，然后我把/var/lib/lightdm/lightdm-deepin-greeter目录给删除了，完美重现。</p><p>我的天啊，排查了快一天，居然是这个目录在新装的系统上没有，所以回车登录以后收到了来自dbus的switchToUser，界面重启导致的内容消失，根本不是收到了Message才被清空的，所以我的log也没有打印出来。</p><p>知道了如何重现，可是要怎么修复呢，似乎在greeter上并不能修复，只能去改dde-daemon中LockService，如果文件不存在，就不要发送userChanged的信号。（流程是读取这个文件的信息，和传入的参数进行对比，但是文件是空的，所以被认为不是同一个账户，就发送了信号，也导致了界面上重启，以后无法重现是因为里面已经有内容了）。</p><p>就这样，一个流程很正确，但是表现到界面上时就成了一个bug的问题被解决了。写下这篇内容是为了记录我如何解决对我来说很棘手的问题，其实这个问题并不是很困难，但是对整个工作的流程不是很熟悉，导致浪费了大量的时间在非关键点处理，有空要写一些文档了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在deepin上使用dnsmasq来解决dns解析缓慢</title>
      <link href="/2017/08/11/%E5%9C%A8deepin%E4%B8%8A%E4%BD%BF%E7%94%A8dnsmasq%E6%9D%A5%E8%A7%A3%E5%86%B3dns%E8%A7%A3%E6%9E%90%E7%BC%93%E6%85%A2/"/>
      <url>/2017/08/11/%E5%9C%A8deepin%E4%B8%8A%E4%BD%BF%E7%94%A8dnsmasq%E6%9D%A5%E8%A7%A3%E5%86%B3dns%E8%A7%A3%E6%9E%90%E7%BC%93%E6%85%A2/</url>
      
        <content type="html"><![CDATA[<p>其实这个问题影响并不是很大，只是稍微的增加一点点访问速度，缓存这东西有利有弊。</p><a id="more"></a><p>在写完这篇文章以后，我就不用dnsmasq了，现在用的是github上的<a href="https://github.com/chengr28/Pcap_DNSProxy" target="_blank" rel="noopener">Pcap_DNSProxy</a>。用来防止dns污染的。</p><p>根据<a href="https://stackoverflow.com/questions/11020027/dns-caching-in-linux" target="_blank" rel="noopener">https://stackoverflow.com/questions/11020027/dns-caching-in-linux</a> 中回答者提供的信息来看，linux发行版是不提供dns解析缓存的，上面提到的nscd也不在deepin的预装列表中，所以我们只能自己动手丰衣足食了。</p><p>首先安装口碑较好的dnsmasq，来为我们提供dns缓存。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install dnsmasq</span><br></pre></td></tr></table></figure><p>如果是deepin最新的2015.4.1版本中安装，安装结束会提醒一个错误，这个错误的解决办法来自<a href="https://stackoverflow.com/questions/16939306/i-cant-restart-my-dnsmasq-service-so-my-fog-server-wont-work" target="_blank" rel="noopener">https://stackoverflow.com/questions/16939306/i-cant-restart-my-dnsmasq-service-so-my-fog-server-wont-work</a>.<br>这个错误似乎是因为/usr/share/dns/root.ds文件更新后结构导致的错误。</p><p>编辑/etc/init.d/dnsmasq，并找到</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ROOT_DS&#x3D;&quot;&#x2F;usr&#x2F;share&#x2F;dns&#x2F;root.ds&quot;</span><br><span class="line"></span><br><span class="line">if [ -f $ROOT_DS ]; then</span><br><span class="line">   DNSMASQ_OPTS&#x3D;&quot;$DNSMASQ_OPTS &#96;sed -e s&#x2F;&quot;. IN DS &quot;&#x2F;--trust-anchor&#x3D;.,&#x2F; -e s&#x2F;&quot; &quot;&#x2F;,&#x2F;g $ROOT_DS | tr &#39;\n&#39; &#39; &#39;&#96;&quot; </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ROOT_DS&#x3D;&quot;&#x2F;usr&#x2F;share&#x2F;dns&#x2F;root.ds&quot;</span><br><span class="line"></span><br><span class="line">if [ -f $ROOT_DS ]; then</span><br><span class="line">   DNSMASQ_OPTS&#x3D;&quot;$DNSMASQ_OPTS &#96;sed -e s&#x2F;&quot;.*IN[[:space:]]DS[[:space:]]&quot;&#x2F;--trust-anchor&#x3D;.,&#x2F; -e s&#x2F;&quot;[[:space:]]&quot;&#x2F;,&#x2F;g $ROOT_DS | tr &#39;\n&#39; &#39; &#39;&#96;&quot; </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>当错误解决以后，我们手动重启一下dnsmasq的systemd服务。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart dnsmasq</span><br></pre></td></tr></table></figure><p>deepin的/etc/resolv.conf来自/etc/NetworkManager/resolv.conf.是一个软连接。我采取的行为是删除这个文件，重新创建。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm &#x2F;etc&#x2F;resolv.conf</span><br><span class="line"></span><br><span class="line">sudo vim &#x2F;etc&#x2F;resolv.conf</span><br></pre></td></tr></table></figure><p>然后写入本地地址当做dns地址。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nameserver 127.0.0.1</span><br></pre></td></tr></table></figure><p>dnsmasq是一个本地的dns和dhcp服务器，当我们在上面成功启动dnsmasq以后，个人系统中就已经在提供dns服务了，所以本机使用回环地址来表明dns服务器就是本机，所有的dns查询都会发送到本机的dnsmasq中。</p><p>如果需要额外添加dns服务器，做法来自<a href="https://wiki.archlinux.org/index.php/Dnsmasq#More_than_three_nameservers" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Dnsmasq#More_than_three_nameservers</a>.</p><p>创建一个 /etc/resolv.dnsmasq.conf，写入其他dns服务器的地址。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nameserver 114.114.114.114</span><br></pre></td></tr></table></figure><p>然后编辑 /etc/dnsmasq.conf,找到resolv-file字段，改为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">resolv-file&#x3D;&#x2F;etc&#x2F;resolv.dnsmasq.conf</span><br></pre></td></tr></table></figure><p>然后重启dnsmasq。</p><p>验证的话通过dig命令。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dig blog.mkacg.com</span><br></pre></td></tr></table></figure><p>通过执行两次来判断，Query time在第二次查询是为0 msec。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PPA</title>
      <link href="/2017/07/24/PPA/"/>
      <url>/2017/07/24/PPA/</url>
      
        <content type="html"><![CDATA[<p>也许需要安装dirmngr</p><p>maybe you need install dirmngr</p><p>追加内容到/etc/apt/sources.list</p><p>Append content to /etc/apt/sources.list</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb [arch&#x3D;amd64] https:&#x2F;&#x2F;packages.mkacg.com panda main</span><br></pre></td></tr></table></figure><p>导入key </p><p>import key</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 3BBF73EE77F2FB2A</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>topbar PPA</title>
      <link href="/2017/07/20/topbar-PPA/"/>
      <url>/2017/07/20/topbar-PPA/</url>
      
        <content type="html"><![CDATA[<p>自己搭了一个仓库，提供deepin-topbar及相关依赖的包。</p><p>I created a repository,provide deepin-topbar and dependencies.</p><a id="more"></a><p>也许需要安装dirmngr</p><p>maybe you need install dirmngr</p><h1 id="追加内容到-etc-apt-sources-list"><a href="#追加内容到-etc-apt-sources-list" class="headerlink" title="追加内容到/etc/apt/sources.list"></a>追加内容到/etc/apt/sources.list</h1><p>Append content to /etc/apt/sources.list</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb [arch&#x3D;amd64] https:&#x2F;&#x2F;packages.mkacg.com panda main</span><br></pre></td></tr></table></figure><h1 id="导入key"><a href="#导入key" class="headerlink" title="导入key"></a>导入key</h1><p>import key</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 3BBF73EE77F2FB2A</span><br></pre></td></tr></table></figure><h1 id="刷新列表，进行安装"><a href="#刷新列表，进行安装" class="headerlink" title="刷新列表，进行安装"></a>刷新列表，进行安装</h1><p>then, refresh list and install</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install deepin-topbar</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>webhook</title>
      <link href="/2017/07/14/webhook/"/>
      <url>/2017/07/14/webhook/</url>
      
        <content type="html"><![CDATA[<p>blog现在是用hexo，放在自己的<a href="https://code.mkacg.com/" target="_blank" rel="noopener">code</a>网站上。</p><p>code是用无闻大大的gogs搭建的，跑在台式机的docker中，本机跑了很多docker服务，有hexo，有aria2c，有gogs，还有个webserver caddy。</p><p>caddy这东西还是基友 <a href="https://mioto.me/" target="_blank" rel="noopener">不爱写博客的mioto</a>推荐给我的，之前我一直是用nginx的，那配置文件太复杂了，根本玩不来。</p><p>写一篇文章，会先提交到code，然后触发webhook，caddy会拉取code中的文章，由于是静态的，所以不需要处理其他的，只需要拉取最新的就可以了。</p><p>caddy的配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blog.mkacg.com &#123;</span><br><span class="line">    gzip</span><br><span class="line">    redir 301 &#123;</span><br><span class="line">    if &#123;&gt;X-Forwarded-Proto&#125; is http</span><br><span class="line">        &#x2F;  https:&#x2F;&#x2F;&#123;host&#125;&#123;uri&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tls kirigaya@mkacg.com</span><br><span class="line">    root &#x2F;srv&#x2F;www&#x2F;blog</span><br><span class="line">    git code.mkacg.com&#x2F;kirigayakazushin&#x2F;blog &#123;</span><br><span class="line">        path &#x2F;srv&#x2F;www&#x2F;blog</span><br><span class="line">        branch gh-pages</span><br><span class="line">        hook &#x2F;_webhook xxx</span><br><span class="line">        hook_type gogs</span><br><span class="line">        then git pull</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gogs上只需要创建一个webhook，地址填写成caddy中的hook地址，加密填写hook后的xxx即可，加密自己设置。</p><p>然后就可以提交了。</p><p>提交会触发push操作，gogs会根据设置的webhook中的规则，执行和push相关的webhook，webhook会向指定的url发送POST操作，发送的内容中包含了相关信息，caddy会根据相关信息，来处理webhook，执行你规定的操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SAOUTILS</title>
      <link href="/2017/07/04/SAOUTILS/"/>
      <url>/2017/07/04/SAOUTILS/</url>
      
        <content type="html"><![CDATA[<p>鼠标手势还没想好要怎么实现，流程无法完全确认，这项稍后再做。</p><p>主界面有两层构成，半透明全屏黑色背景和菜单。</p><p>菜单较为复杂，除了左边是一个大面板，其他部分全部都可以使用一种方式实现。使用Qt的QAbstractItemDelegate、QListView来做列表和界面绘制。</p><p>右边则是无限展开的菜单。</p><p>每层菜单只是用一个对象，和topbar dock的popup window一样。<br>点击每层菜单的时候，计算下一项要显示的位置。</p><p>主界面应该是只有左右两部分，除了左边的大面板，右侧全部都是相同结构的菜单，只不过在功能上略有不同。</p><p>点击的时候，所有菜单对鼠标点击的地点进行坐标计算，如果在鼠标右侧，则隐藏。如果要显示的菜单是自己，不隐藏。点击时开始timer，松开时停止，timeout以后显示选项。</p><p>保持最后一个菜单在最中间的位置，主界面向左或向右用动画移动固定长度。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Topbar</title>
      <link href="/2017/06/26/Topbar/"/>
      <url>/2017/06/26/Topbar/</url>
      
        <content type="html"><![CDATA[<p>　　topbar的架构参考的是dde-dock，就是一个精简的dock，只有一个方向，一个位置，没有右键菜单，只有插件类型。</p><a id="more"></a><p><video controls="" autoplay="false" name="media"><source src="https://cache.mkacg.com/t.mp4" type="video/mp4"></video></p><p>　　计划是用来支持各种各样的方便的插件，比如：</p><ul><li>活动窗口指示器</li><li>多媒体控制器</li><li>电源控制</li><li>时间控制</li></ul><p>计划要完成有：</p><ul><li>shadowsocks</li><li>vpn控制器</li><li>系统资源监视器</li></ul><p>剩下的计划待完成的插件由于各种原因，开发比较难，还需要学习一部分知识才可以完成。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArchLinux运行steam出现缺少LibGL--steam libGL error: failed to load driver: swrast</title>
      <link href="/2016/07/15/ArchLinux%E8%BF%90%E8%A1%8Csteam%E5%87%BA%E7%8E%B0%E7%BC%BA%E5%B0%91LibGL-steam-libGL-error-failed-to-load-driver-swrast/"/>
      <url>/2016/07/15/ArchLinux%E8%BF%90%E8%A1%8Csteam%E5%87%BA%E7%8E%B0%E7%BC%BA%E5%B0%91LibGL-steam-libGL-error-failed-to-load-driver-swrast/</url>
      
        <content type="html"><![CDATA[<p>其实arch的wiki已经提到了，而且这个问题是比较常见的，只需要删除steam的库就行。</p><p><a href="https://wiki.archlinux.org/index.php/Steam/Troubleshooting#Deleting_the_runtime_libraries" target="_blank" rel="noopener">wiki原文链接</a></p><a id="more"></a><p>删除运行库<br>运行此命令，删除在issues上已知的运行库问题:</p><pre><code>find ~/.steam/root/ \( -name &quot;libgcc_s.so*&quot; -o -name &quot;libstdc++.so*&quot; -o -name &quot;libxcb.so*&quot; -o -name &quot;libgpg-error.so*&quot; \) -print -delete</code></pre><p>如果上面的命令不工作，则再次运行上面的命令，然后运行此命令。</p><pre><code>find ~/.local/share/Steam/ \( -name &quot;libgcc_s.so*&quot; -o -name &quot;libstdc++.so*&quot; -o -name &quot;libxcb.so*&quot; -o -name &quot;libgpg-error.so*&quot; \) -print -delete</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 实验室 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker-hexo</title>
      <link href="/2016/07/15/docker-hexo/"/>
      <url>/2016/07/15/docker-hexo/</url>
      
        <content type="html"><![CDATA[<p>引用一下基友的话</p><blockquote><p>最开始接触 Hexo 的时候是在 Windows 下, 安装过程还算顺利, 因此在初期还整理了6篇关于 Hexo 博客的搭建教程.</p></blockquote><blockquote><p>后来转投 Linux 大法, 期间重装电脑无数次, 每一次安装 Hexo 所需要的 nodejs, 和各种插件的时候都是闹心的过程, 玩的多了自然就熟了, Linux 下的安装基本没问题了.</p></blockquote><a id="more"></a><blockquote><p>然后入职公司, 公司配了 Mac Pro 又需要安装 Nodejs, 以及各种插件, 人傻搞不定啊.., 晚上迷迷糊糊的还 rm -rf /usr/bin 了.., 所以决定放弃在实体机安装 Nodejs 的想法转战到了 Docker.</p></blockquote><blockquote><p>来自mashiro.io</p></blockquote><p>他后来更新了一下dockerfile，他觉得以前的思路是错的，现在他要把hexo封装进docker当做工具，又写了几个alias。<br>安装docker，然后pull镜像</p><pre><code>docker pull kirigayakazushin/docker-hexo</code></pre><p>pull镜像以后，写入alias，将docker-hexo当做本地工具。</p><pre><code>alias hexo=&#39;docker run -it --rm -p 4000:4000 -v $PWD:/Hexo -v $HOME/.gitconfig:/home/docker/.gitconfig -v $HOME/.ssh:/home/docker/.ssh kirigayakazushin/docker-hexo hexo&#39;alias npm=&#39;docker run -it --rm -v $PWD:/Hexo kirigayakazushin/docker-hexo npm&#39;alias ddnone=&quot;docker images | grep none | awk &#39;{print \$3}&#39; |xargs docker rmi&quot;</code></pre><p>然后执行一下命令</p><pre><code>npm install hexo-generator-sitemap --save \&amp;&amp; npm install hexo-generator-feed --save \&amp;&amp; npm install hexo-deployer-git --save</code></pre><p>把以上内容写进rc文件，我是用zsh的，所以写入~/.zshrc。</p><img src="/2016/07/15/docker-hexo/zshrc.png" class="" title="zshrc"><p>接下来基本演示一下使用方式。</p><img src="/2016/07/15/docker-hexo/ys1.png" class="" title="ys1"><img src="/2016/07/15/docker-hexo/ys2.png" class="" title="ys2"><img src="/2016/07/15/docker-hexo/ys3.png" class="" title="ys3"><img src="/2016/07/15/docker-hexo/ys4.png" class="" title="ys4"><img src="/2016/07/15/docker-hexo/ys5.png" class="" title="ys5">]]></content>
      
      
      
        <tags>
            
            <tag> 实验室 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker-aria2c</title>
      <link href="/2016/05/31/docker-aria2c/"/>
      <url>/2016/05/31/docker-aria2c/</url>
      
        <content type="html"><![CDATA[<p>该项目是将aria2c封装进docker并提供服务。</p><pre><code>docker pull kirigayakazushin/docker-aria2c</code></pre><a id="more"></a><p>下载好镜像，然后保存一份运行</p><pre><code>docker run -p 6800:6800 --name docker-aria2c -d \-v {下载目录的绝对路径}:/aria2/downloads \imashiro/docker-aria2c</code></pre><p>打开浏览器，访问<a href="http://yaaw.qiniudn.com/" target="_blank" rel="noopener">http://yaaw.qiniudn.com/</a><br>输入</p><pre><code>http://token:secret@127.0.0.1:6800/jsonrpc</code></pre><p>注意，暂时还无法处理文件的所有权，目前下载好的文件归属root。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实验室 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>aria2配置</title>
      <link href="/2016/05/25/aria2%E9%85%8D%E7%BD%AE/"/>
      <url>/2016/05/25/aria2%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>安装好aria2，然后执行一下内容</p><pre><code>$ sudo nano /etc/systemd/user/aria2.service  [Unit]Description=Aria2 ServiceAfter=network.target[Service]ExecStart=/usr/bin/aria2c --enable-rpc --rpc-listen-all=true   --rpc-secret=secret  --rpc-allow-origin-all  --conf-path=/home/用户名字/.config/aria2/aria2.conf  --input-file /home/用户名字/.config/aria2/session.lock --disk-cache=100M --max-overall-download-limit=0  --split=10 --max-connection-per-server=10 --max-concurrent-downloads=4   --dir=/home/用户名字/Downloads/[Install]WantedBy=default.target</code></pre><a id="more"></a><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>以上内容需要把用户名字更改成自己的</p><p>在用户目录新建三个文件</p><pre><code>touch ~/.config/aria2.conf  touch ~/.config/aria2.session  touch ~/.config/session.lock</code></pre><p>~/.config/aria2.conf 里面需要填写以下内容，其他两个文件保持空。</p><pre><code>dir=下载目录【需要自行修改】enable-rpc=true</code></pre><p>启动服务  </p><pre><code>systemctl --user enable aria2systemctl --user start aria</code></pre><p>浏览器打开：<a href="http://yaaw.qiniudn.com/" target="_blank" rel="noopener" title="aria2">http://yaaw.qiniudn.com/</a><br>将服务器地址改成</p><pre><code>http://token:secret@127.0.0.1:6800/jsonrpc</code></pre><p>然后应该页面的右上角就显示网速了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下安装vmware及archlinux的安装和配置</title>
      <link href="/2016/04/10/linux%E4%B8%8B%E5%AE%89%E8%A3%85vmware%E5%8F%8Aarchlinux%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
      <url>/2016/04/10/linux%E4%B8%8B%E5%AE%89%E8%A3%85vmware%E5%8F%8Aarchlinux%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>视频中给出了vmware的下载地址和安装过程，系统的下载我也会演示一遍。<br>这篇教程会一篇完成，从安装到配置和美化，顺便也总结一下我的成果。<br>由于我已经安装过一次vmware了，所以有个脚本的地方没有出现，输入界面上的提示信息即可。<br>宿舍太乱，所以就没有录麦克风，操作我会尽量慢一些，然后打字讲述。<br>这次大更。。gtk主题还没更新上来，所以界面好丑。  = =。<br>安装完成以后安装源里面的vmware-patch。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Archlinux 添加漂亮的字体</title>
      <link href="/2016/04/08/font-config/"/>
      <url>/2016/04/08/font-config/</url>
      
        <content type="html"><![CDATA[<p>该教程不能保证适用于所有人的情况。<br>字体也不是配置，而是补充了字体。使用的是第三方的源。</p><a id="more"></a><p>打开/etc/pacman.conf文件，添加以下内容到最底部。</p><pre><code>[infinality-bundle]SigLevel = NeverServer = http://bohoomil.com/repo/$arch[infinality-bundle-multilib]SigLevel = NeverServer = http://bohoomil.com/repo/multilib/$arch[infinality-bundle-fonts]SigLevel = NeverServer = http://bohoomil.com/repo/fonts</code></pre><p>执行安装命令:</p><pre><code>sudo pacman -S infinality-bundle infinality-bundle-multilib ibfonts-meta-extended  #（用于64位系统）sudo pacman -S infinality-bundle ibfonts-meta-extended #（用于32位系统）</code></pre><p>如果有遇到错误，可以手动添加hosts：</p><pre><code>188.226.219.173 bohoomil.com</code></pre><p>会出现很多冲突，选择Y，然后安装。如果中断了，重新执行安装命令。</p><p>来自：<a href="https://linux.cn/article-3019-1.html" target="_blank" rel="noopener" title="如何给任意一款 Linux 发行版添加漂亮的字体-桌面应用|Linux.中国-开源社区">如何给任意一款 Linux 发行版添加漂亮的字体-桌面应用|Linux.中国-开源社区</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My Life</title>
      <link href="/2016/03/25/my-life/"/>
      <url>/2016/03/25/my-life/</url>
      
        <content type="html"><![CDATA[<p>这是我用markdown写的第一篇文章(水文)，先来个自我介绍吧，我是小竹，对没错，是小竹，不是竹子，不是竹酱，更不是竹基。</p><a id="more"></a><p>我玩linux应该有五六年了吧，初二的时候接触的，不过很多年都保持在换各种发行版上，并没有真正意义的玩。上了大学以后，接触的更多了，玩的也更嗨了。<br>现在也用上arch+btrfs+uefi了，各种叼炸天。<br>irc里面也经常学习【看别人装逼。<br>依旧是英语渣渣，数学渣渣，看到win32api，我直接放弃win编程了，我的智商也就玩玩wpf了。<br>下面就贴几张我的日常截图。</p><!-- more --><p><strong>My Computer info</strong></p><pre><code>kirigayaloveyousei@linuserOS: Arch LinuxKernel: x86_64 Linux 4.4.5-1-ARCHackages: 1092Shell: zsh 5.2Resolution: 1366x768WM: Mutter(DeepinGala)WM Theme: AdwaitaGTK Theme: Arc-OSX [GTK2/3]Icon Theme: deepinFont: Noto Sans CJK SC Regular 10CPU: Intel Core i5-4210U CPU @ 2.7GHzRAM: 1980MiB / 3861MiB</code></pre><img src="/2016/03/25/my-life/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE20160403224356.png" class="" title="pic1"><img src="/2016/03/25/my-life/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE20160403224410.png" class="" title="pic1"><img src="/2016/03/25/my-life/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE20160403224524.png" class="" title="pic1"><img src="/2016/03/25/my-life/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE20160403224634.png" class="" title="pic1"><img src="/2016/03/25/my-life/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE20160403233112.png" class="" title="pic1"><img src="/2016/03/25/my-life/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE20160403233229.png" class="" title="pic1">]]></content>
      
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标题</title>
      <link href="/2016/03/25/page/"/>
      <url>/2016/03/25/page/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
      
        <tags>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
